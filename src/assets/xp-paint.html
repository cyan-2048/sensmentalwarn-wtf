<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <title>XP Paint</title>

  <style>
    button::-moz-focus-inner,
    [type="button"]::-moz-focus-inner,
    [type="reset"]::-moz-focus-inner,
    [type="submit"]::-moz-focus-inner {
      border-style: none;
      padding: 0
    }

    button:-moz-focusring,
    [type="button"]:-moz-focusring,
    [type="reset"]:-moz-focusring,
    [type="submit"]:-moz-focusring {
      outline: 1px dotted ButtonText
    }
  </style>
  <style>
    html,
    body,
    .jspaint {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      border: 0;
      overflow: hidden
    }

    .choose-shape-style {
      flex-flow: column
    }

    .choose-eraser,
    .choose-magnification,
    .choose-stroke-size,
    .choose-transparent-mode {
      flex-flow: column;
      align-items: center;
      justify-content: space-around
    }

    .choose-brush,
    .choose-airbrush-size {
      flex-flow: row wrap;
      justify-content: space-around;
      align-content: space-around
    }

    .tool-options canvas {
      flex: 0 0 auto
    }

    .jspaint :not(table):not(tbody):not(tr):not(td) {
      display: flex
    }

    .component-window .window-content,
    .component-window .window-content :not(table):not(tbody):not(tr):not(td) {
      display: flex
    }

    .jspaint {
      display: flex;
      flex-flow: column;
      flex: 1
    }

    .horizontal {
      flex-flow: row;
      flex: 1 1 0;
      overflow: hidden
    }

    .vertical {
      flex-flow: column;
      flex: 1
    }

    .jspaint>.vertical {
      height: 100%
    }

    @media (max-width:200px) {
      .horizontal>.component-area {
        display: none
      }
    }

    @media (max-height:340px) {
      .vertical>.component-area {
        display: none
      }
    }

    @media (max-height:359px) {
      .vertical>.status-area {
        display: none !important
      }
    }

    .window,
    .window-content {
      max-width: 100vw;
      max-height: 100vh
    }

    .component-area,
    .tool-window .window-titlebar {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none
    }

    .status-area,
    .component-area {
      flex: 0 0 auto
    }

    .selection,
    .textbox,
    .helper-layer {
      z-index: 3
    }

    .selection,
    .textbox {
      display: block !important;
      box-sizing: border-box;
      -moz-box-sizing: border-box
    }

    .textbox>img,
    .textbox>canvas,
    .selection>img,
    .selection>canvas {
      opacity: 0
    }

    .selection>img,
    .selection>canvas,
    .helper-layer>canvas {
      width: 100%;
      height: 100%
    }

    .resize-ghost,
    .component-ghost {
      pointer-events: none
    }

    .resize-ghost {
      z-index: 4
    }

    .component-ghost {
      z-index: 5001
    }

    .textbox-editor {
      color: transparent !important;
      background: transparent !important;
      caret-color: black;
      z-index: 4;
      outline: none
    }

    .menu-container {
      position: relative
    }

    .menu-popup {
      position: absolute;
      top: 100%;
      left: 0;
      z-index: 5002;
      box-sizing: border-box
    }

    .menu-popup-table {
      border-collapse: collapse
    }

    .menu-item {
      white-space: nowrap
    }

    .menu-hr {
      display: block !important;
      height: 0;
      width: auto
    }

    .menu-hotkey {
      display: inline !important
    }

    .menu-item-checkbox-area,
    .menu-item-submenu-area {
      min-width: 16px
    }

    .menu-item-checkbox-area,
    .menu-item-submenu-area {
      text-align: center
    }

    .status-area {
      overflow: hidden;
      white-space: nowrap;
      cursor: default;
      height: 1.25em
    }

    .status-text {
      flex-basis: auto;
      flex-grow: 1;
      flex-shrink: 0;
      padding-right: 2px;
      overflow: hidden
    }

    .status-coordinates {
      flex: 0 0 114px;
      min-width: 0px;
      padding-left: 3px;
      border-left: 1px solid #7b7b7b
    }

    .hover-halo {
      pointer-events: none;
      z-index: 1000000;
      box-shadow: 0 0 10px yellow, 0 0 3px yellow
    }

    .dwell-indicator {
      position: fixed;
      pointer-events: none;
      z-index: 1000000
    }

    .dwell-indicator::after {
      content: "";
      display: block;
      position: absolute;
      background: red;
      left: 2px;
      top: 2px;
      right: 2px;
      bottom: 2px
    }

    .dwell-indicator:not(.for-release) {
      background: yellow
    }

    .dwell-indicator.for-release {
      background: white
    }

    .dwell-indicator:not(.for-release),
    .dwell-indicator:not(.for-release)::after {
      border-radius: 50%
    }

    .dwell-indicator.for-release,
    .dwell-indicator.for-release::after {
      clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%)
    }

    .eye-gaze-mode .color-button {
      width: 25px;
      height: 25px
    }

    .eye-gaze-mode .Colors-component.tall {
      width: 50px
    }

    .eye-gaze-mode .Colors-component.tall .color-box {
      width: 100%
    }

    .eye-gaze-mode .Colors-component.tall .current-colors {
      width: 100%
    }

    .eye-gaze-mode .Colors-component.tall .foreground-color {
      left: 12px
    }

    .eye-gaze-mode .Colors-component.tall .background-color {
      right: 12px
    }

    .eye-gaze-mode .os-window .window-titlebar,
    .eye-gaze-mode .tool-window .window-titlebar {
      font-size: 2rem;
      line-height: 1.2;
      height: 2.8rem
    }

    .eye-gaze-mode .os-window .window-title-area,
    .eye-gaze-mode .tool-window .window-title-area {
      height: 100%
    }

    .eye-gaze-mode .os-window .window-titlebar button,
    .eye-gaze-mode .tool-window .window-titlebar button {
      transform: scale(3);
      margin-right: 32px
    }

    .eye-gaze-mode .tool-window .window-titlebar button {
      transform-origin: 0 0
    }

    .eye-gaze-mode .menu-button {
      padding-right: 10px;
      padding-left: 10px
    }

    .eye-gaze-mode .menu-button {
      height: 3rem;
      line-height: 2.5rem
    }

    .eye-gaze-mode .menu-button,
    .eye-gaze-mode .menu-button * {
      font-size: 2rem
    }

    .eye-gaze-mode .menu-item * {
      font-size: 2rem;
      line-height: 1.5
    }

    .eye-gaze-mode .status-area {
      padding-left: 170px
    }

    .component-area {
      position: relative
    }

    .Tools-component {
      height: 273px;
      align-items: center;
      padding-left: 4px;
      padding-right: 2px;
      flex-flow: column
    }

    .tool-options {
      margin-top: 3px;
      width: 41px;
      height: 66px;
      box-sizing: border-box;
      -moz-box-sizing: border-box
    }

    .tool-options>div {
      flex: 1
    }

    .tools {
      display: flex;
      flex-flow: row wrap
    }

    .tool {
      display: block !important;
      box-sizing: border-box;
      -moz-box-sizing: border-box;
      position: relative
    }

    .horizontal .component-area {
      flex-direction: column
    }

    .Colors-component {
      align-items: center;
      justify-content: center
    }

    .Colors-component.wide {
      height: 47px
    }

    .Colors-component.tall {
      width: 47px
    }

    .palette {
      display: flex
    }

    .Colors-component.wide .palette {
      flex-flow: row wrap
    }

    .Colors-component.tall .palette {
      flex-flow: column wrap
    }

    .Colors-component.wide .color-box,
    .Colors-component.wide .palette {
      flex-direction: row;
      height: 32px
    }

    .Colors-component.tall .color-box,
    .Colors-component.tall .palette {
      flex-direction: column;
      width: 32px
    }

    .Colors-component.wide .current-colors {
      width: 30px;
      height: 31px
    }

    .Colors-component.tall .current-colors {
      width: 31px;
      height: 32px
    }

    .current-colors,
    .color-button {
      position: relative
    }

    .foreground-color {
      position: absolute;
      left: 2px;
      top: 4px
    }

    .background-color {
      position: absolute;
      right: 3px;
      bottom: 3px
    }

    .Colors-component.tall .foreground-color {
      left: 4px;
      top: 3px
    }

    .Colors-component.tall .background-color {
      right: 3px;
      bottom: 3px
    }

    .Colors-component.wide .color-button,
    .Colors-component.wide .color-selection {
      margin-left: 1px
    }

    .Colors-component.tall .color-button,
    .Colors-component.tall .color-selection {
      margin-top: 1px
    }

    .color-button,
    .color-selection {
      padding: 0;
      box-sizing: border-box;
      width: 15px;
      height: 15px;
      border: 0
    }

    .color-button input {
      margin: 0;
      padding: 0;
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%
    }

    .canvas-area {
      flex: 1;
      display: block !important;
      position: relative;
      overflow: auto;
      padding: 3px
    }

    .main-canvas {
      position: absolute;
      z-index: 2
    }

    .handle {
      position: absolute;
      width: 3px;
      height: 3px;
      z-index: 1
    }

    .handle::after {
      content: "";
      pointer-events: all;
      display: block;
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 32px;
      height: 32px;
      max-width: inherit;
      max-height: inherit
    }

    .textbox::before {
      content: "";
      pointer-events: all;
      display: block;
      position: absolute;
      left: -10px;
      right: -10px;
      top: -10px;
      bottom: -10px
    }

    .tool-window .window-title {
      display: inline-block !important;
      margin: 0;
      padding: 0;
      cursor: default
    }

    .tool-window .window-close-button {
      display: block !important;
      float: right
    }

    .window-content .button-group {
      display: flex;
      flex: 0 0 auto;
      flex-flow: column
    }

    .window-content .button-group>button {
      min-width: 80px;
      padding: 3px 5px;
      white-space: nowrap
    }

    .window-content>form {
      display: flex;
      flex-flow: row
    }

    .dialogue-window .window-content>form {
      flex-flow: column
    }

    .dialogue-window .window-content>form>.button-group {
      flex-flow: row;
      justify-content: flex-end
    }

    .dialogue-window .window-content>form>div:first-child {
      padding: 5px
    }

    .flip-and-rotate fieldset {
      width: 200px
    }

    .os-window {
      display: flex;
      flex-direction: column
    }

    .os-window .window-content {
      flex: 1
    }

    .help-window .window-content {
      display: flex;
      flex-flow: column
    }

    .help-window .main {
      flex: 1;
      display: flex;
      flex-flow: row
    }

    .help-window .toolbar button {
      width: 55px;
      height: 40px;
      padding: 0;
      font-size: 12px;
      line-height: 60px
    }

    .help-window .toolbar button {
      position: relative
    }

    .help-window .toolbar button .icon {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0
    }

    .help-window .toolbar button .icon {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAVkAAAApCAYAAACfp1quAAAABmJLR0QA/wD/AP+gvaeTAAAD+klEQVR4nO3cXZLqOAxAYWVq9kV2htmZWZnmYRCtOA5J6NAtpc9XRXG5/JQV24piQ4sAAAAAGQ2/3QAAh9PmMfP8Fx198NvOfQcDAp+2NE4H91zGcbg2/zLG1NqTY0LE++/RH1hrffu94zge1g5ggarO5+n9fpdxHLWUIiIidh+QSj95PINSVRmGQTqxLL03lS05JlIuOTzJRgoOaGitVYZhEFWV+/0ul8vleV9r/VaR8MMsYU7OGL0TSCkl8kljt2w55iOVbK11ciDGcex2fmsY0p1kT1EZbJAtzu5gs3G5lmiD8/2wmmCzK6VoKWUy9rLlkn8+9cHZzjZvON+Ifi1VvFa9WQXnE6xPtD7BRpqYS0opfs3Y354sjl4F696fQaa2Ljq8kjW2LtRWBrfbbfbacRzlcrl8qimfoBbfX/GIN01F65OLv7LqJdql90VmFZ4lTWu3rcWWUmZrs06GflRV7eYL03vuer1+sk1v+faBXjozWrA2iHeU+Ck6XyRNe4+QLebZSdCPPzv52zJWkpgm2nnXbnJZkhWR2XG43W72uqgxP8dbm0h9XK9E6tNDKtlXZ492sLcHLVkV29uZPsPXZjZflmWraJcm5NZ9gmhcBdsef12qwv0c7F1dBjOZYz63tLmjfRyxihX54HKBZ52sqmEPxAazBLs2STMtJ+xJONkSrZ+MNv4yJlhvabnA/9vmnGeV7KOSj9aH3a/XLcmSS34kyfrOTromu6vz/4JMiTbLZNzCV7C9pbq2mm0TrVWyQavZYRiGzXPtz6zJysKlZrselG0dpWN3og0ej3e22NRfPbWVbC/xyFcsvQMRKc7Zie1R1W56s0+uj83ASLGZdg+gfXL1AyKNz8N/VttuKPjHIq/XZCMdmAXamZxrIsdjVkfti6QU0STJtlaSrMj0eESL0/8IYfZjBJGvJYHr9eo3uUTkK8nWWlNsfvX6ZimX+Co2wRh9m9ZaVf7veK21Ph9vITm+F5etvUfIFvOzraqqj0pPSymT/1+JKXqc2t5srlmc7b24OenmaWS9NqbLJR9bk11a80m6JuvtWjc6k6zVwZvrdNHjnFR3Nt9c9fesZO3eC7om2+pW6ibLmuzRJmfKk1ayJlt7vyNbrH48dW+Jx12PllJmc85Xsv41/vEvt/sd6XLJR9ZkWzv/dkH0CsJLsbt+gGxx7rrSSDjuelRkvrHlf15sv3Jza7QZY97Ut5H69Ee+wnViITrxB/yVODMbxG08i0w3uew+eYJNiT/ajTN6ZxyeZdzNfpxgTpJg9/RtiDhDNALAoV4lIuY8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADr/gN0lIbO8xCe1AAAAABJRU5ErkJggg==")
    }

    .help-window .toolbar button:not([disabled]):hover .icon {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAVkAAAApCAYAAACfp1quAAAABmJLR0QA/wD/AP+gvaeTAAAEKklEQVR4nO3cXXKzOhAE0Natb1+wM4adKSub+wDCkhCG2ODMmD5VFIn/IoFoj2UIQERERETkUfjrBhDR6bT6ncf5Hzp749c79xUcEHS1rXEasvs8jsO9489jn2q/yRgT/f3v/JfUNxaiy6mqol5ijACgDsbiVuN09YPMy/5znfGVJReEbHhjIbqUxhgRQjnWfn5+0HVdClovNFuvAzYnH2jNR907SzTGqCKiMcZlwVQ97IK1t6B93tr7Km/9bJY3aSzmYzLGWKyBtJi36l/W+Ok2yRaLJd4BIlK32V2WXFDJTvq+v+qlrTCzEz/EWX/LXIkxou/7Yh1CQNd1SyVbV7gWaTln3Czdll8Eqyq2EVqWeWrrpn9XvbAqEEK/+gg2juPqsX3fo+u6q5pyBZ07+Nft+Jypvwo3n8UezUzBCqAZtFvPs0wBDUBIoRsAjNiYGZD8RwEgCoj1jqoq0IiLRStLhmG4sEmveXtDb70zDoNMf2D+C3rgE9g84M3v/OXTpI/2nsFbn1VViwDNx18IYQna7HHW+1TQqsoL9b0I1S7L7nqksdU+L7trHKW4Q0TcZckplewUqKnIKYuduuCr332cVbHamK77htNmjn8sc1bRbh2QKWD9mXZAWG9/LVarZ8y/jAAGWP4yrNgtebbUgVtnicUqFjhtuqAO2FbQBqiq2Q1xwDpg9w5ST9MJvwkcZ0GbH4xp/PkM2FyKzqVexaH3SimOUWv7sLFb8vb6CNXaSSFbB2u536ahMG09p3OyrQr23hwFrZeD8Zj8nXtrUIbikcWjUrba3HOpFstvytZSPPg2c7LYePus54O8zaM0/D5obfcn9219W+ZkVXVVydZHcjXuWhvCUj9X8SgiKiJonk7QevryCmb3odb50bzzCUtZcvpltY8vFKYNlH/BADyfk7W0YTaUYXRsOsByf5L9Ubvut+V+FSFb2wlZoNwe1vrZmptbPyLNvdanHKhmzza9HzWbSw7l7e0syatYB1nysuVE7/TzF16M8LgW00d7z+Ctz8t4UlWdKz0VkeL2nXFnvZ+6WtLFFCIKnS9CyNdTGft4nJ8+Frd5y5LLzpPdukTR6ZxsLiCEe87ROq0OXpyns97PrH2i0CGrUOfTB1Ilm9ZpqmAMgIjlMwySp9/meZmTPVtxOe2XVrKJt/a+w1tf8/HUXByPu5XpXPWsQl0q2qySLW4XBaDOrv5K3GXJZZXsDRw8Z+ZrWK/sVvQmnzZEZBqLYahmbOdfJPuyS+Yq9vE8uhhD9j13GaR36adjT4J2CdhxDlgBuE8/5vSQ3frHMB7++QZ9j3uOtxS0mHK0Xs8VLJwHrLd966u1RHTEs3kSHvNERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERET7/gf6G4s+bg+MYAAAAABJRU5ErkJggg==")
    }

    .help-window .toolbar button[disabled] .icon {
      filter: saturate(0%) opacity(50%)
    }

    .help-window .contents {
      background: white;
      background: var(--Window);
      color: var(--WindowText);
      flex-basis: 300px;
      flex-grow: 0;
      flex-shrink: 0;
      overflow: auto;
      box-sizing: border-box
    }

    .help-window ul {
      margin: 0;
      padding: 0
    }

    .help-window li {
      display: block;
      white-space: nowrap
    }

    .help-window .item {
      display: inline-block
    }

    .help-window .folder:not(.expanded) ul {
      display: none
    }

    .help-window iframe {
      flex: 1;
      width: 0
    }

    .help-window li ul {
      padding-left: 16px
    }

    .help-window li:before {
      content: "";
      display: inline-block;
      vertical-align: middle;
      width: 16px;
      height: 16px;
      background-position: 0 0;
      margin-right: 2px
    }

    .help-window .folder.expanded:before {
      background-position: -16px 0
    }

    .help-window .page:before {
      background-position: -32px 0
    }

    .dragging iframe {
      pointer-events: none
    }

    .storage-manager table {
      max-height: 400px;
      overflow: auto;
      display: block
    }

    .storage-manager .thumbnail-container {
      width: 64px;
      height: 64px;
      display: flex;
      align-items: center;
      justify-content: center
    }

    .storage-manager .thumbnail-container>img {
      max-width: 64px;
      max-height: 64px;
      flex: 0 0 auto
    }

    .storage-manager .thumbnail-container,
    .storage-manager p {
      margin: 5px
    }

    .storage-manager .remove-button {
      margin-left: 15px
    }

    .history-view {
      width: 500px;
      height: 500px;
      max-width: calc(100vw - 10px);
      max-height: calc(100vh - 100px);
      overflow: auto;
      background: white;
      color: black
    }

    .history-entry {
      cursor: pointer;
      padding: 5px;
      display: flex
    }

    .history-entry-icon-area {
      width: 16px;
      height: 16px;
      margin-right: 6px
    }

    .history-entry.current {
      font-weight: bold
    }

    .history-entry:not(.current):not(.ancestor-of-current) {
      color: gray
    }

    .history-entry:hover:hover:hover {
      color: #0000ff;
      text-decoration: underline
    }

    ::before,
    ::after {
      pointer-events: none
    }

    .cursor-bully * {
      cursor: inherit !important
    }

    #about-paint-header {
      display: flex;
      flex-direction: row;
      margin: 0;
      margin-top: 30px;
      margin-bottom: 10px
    }

    #jspaint-project-name {
      margin-left: 10px;
      margin-right: 8px
    }

    #jspaint-version {
      font-size: 0.6em;
      color: #7b7b7b
    }

    #maybe-outdated-line {
      font-style: italic;
      height: 2em
    }

    #view-project-news {
      margin: auto;
      margin-right: 40px;
      width: 150px;
      height: 2.2em
    }

    #news {
      max-height: 500px;
      overflow: auto
    }

    @media (max-height:550px) {
      #news {
        max-height: calc(100vh - 50px)
      }
    }

    .news-indicator {
      font-family: sans-serif
    }

    .news-indicator>img {
      margin-right: 5px
    }

    @media (max-width:500px) {
      .news-indicator>img {
        position: absolute;
        right: 0;
        bottom: 0
      }

      .news-indicator .not-the-icon {
        display: none
      }
    }

    [touch-action="none"] {
      touch-action: none
    }
  </style>
  <style>
    @media print {

      html,
      body,
      .jspaint {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        border: 0;
        overflow: hidden
      }

      .canvas-area,
      .main-canvas {
        position: fixed;
        left: 0;
        top: 0;
        max-width: 100%;
        width: auto !important;
        height: auto !important
      }

      .window,
      .handle,
      .status-area,
      .menus,
      .component-area,
      .selection,
      .textbox,
      button,
      .hover-halo,
      .dwell-indicator {
        display: none !important
      }

      * {
        background: transparent !important
      }
    }
  </style>
  <style>
    .menus,
    .menu-popup,
    .os-window,
    .os-window .window-titlebar,
    .os-window .window-title {
      cursor: default;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none
    }

    .os-window .window-titlebar,
    body>.window-titlebar {
      display: flex;
      flex-direction: row;
      align-items: center
    }

    .os-window .window-title-area {
      position: relative;
      flex: 1
    }

    .os-window .window-titlebar .icon {
      vertical-align: bottom
    }

    .dragging iframe {
      pointer-events: none
    }

    .menus {
      display: flex;
      flex: 0 0 auto
    }

    .menu-container {
      position: relative
    }

    .menu-popup {
      position: absolute;
      top: 100%;
      left: 0;
      z-index: 400000;
      box-sizing: border-box
    }

    .menu-popup-table {
      border-collapse: collapse
    }

    .menu-item {
      white-space: nowrap
    }

    .menu-hr {
      display: block !important;
      height: 0;
      width: auto
    }

    .menu-hotkey {
      display: inline !important
    }

    .menu-item-checkbox-area,
    .menu-item-submenu-area {
      min-width: 16px
    }

    .menu-item-checkbox-area,
    .menu-item-submenu-area {
      text-align: center
    }

    ::before,
    ::after {
      pointer-events: none
    }
  </style>
  <style>
    body {
      font-family: Arial;
      font-size: 12px;
      color: #222222;
      background: #ece9d8
    }

    .xp-background {
      background: #ece9d8
    }

    h1 {
      font-size: 5rem
    }

    h2 {
      font-size: 2.5rem
    }

    h3 {
      font-size: 2rem
    }

    h4 {
      font-size: 1.5rem
    }

    u {
      text-decoration: none;
      border-bottom: 0.5px solid #222222
    }

    a {
      color: #0000ff
    }

    a:focus {
      outline: 1px dotted #0000ff
    }

    code {
      font-family: monospace
    }

    code * {
      font-family: monospace
    }

    pre {
      display: block;
      padding: 12px 8px;
      background-color: black;
      color: #c0c0c0;
      font-family: "Perfect DOS VGA 437 Win";
      font-size: 1rem;
      margin: 0
    }

    pre * {
      font-family: "Perfect DOS VGA 437 Win"
    }

    summary:focus {
      outline: 1px dotted #000000
    }

    ::-webkit-scrollbar {
      width: 16px
    }

    ::-webkit-scrollbar:horizontal {
      height: 17px
    }

    ::-webkit-scrollbar-corner {
      background: #dfdfdf
    }

    ::-webkit-scrollbar {
      width: 16px
    }

    ::-webkit-scrollbar:horizontal {
      height: 17px
    }

    ::-webkit-scrollbar-corner {
      background: #dfdfdf
    }

    ::-webkit-scrollbar-track {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAIAAAD91JpzAAAABmJLR0QA/wD/AP+gvaeTAAAAF0lEQVQImWM4cODA////Gf///3/w4EEASXEKf3vGbvcAAAAASUVORK5CYII=")
    }

    ::-webkit-scrollbar-thumb {
      background-color: #dfdfdf;
      box-shadow: inset -1px -1px #0a0a0a, inset 1px 1px #ffffff, inset -2px -2px #808080, inset 2px 2px #dfdfdf
    }

    ::-webkit-scrollbar-button:horizontal:start:decrement,
    ::-webkit-scrollbar-button:horizontal:end:increment,
    ::-webkit-scrollbar-button:vertical:start:decrement,
    ::-webkit-scrollbar-button:vertical:end:increment {
      display: block
    }

    ::-webkit-scrollbar-button:vertical:start {
      height: 17px;
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAARCAIAAABbzbuTAAAABmJLR0QA/wD/AP+gvaeTAAAAW0lEQVQokWO8f/8+A9FAUVGRhYGBQUFBgRjVjY2NDAwMLBDOwYMHibSEiXj3DKwGBwcHEjRAVOPSg64BWR1WPSgaMFVgirAgcw4cOIDVGficNBQ1sDDAkiGtAAAy/xBR890WEgAAAABJRU5ErkJggg==")
    }

    ::-webkit-scrollbar-button:vertical:end {
      height: 17px;
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAARCAIAAABbzbuTAAAABmJLR0QA/wD/AP+gvaeTAAAAYUlEQVQokWO8f/8+A9FAUVGRhYGBQUFBgRjVjY2NDAwMLBDOwYMHibSEiXj30EsDCzLHwcEBU8WBAwdw2oAmh1UE3UnIKjBVY9EAV4dVNXYNeFTj1IAHDEINLAywZEgrAABIJBuRRgGHhgAAAABJRU5ErkJggg==")
    }

    ::-webkit-scrollbar-button:horizontal:start {
      width: 16px;
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAARCAIAAABbzbuTAAAABmJLR0QA/wD/AP+gvaeTAAAAYElEQVQokWO8f/8+A9FAUVGRhYGBQUFBgRjVjY2NDAwMLBDOwYMHibSEiXj3ENDg4OBAggZcqrFrwKMaiwb8qrFoOHDgAGkaCOrB7mk8enAGKy491Is4qmlgYYAlQ1oBAPRrFM+iG2Z3AAAAAElFTkSuQmCC")
    }

    ::-webkit-scrollbar-button:horizontal:end {
      width: 16px;
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAARCAIAAABbzbuTAAAABmJLR0QA/wD/AP+gvaeTAAAAX0lEQVQokcXSwQnAMAgF0N/iILqJq7mZTuIqPZTeophDqLfAf/gDXpmJ8YgIAWDmSdrMAND7iIjhknvepwSqur2hMWWlynR/WJoOuPsGWKZLUKXXoEl3lf4DhO8MT80D0GsUzzkty1YAAAAASUVORK5CYII=")
    }

    ::-webkit-scrollbar {
      width: 17px
    }

    ::-webkit-scrollbar-corner {
      background: #dfdfdf
    }

    ::-webkit-scrollbar-track:vertical {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAABCAIAAAC32dI2AAAABmJLR0QA/wD/AP+gvaeTAAAALUlEQVQImUXJMRIAEQAEwZnlyv8fKVGFe4JAoNN2zf7VJpB4pUSxJMIbAPj3OJaoBcIEy2ZkAAAAAElFTkSuQmCC")
    }

    ::-webkit-scrollbar-track:horizontal {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAARCAIAAACToVFFAAAABmJLR0QA/wD/AP+gvaeTAAAAMklEQVQImSXJsQ2AMADAsCQF8f+RLEgtnMDQwZNZ8+48roSo1K1RGo7KwIBqPxDQ9z4/yQEF4ercSlsAAAAASUVORK5CYII=")
    }

    ::-webkit-scrollbar-thumb {
      background-position: center;
      background-repeat: no-repeat;
      background-color: #c8d6fb;
      background-size: 7px;
      border: 1px solid white;
      border-radius: 2px;
      box-shadow: inset -3px 0 #bad1fc, inset 1px 1px #b7caf5
    }

    ::-webkit-scrollbar-thumb:vertical {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAICAIAAAC6ZnJRAAAABmJLR0QA/wD/AP+gvaeTAAAAI0lEQVQImWN89+UfAyo4c/cfy61Hf4/c+osmwUhHtfdxqAUApPUrg5jjow0AAAAASUVORK5CYII=")
    }

    ::-webkit-scrollbar-thumb:horizontal {
      background-size: 8px;
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAHCAIAAAC6O5sJAAAABmJLR0QA/wD/AP+gvaeTAAAALklEQVQImWN89+XfrUd/1eSY0UgmBgaGI7f+YpJMDDgANSXO3P3HwMAAJe8jSABzOyOzHG4RfgAAAABJRU5ErkJggg==")
    }

    ::-webkit-scrollbar-button:vertical:start {
      height: 17px;
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAARCAIAAAC0D9CtAAAABmJLR0QA/wD/AP+gvaeTAAABxElEQVQokY2TsW4TYRCEZ3/bcREUCbrQIOSKgoJX4Cl4gVBGUZTY7iFSbKhIJN6CN6CCnoYSqsiKZMkHlgzJ3f0zQ3F3Fumy1erXfprZWf0oVguy8r2rWC36AFIaXP/ico2qZFUpCxRkUWFbSrKy/PzpYLS/s/6T+wAALNd4uJvKYapq0WFaityRJKpaP6/K0f7O7y1TlSyHSRQZJLLCdiagIJAJGNELAMWGHZPVKGQ6EwBMl3VQ0QxEINkANjd16pjIGSSosGz57P283ceyLbeTN2XXWaZg2nakOHs3B/Dh4tywEIYNN5OZHVPTmaAiEG9nM3R1eTl3WAgAcgDIRKfTmJDezM6bl5PjcdN8vJg7TGAr1TJU0K0lANOTSaQ4+h+DswDA6LzRoDA9nQCYnk4aM4w4OBwDODgcZ2EbQ5t1zmgiHh9PaaNdOgb9eH00ybQNQHeY9oJAL4k5ADiBgGULEGyDuMNIouhIUisiJcsZkCQhrCaDQLTMi9Hgx9WtFUR7eMN0L4AEh2z52ZM+gL3dHorV4sv363t+hE9fF8VqEcVq4f7e52/Fcn27+euadZUjrCa6iFZ20E+PHgxfvXyc6uIfE966i93X6PkAAAAASUVORK5CYII=")
    }

    ::-webkit-scrollbar-button:vertical:end {
      height: 17px;
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAARCAIAAAC0D9CtAAAABmJLR0QA/wD/AP+gvaeTAAABzElEQVQokY2Tv2pUURDGf3OymxSRgHaxEUllYeEr+BS+gIVFRDT/wEZQMFnExoBv4RtYaW9jqVVYAoG9uhjN7r1nvs/i7gbtcoo5M/D9+JgZhmYyzmx95ddMxgOglOHpjzyb0s6zbVVFClmpsC0VWVW+e3u4tbk6/V0HAHA25fp6ma+VtlM6nJaiLslM2k7fT+Zbm6s/L5l2nvO1olRmZFIVtmuCIqEmmFgJoDnPJVPVO9R0TQCn512kohdEUGzg/KK7ZKJWBKmwBBD0/RgHYUoB4GLuPsFyCqdfHh5GiSjxa1ZkGR8fj4yNe2XNJdOla/Li9RHw6uho1nl1qAyOj0ewiHIANVn62Jaf7+715Zu3I+D9u1FfPtreS7i0WjCpSEc6Dnb2/8V6ADCuok+WjElBQHCwu8CAh4/3alCDKrQUL75aqUkmykizu7MPbD/bHw4iSqRJI9SLB5f99GtZKcoawJOne62xbIGwTfIfIymVjiIZbCwVyxUkSYTVzyCIBXNva/jtZGZFsli8cXoloOCQLd+5NQA21ldoJuNPX0+veAgfPo+byTiaydiDjY9fmrPp7PyPu+zaGmGJACIWtsNBuXFt7cH9m6Vr/gLUAa+Mz676nAAAAABJRU5ErkJggg==")
    }

    ::-webkit-scrollbar-button:horizontal:start {
      width: 17px;
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAARCAIAAAC0D9CtAAAABmJLR0QA/wD/AP+gvaeTAAAB0klEQVQokZWRu2qVQRSFvz35T1IognbaiKSysPAVfAqfwRsScpKAjYVKTowi+B6+gZX2NpZaSQwEcuLB3M4/s9ey+OOljItdzLBn8e01O6b7O/ynIrMvZXR+w8H0e1fKaPcg92b08+x7NZFCFpAK21KR1eRbN0bLVxdnR60D9mZcvlDmS6WvSofTUhinQlYqMumrvn6bL19d/HHUCtDPc95QKjOy0reo6acvJrU5a2TSEkwsBDA9zAL0TX3VPKOla9r2s8kE2NyeHNeY10gFQcHA4UntgL5Fa2gIID1/uTXEffRww7ZxEKYUAE7m7gDLKbBt/hgePFgbfkLEQBjU0h1Q0y0J4tlkc2isrqwBR3W4WY6C5QBaUhgAsqQn47Xh1fbrrfbPThxO8G9aAfqMPiOJJDbG60PjzeutbjFaMFSV+yyAcQFaoyWZKCPNePXM9vbVZNRFlEiTRugvx3ZLWiKrNVrj8coacG9l3bJlhG3ybNQOkJRKR5EMNpbK/Udj9W4gSSKsIU8QHXB7efTl26kVSZyFxkB6IaDgkC3fvN4Bly4s8OHzrs+tdx93pvs7sT/7+f7TdG92enjsmrVvEZZ+AyPODqOuXLm4dPfOtVKnvwC4Q4tqRxqhHwAAAABJRU5ErkJggg==")
    }

    ::-webkit-scrollbar-button:horizontal:end {
      width: 17px;
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAARCAIAAAC0D9CtAAAABmJLR0QA/wD/AP+gvaeTAAAB1ElEQVQokZWRv2pWQRDFf7Pf/WKhCNrFRiSVhYWv4FP4AhaCCf5NBAsLURITEDH4GL6BlfY2llpJFAL59MOY5N7dOcfiJtrqNDtzds45Ozsx29vhPyMyh1Km/074PvvalTL99j135wx9DoOaSCELSIVtqchq8pVL06XFhfmv1gG7c86dLv2pMlSlw2kpjFMhKxWZDFWfv/RLiws/frUCDH32DaUyIytDi8fP1mt1bc4ambQEE5MAZvtZgKFpqOozWrqmn6yvA083n/eVgxp9jVQQFAzsH9aRE62RSSosP3qwOo774uWGbVm25TKCh70LYDmF07ajRJRYWX44drza3hBhbDwiLV2Amm5JKoII4qh6Yar7d4/dXm9viADkAFrSjUdLOFHqSiRsbm2M5c3lVeNmIwPGHZAmxWRyvDU5NrfWx/zGymoDwEk5GakDWht9CMLFfwjL99bSNNHSNqARL4Dt8XmyWuPO7TVg5e7DNJYtI2yT/PWRlEpHkQw2vrWymi2taCBJIqzx64LogKtL009fjqxIYlQar9OTgIJDtnz5YgecPT3h3cdv/ud4835ntrcTe/Ofbz/MdudH+weuWYcWYenEMOI4mXbl/JlT169dKHX2GxUzjXaq5NCYAAAAAElFTkSuQmCC")
    }

    button.xp-button {
      font-family: "Pixelated MS Sans Serif", Arial;
      font-size: 11px;
      box-sizing: border-box;
      border: none;
      background: #ece9d8;
      box-shadow: inset -1px -1px #0a0a0a, inset 1px 1px #ffffff, inset -2px -2px #808080, inset 2px 2px #dfdfdf;
      border-radius: 0;
      min-width: 75px;
      min-height: 23px;
      padding: 0 12px
    }

    button.xp-button:not(:disabled):active {
      box-shadow: inset -1px -1px #ffffff, inset 1px 1px #0a0a0a, inset -2px -2px #dfdfdf, inset 2px 2px #808080
    }

    button.xp-button:not(:disabled).active {
      box-shadow: inset -1px -1px #ffffff, inset 1px 1px #0a0a0a, inset -2px -2px #dfdfdf, inset 2px 2px #808080
    }

    button.xp-button:focus,
    button.xp-button.focused {
      outline: 1px dotted #000000;
      outline-offset: -4px
    }

    button.xp-button::-moz-focus-inner {
      border: 0
    }

    button.xp-button {
      font-family: "Pixelated MS Sans Serif", Arial;
      -webkit-font-smoothing: antialiased;
      font-size: 11px;
      box-sizing: border-box;
      border: 1px solid #003c74;
      background: linear-gradient(180deg, rgba(255, 255, 255, 1) 0%, rgba(236, 235, 229, 1) 86%, rgba(216, 208, 196, 1) 100%);
      box-shadow: none;
      border-radius: 3px
    }

    button.xp-button:not(:disabled):active,
    button.xp-button:not(:disabled).active {
      box-shadow: none;
      background: linear-gradient(180deg, rgba(205, 202, 195, 1) 0%, rgba(227, 227, 219, 1) 8%, rgba(229, 229, 222, 1) 94%, rgba(242, 242, 241, 1) 100%)
    }

    button.xp-button:not(:disabled):hover {
      box-shadow: inset -1px 1px #fff0cf, inset 1px 2px #fdd889, inset -2px 2px #fbc761, inset 2px -2px #e5a01a
    }

    button.xp-button:focus,
    button.xp-button.focused {
      box-shadow: inset -1px 1px #cee7ff, inset 1px 2px #98b8ea, inset -2px 2px #bcd4f6, inset 1px -1px #89ade4, inset 2px -2px #89ade4
    }

    button.xp-button::-moz-focus-inner {
      border: 0
    }

    input.xp-checkbox[type="checkbox"] {
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      margin: 0;
      background: 0;
      position: fixed;
      opacity: 0;
      border: none
    }

    input.xp-checkbox[type="checkbox"]+label {
      line-height: 13px;
      position: relative;
      margin-left: 19px
    }

    input.xp-checkbox[type="checkbox"]+label::before {
      content: "";
      position: absolute;
      left: -19px;
      display: inline-block;
      width: 13px;
      height: 13px;
      background: #ffffff;
      box-shadow: inset -1px -1px #ffffff, inset 1px 1px #808080, inset -2px -2px #dfdfdf, inset 2px 2px #0a0a0a;
      margin-right: 6px
    }

    input.xp-checkbox[type="checkbox"]:focus+label {
      outline: 1px dotted #000000
    }

    input.xp-checkbox[type="checkbox"]:active+label::before {
      background: #ece9d8
    }

    input.xp-checkbox[type="checkbox"]:checked+label::after {
      content: "";
      display: block;
      width: 11px;
      height: 11px;
      position: absolute;
      background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAYAAADEUlfTAAAABmJLR0QA/wD/AP+gvaeTAAAAMElEQVQImWNgwA3+M+KSYGBgYGCCMdAlYJLIAsgKGRmx6GRgYGBghBPoOnA6AhkAALZJCQLUta0kAAAAAElFTkSuQmCC");
      top: 1px
    }

    input.xp-checkbox[type="checkbox"][disabled]+label::before {
      background: #ece9d8
    }

    input.xp-checkbox[type="checkbox"][disabled]:checked+label::after {
      background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAYAAADEUlfTAAAABmJLR0QA/wD/AP+gvaeTAAAAMklEQVQImXWOQQoAMAzCYl/uz7dTQUrrSQwB4YjtpwsAVJcJACqHBLalaTYA0GacJzIfhbIbAqvL5V4AAAAASUVORK5CYII=")
    }

    input.xp-checkbox[type="checkbox"]+label:before {
      box-shadow: none;
      border: 1px solid #1d5281;
      background: linear-gradient(135deg, rgba(220, 220, 215, 1) 0%, rgba(255, 255, 255, 1) 100%)
    }

    input.xp-checkbox[type="checkbox"]:checked+label:after {
      background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAALCAYAAACprHcmAAAABmJLR0QA/wD/AP+gvaeTAAAAOUlEQVQYlWNgGDCgtFDpP4zNRKxCFMXoEuh8DJNhCpAV3ou/xwhjM6IrRAbIClEU4zMRJ8BmA+0BAMLtF2F7127ZAAAAAElFTkSuQmCC");
      left: -17px
    }

    input.xp-checkbox[type="checkbox"]:not([disabled]):not(:active)+label:hover:before {
      box-shadow: inset -2px -2px #f8b636, inset 2px 2px #fedf9c
    }

    input.xp-checkbox[type="checkbox"]:active+label::before {
      background: linear-gradient(135deg, rgba(176, 176, 167, 1) 0%, rgba(227, 225, 210, 1) 100%)
    }

    input.xp-checkbox[type="checkbox"][disabled]+label::before {
      background: white;
      border: 1px solid #cac8bb
    }

    input.xp-checkbox[type="checkbox"][disabled]:checked+label::after {
      background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAALCAYAAACprHcmAAAABmJLR0QA/wD/AP+gvaeTAAAAOUlEQVQYlWNgGDBw6sTu/zA2E7EKURSjS6DzMUyGKUBWaGbhyghjM6IrRAbIClEU4zMRJ8BmA+0BACtdH9GUsUy1AAAAAElFTkSuQmCC")
    }

    select.xp-dropdown {
      height: 23px
    }

    select.xp-dropdown {
      font-family: "Pixelated MS Sans Serif", Arial;
      font-size: 11px;
      padding: 3px 4px;
      border: none;
      background-color: #ffffff;
      box-sizing: border-box;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      border-radius: 0;
      height: 21px;
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      position: relative;
      padding-right: 32px;
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAARCAIAAABbzbuTAAAABmJLR0QA/wD/AP+gvaeTAAAAYUlEQVQokWO8f/8+A9FAUVGRhYGBQUFBgRjVjY2NDAwMLBDOwYMHibSEiXj30EsDCzLHwcEBU8WBAwdw2oAmh1UE3UnIKjBVY9EAV4dVNXYNeFTj1IAHDEINLAywZEgrAABIJBuRRgGHhgAAAABJRU5ErkJggg==");
      background-position: top 2px right 2px;
      background-repeat: no-repeat;
      border-radius: 0
    }

    select.xp-dropdown:focus {
      outline: none;
      color: #ffffff;
      background-color: #2267cb
    }

    select.xp-dropdown:focus>option {
      color: #000;
      background-color: #fff
    }

    select.xp-dropdown:active {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAARCAIAAABbzbuTAAAABmJLR0QA/wD/AP+gvaeTAAAAU0lEQVQokWNsaGhgIAWwMDAwODg4EKn6wIEDTCQZz8DAMBw0sKDxsYbYgQMHcNqALIdVBIuTkFVg6sfuB4g6TNU4NeBSjU8DLjAINbAw4PYfVgAATw8ZqGxJPfgAAAAASUVORK5CYII=")
    }

    select.xp-dropdown,
    select.xp-dropdown>option {
      -webkit-font-smoothing: antialiased
    }

    select.xp-dropdown {
      border: 1px solid #7f9db9;
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAARCAIAAACNaGH2AAAABmJLR0QA/wD/AP+gvaeTAAABf0lEQVQokZWSMYtTURCFv7nvJYIouH9AsLTwh1ksiC5JGru1SBSbDforrP0BdnbWWggLNoKFEnkv9845Fi+b2O5hipnhzOHOPRM/frWfv2Mc2r6qZgCSUykX24BUZDX5yaNZfPmeD+7G2NhXpQNwWoomZAGpyGRflXXsx6GN85lSmZEJ0BS2W4ICSGgJEF30+6pJtaWn7iQ/1kgFNwgouHAb9DWjNQSpsHSUSsW0pXEQphQoklNYtv3q9SZKRIk/Q5FlfLVdizA2BkpNtyQzLtdr4HK9HqrnM2Ww3W6Ad9u1CEDE6d0vl6spefN2A7y/2kzl0/PFadePn3dn9+ZTMeaBesSJajoNJRXpQ/QlVhfLI/XZ88Wd2ZHsJkqaFMQpFhcr4PzFctfYNVrQgibkEh8+/T27P+87AP77/cGkAZpozchd7m/pDjdn0BVnPVjtzklYBiwAyUXuJaXSUSSDJ3Y6LLdpUpYclu34ej18ux6ji+B0Q8bV3TGfnH78sP8HtMEnEZnQc2MAAAAASUVORK5CYII=");
      background-size: 15px
    }

    select.xp-dropdown:focus {
      box-shadow: inset 2px 2px white, inset -2px -2px white
    }

    select.xp-dropdown:hover {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAARCAIAAACNaGH2AAAABmJLR0QA/wD/AP+gvaeTAAABhklEQVQokZWSvW5UUQyEP5/dJNDzCDS0VLwCb5NISElASvhRtJsECYlXoouEoIaWiCZVJNi999gzFHfZpI3lwpbsGdvj+Pbz5vrGq5XGrt4FpEjbJXkGWE4zpl8825tf3/jliycDrIsugEwkUk4HUFmZDANXV7/mq5UGSNPFOAKkLNG7MECaTIBoMR+7JtRhUK8AAKfXI2Xu2yzceIjN16NXI0A5vEULypQCkNViA9psVynTEgevljGLmMXfil6W9eF0qWiyZAGtZ/UKSfsHC2D/YPFnompx9vYCWJwuFW0iv5v786fDKXhzuACWJ+dTevT+cFvT5JnLVVEVZ+fH9xu2pQ5XC6D1cmrju6HLizukd+dHj/c2Ny0zOlqZFLQ7X14cAScfX9+Ovh3dgx6ksDyv8kaqCMd0QZ9dHg+wuzdjknlQllI8UB0VYwW4zUPaqKPmHqEyoNT0A02au3rvlr1T2ixEKGQ89ZacBUXh+PL19/cf69kOQWwZjfv/FzIuhVXPnz76B1zVOLYX0E32AAAAAElFTkSuQmCC")
    }

    select.xp-dropdown:active {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAARCAIAAACNaGH2AAAABmJLR0QA/wD/AP+gvaeTAAABq0lEQVQokZWRvWpVURSEv/Vz9r7ekCCIrb2dpViFFCminSi+gmL0WUIgryEmKGLAwsJCfANTmSIQtFDQeO85Z4/FCYltppoFs9YMa+zw49HJKX9+22I59oMD/aCm1kZTEzCONjSGprt3PE9O+fLtJoWazApAFCJUpBQTFrLlwuY3PP/8Ngp1Rp0p3IAwzUMxnkvTiEHhsohcLMfODdekA1bnHo3shkkdPVEBc+RcBdkPXkxRBKAEoFWUnqNGgEICCPB+UBaytxXl58Od66VFz2I0RqLF/us9GjQyDPBhUEDN+PRhB3j/ZncyPRv91cEusH+wV1M11bDL3Pc2Xk5kWnj3dmcaHz98caFxNa0Wd+Ro8/72/wvA1oPtcGWmd5Lky8GBhITlma1vXF568uj52jW5y12l86HhowjT9OmJrK8/mwIselv01ppZWhetyXPoGZcjATDVF8HW5lOLZQmA7Hy+onDrddV2WmvTvVqVMoCkJl1YugG1aD5T6fTj13l51KrsrBYBNTG3Llo3AwindFqb6/tP2dfjv0fHCwsz7MJRqFdccDVJun0r/wG/iMl5c/+qnQAAAABJRU5ErkJggg==")
    }

    select.xp-dropdown {
      height: 23px
    }

    .xp-field-row {
      display: flex;
      align-items: center
    }

    .xp-field-row>*+* {
      margin-left: 6px
    }

    [class^="xp-field-row"]+[class^="xp-field-row"] {
      margin-top: 6px
    }

    .xp-field-row-stacked {
      display: flex;
      flex-direction: column
    }

    .xp-field-row-stacked *+* {
      margin-top: 6px
    }

    .xp-field-row {
      display: flex;
      align-items: center
    }

    .xp-field-row>*+* {
      margin-left: 6px
    }

    [class^="xp-field-row"]+[class^="xp-field-row"] {
      margin-top: 6px
    }

    .xp-field-row-stacked {
      display: flex;
      flex-direction: column
    }

    .xp-field-row-stacked *+* {
      margin-top: 6px
    }

    @font-face {
      font-family: "Pixelated MS Sans Serif";
      src: url("") format("woff");
      src: url("") format("woff2");
      font-weight: normal;
      font-style: normal
    }

    @font-face {
      font-family: "Pixelated MS Sans Serif";
      src: url("") format("woff");
      src: url("") format("woff2");
      font-weight: bold;
      font-style: normal
    }

    @font-face {
      font-family: "Perfect DOS VGA 437 Win";
      src: url("") format("woff2"), url("") format("woff");
      font-weight: normal;
      font-style: normal
    }

    fieldset.xp-groupbox {
      border: none;
      box-shadow: inset -1px -1px #ffffff, inset 1px 1px #0a0a0a, inset -2px -2px #808080, inset 2px 2px #dfdfdf;
      padding: 10px;
      padding-block-start: 8px;
      margin: 0
    }

    legend.xp {
      background: #ece9d8
    }

    .xp-field-row {
      display: flex;
      align-items: center
    }

    .xp-field-row>*+* {
      margin-left: 6px
    }

    .xp-field-row-stacked {
      display: flex;
      flex-direction: column
    }

    .xp-field-row-stacked *+* {
      margin-top: 6px
    }

    fieldset.xp-groupbox {
      border: none;
      box-shadow: none;
      background: white;
      border: 1px solid #d0d0bf;
      border-radius: 4px;
      padding-top: 10px
    }

    fieldset.xp-groupbox>legend {
      background: transparent;
      color: #0046d5
    }

    .xp-field-row {
      display: flex;
      align-items: center
    }

    .xp-field-row>*+* {
      margin-left: 6px
    }

    .xp-field-row-stacked {
      display: flex;
      flex-direction: column
    }

    .xp-field-row-stacked *+* {
      margin-top: 6px
    }

    hr.xp-hr {
      border-top: 1px solid #aca899;
      border-bottom: 1px solid #ffffff;
      border-left: none;
      border-right: none
    }

    :root {
      --xp-progress-bar-width: 100%;
      --xp-progress-bar-height: 8px;
      --xp-progress-bar-border-radius: 2px;
      --xp-progress-bar-background-color: #ffffff;
      --xp-progress-bar-border: 1px solid #686768;
      --xp-progress-bar-padding: 2px;
      --xp-progress-bar-box-shadow: inset 0px 0px 1px grey;
      --xp-progress-bar-background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAYAAADEUlfTAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAB3RJTUUH5AcHABc2pM8GkgAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAA+SURBVAjXY1z9du1/BjQQIhTEwMDAwMBy+ftlBgxJBqjk+W8XGHABlgc/H+KWFGYRxC1pymWGW1KKTRynJAAU3A18Y6k7aQAAAABJRU5ErkJggg==");
      --xp-progress-bar-background-size: contain;
      --xp-progress-bar-background-repeat: repeat-x;
      --xp-progress-bar-border-radius: 2px
    }

    progress {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      border: none
    }

    progress {
      width: var(--xp-progress-bar-width);
      height: var(--xp-progress-bar-height);
      border-radius: var(--xp-progress-bar-border-radius);
      background-color: var(--xp-progress-bar-background-color);
      border: var(--xp-progress-bar-border);
      padding: var(--xp-progress-bar-padding);
      box-shadow: var(--xp-progress-bar-box-shadow)
    }

    progress::-webkit-progress-bar {
      background-color: var(--xp-progress-bar-background-color);
      border-radius: var(--xp-progress-bar-border-radius)
    }

    progress::-webkit-progress-value {
      background-image: var(--xp-progress-bar-background-image);
      background-size: var(--xp-progress-bar-background-size);
      background-repeat: var(--xp-progress-bar-background-repeat)
    }

    progress::-moz-progress-bar {
      background-image: var(--xp-progress-bar-background-image);
      background-size: var(--xp-progress-bar-background-size);
      background-repeat: var(--xp-progress-bar-background-repeat)
    }

    input.xp-radio-button[type="radio"] {
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      margin: 0;
      background: 0;
      position: fixed;
      opacity: 0;
      border: none
    }

    input.xp-radio-button[type="radio"]+label {
      line-height: 13px;
      position: relative;
      margin-left: 19px
    }

    input.xp-radio-button[type="radio"]+label::before {
      content: "";
      position: absolute;
      top: 0;
      left: -19px;
      display: inline-block;
      width: 13px;
      height: 13px;
      margin-right: 6px;
      background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAABmJLR0QA/wD/AP+gvaeTAAAAaklEQVQokbWRsRHAIAwD5RyDMKo3NZsoRQwHckGV76yThAGD4O6U2fbZ1OjuWlCDaSYAKrsOAG1vSw2qjTHKzqVZiQiS5FMqL/wfAHC/x9z/OCEiztdIVFufMRvU0Hv/jGZ2BDS4GtM4eQH4eI7jn/i0fgAAAABJRU5ErkJggg==")
    }

    input.xp-radio-button[type="radio"]:active+label::before {
      background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAABmJLR0QA/wD/AP+gvaeTAAAAf0lEQVQokbWQwRUEIQhDk33TB5RiaZRmJ2ol7mEWn7DjcXJDfpInRJKZzTRzn5lBM8sBwUiHfVFrDYZSCgBgzgmSvPZlhv1NRNZ8efoT7BpjeMv8HKmD3jeEK53+ISJQVZDkamithWvs8F8DcF8AAHrvAVDVGyQZDNm4En+g6wsf5zwps04niAAAAABJRU5ErkJggg==")
    }

    input.xp-radio-button[type="radio"]:checked+label::after {
      content: "";
      display: block;
      width: 5px;
      height: 5px;
      top: 5px;
      left: -14px;
      position: absolute;
      background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAABmJLR0QA/wD/AP+gvaeTAAAAGUlEQVQImWNggID/UMzACGPAABMDDgDXAgCxCgT/tZpalAAAAABJRU5ErkJggg==")
    }

    input.xp-radio-button[type="radio"]:focus+label {
      outline: 1px dotted #000000
    }

    input.xp-radio-button[type="radio"][disabled]+label::before {
      background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAABmJLR0QA/wD/AP+gvaeTAAAAf0lEQVQokbWQwRUEIQhDk33TB5RiaZRmJ2ol7mEWn7DjcXJDfpInRJKZzTRzn5lBM8sBwUiHfVFrDYZSCgBgzgmSvPZlhv1NRNZ8efoT7BpjeMv8HKmD3jeEK53+ISJQVZDkamithWvs8F8DcF8AAHrvAVDVGyQZDNm4En+g6wsf5zwps04niAAAAABJRU5ErkJggg==")
    }

    input.xp-radio-button[type="radio"][disabled]:checked+label::after {
      background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAABmJLR0QA/wD/AP+gvaeTAAAAI0lEQVQImWNgYGBgaGho+N/Q0PCfgYGBgRHGgAEmBmwAWQsAyZkMfy66HJUAAAAASUVORK5CYII=")
    }

    input.xp-radio-button[type="radio"] {
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      margin: 0;
      background: 0;
      position: fixed;
      opacity: 0;
      border: none
    }

    input.xp-radio-button[type="radio"]+label {
      line-height: 16px
    }

    input.xp-radio-button[type="radio"]+label::before {
      background: linear-gradient(135deg, rgba(220, 220, 215, 1) 0%, rgba(255, 255, 255, 1) 100%);
      border-radius: 50%;
      border: 1px solid #1d5281
    }

    input.xp-radio-button[type="radio"]:not([disabled]):not(:active)+label:hover:before {
      box-shadow: inset -2px -2px #f8b636, inset 2px 2px #fedf9c
    }

    input.xp-radio-button[type="radio"]:active+label::before {
      background: linear-gradient(135deg, rgba(176, 176, 167, 1) 0%, rgba(227, 225, 210, 1) 100%)
    }

    input.xp-radio-button[type="radio"]:checked+label::after {
      background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAABmJLR0QA/wD/AP+gvaeTAAAAcklEQVQImQXBQQqCQBiA0U/JE3iFOUHHEFzZRRLPUtIiWgmD3cF14Mq129GxYsRgBlr9vgeAHhvJu0wew10AIj028vy3OOeYzMxZlUR5l4k/eEIILPZL4mPiIj1hjeW9fPhtK+WxAoBbX4u6KKlfVwHYAYLmMVZ5WBWJAAAAAElFTkSuQmCC")
    }

    input.xp-radio-button[type="radio"]:focus+label {
      outline: 1px dotted #000000
    }

    input.xp-radio-button[type="radio"][disabled]+label::before {
      border: 1px solid #cac8bb;
      background: white
    }

    input.xp-radio-button[type="radio"][disabled]:checked+label::after {
      background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAABmJLR0QA/wD/AP+gvaeTAAAAa0lEQVQImQXBMQqDMBiA0S/FG4iTSMC5dPG8XqVTR6HOCpVakCCIQjGpweTvewrATJ3MpifNNHlxVcpMnazLh+PYcXYjL24ks+mJMRBOTwyB96vhkmYaZzd+7ov3Fl1WADAOrTzutYzDUwD+4Ho1Vm2xAP4AAAAASUVORK5CYII=")
    }

    input.xp-slider[type="range"] {
      -webkit-appearance: none;
      width: 100%;
      background: transparent
    }

    input.xp-slider[type="range"]:focus {
      outline: none
    }

    input.xp-slider[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      height: 21px;
      width: 11px;
      background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAVCAYAAACQcBTNAAAABmJLR0QA/wD/AP+gvaeTAAAAXklEQVQoke3TsQ2AMAxE0X+IhelgAuiYKZVhqqMKQihBKShzhQvr2ZUt26YhkhgB0nF+wkgBwNCyNafjjn/BArDt2plGCpZ5ApByszTwhHcpDbxhMba9bruBpnejBi/pPy9cjLNfpQAAAABJRU5ErkJggg==");
      transform: translateY(-8px)
    }

    input.xp-slider[type="range"]::-moz-range-thumb {
      height: 21px;
      width: 11px;
      border: 0;
      border-radius: 0;
      background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAVCAYAAACQcBTNAAAABmJLR0QA/wD/AP+gvaeTAAAAXklEQVQoke3TsQ2AMAxE0X+IhelgAuiYKZVhqqMKQihBKShzhQvr2ZUt26YhkhgB0nF+wkgBwNCyNafjjn/BArDt2plGCpZ5ApByszTwhHcpDbxhMba9bruBpnejBi/pPy9cjLNfpQAAAABJRU5ErkJggg==");
      transform: translateY(2px)
    }

    input.xp-slider[type="range"]::-webkit-slider-runnable-track {
      width: 100%;
      height: 2px;
      box-sizing: border-box;
      background: black;
      border-right: 1px solid grey;
      border-bottom: 1px solid grey;
      box-shadow: 1px 0 0 white, 1px 1px 0 white, 0 1px 0 white, -1px 0 0 darkgrey, -1px -1px 0 darkgrey, 0 -1px 0 darkgrey, -1px 1px 0 white, 1px -1px darkgrey
    }

    input.xp-slider[type="range"]::-moz-range-track {
      width: 100%;
      height: 2px;
      box-sizing: border-box;
      background: black;
      border-right: 1px solid grey;
      border-bottom: 1px solid grey;
      box-shadow: 1px 0 0 white, 1px 1px 0 white, 0 1px 0 white, -1px 0 0 darkgrey, -1px -1px 0 darkgrey, 0 -1px 0 darkgrey, -1px 1px 0 white, 1px -1px darkgrey
    }

    input.xp-slider[type="range"][box]::-webkit-slider-thumb {
      background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAVCAIAAAAfEoOaAAAABmJLR0QA/wD/AP+gvaeTAAAAM0lEQVQokWP8//8/A27AyMjIwsDAcPDESazSxw8eZ2BgYMJjAASMqhhVgQ+wMMDSEvkAACpVChw8ipDsAAAAAElFTkSuQmCC");
      transform: translateY(-10px)
    }

    input.xp-slider[type="range"][box]::-moz-range-thumb {
      background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAVCAIAAAAfEoOaAAAABmJLR0QA/wD/AP+gvaeTAAAAM0lEQVQokWP8//8/A27AyMjIwsDAcPDESazSxw8eZ2BgYMJjAASMqhhVgQ+wMMDSEvkAACpVChw8ipDsAAAAAElFTkSuQmCC");
      transform: translateY(0px)
    }

    .xp-is-vertical {
      display: inline-block;
      width: 4px;
      height: 150px;
      transform: translateY(50%)
    }

    .xp-is-vertical>input.xp-slider[type="range"] {
      width: 150px;
      height: 4px;
      margin: 0 16px 0 10px;
      transform-origin: left;
      transform: rotate(270deg) translateX(calc(-50% + 8px))
    }

    .xp-is-vertical>input.xp-slider[type="range"]::-webkit-slider-runnable-track {
      border-left: 1px solid grey;
      border-right: 0;
      border-bottom: 1px solid grey;
      box-shadow: -1px 0 0 white, -1px 1px 0 white, 0 1px 0 white, 1px 0 0 darkgrey, 1px -1px 0 darkgrey, 0 -1px 0 darkgrey, 1px 1px 0 white, -1px -1px darkgrey
    }

    .xp-is-vertical>input.xp-slider[type="range"]::-moz-range-track {
      border-left: 1px solid grey;
      border-right: 0;
      border-bottom: 1px solid grey;
      box-shadow: -1px 0 0 white, -1px 1px 0 white, 0 1px 0 white, 1px 0 0 darkgrey, 1px -1px 0 darkgrey, 0 -1px 0 darkgrey, 1px 1px 0 white, -1px -1px darkgrey
    }

    .xp-is-vertical>input.xp-slider[type="range"]::-webkit-slider-thumb {
      transform: translateY(-8px) scaleX(-1)
    }

    .xp-is-vertical>input.xp-slider[type="range"]::-moz-range-thumb {
      transform: translateY(2px) scaleX(-1)
    }

    .xp-is-vertical>input.xp-slider[type="range"][box]::-webkit-slider-thumb {
      transform: translateY(-10px) scaleX(-1)
    }

    .xp-is-vertical>input.xp-slider[type="range"][box]::-moz-range-thumb {
      transform: translateY(0px) scaleX(-1)
    }

    input.xp-slider[type="range"]::-webkit-slider-thumb {
      height: 21px;
      width: 11px;
      background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAVCAYAAACQcBTNAAAABmJLR0QA/wD/AP+gvaeTAAABYUlEQVQoke2TPS9DYRiGr7dpOvgBBoP4GhiUMtgkLZNIJ1+r32CxSMQP8PUDbCRWwSDRRFSkkZCwkDQiRKsnIv04PY6357yPgaLKaHPP1/XkfpLnUQCJkwtxtUaEuuhKhXzJYToeUypxciEPoWtS7OP6zwifhic+d84tzbl+Op56CbpakwrtY3s2Gfce82W8EZ+0nebSvaLJbicoAq7/TMa9J22n8cSrqeHnfUzRR+sXggDLXUsYYzDGr+ucy1lks1m2j84J1K/0e/7hv4GNMYgISqk3WFcqjJ2OI99OzhhDuVymVCoycTaFUopAvuTQ/NhHdzL8IVRBy7IYPYzTV4iitSYwHY+pzvIAMXuSnmQEEcFxHCzLYuRglEghSpsOszg3814GWNnYkvNQkkTDJrutOwztDRMpRGn3elhdmFUA6mvPqrDnrBO+GawB6+CqcFzcpTHTUgP+mvnVtR++EV4BVMzCYg/h2WQAAAAASUVORK5CYII=");
      transform: translateY(-8px)
    }

    input.xp-slider[type="range"]::-moz-range-thumb {
      height: 21px;
      width: 11px;
      border: 0;
      border-radius: 0;
      background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAVCAYAAACQcBTNAAAABmJLR0QA/wD/AP+gvaeTAAABYUlEQVQoke2TPS9DYRiGr7dpOvgBBoP4GhiUMtgkLZNIJ1+r32CxSMQP8PUDbCRWwSDRRFSkkZCwkDQiRKsnIv04PY6357yPgaLKaHPP1/XkfpLnUQCJkwtxtUaEuuhKhXzJYToeUypxciEPoWtS7OP6zwifhic+d84tzbl+Op56CbpakwrtY3s2Gfce82W8EZ+0nebSvaLJbicoAq7/TMa9J22n8cSrqeHnfUzRR+sXggDLXUsYYzDGr+ucy1lks1m2j84J1K/0e/7hv4GNMYgISqk3WFcqjJ2OI99OzhhDuVymVCoycTaFUopAvuTQ/NhHdzL8IVRBy7IYPYzTV4iitSYwHY+pzvIAMXuSnmQEEcFxHCzLYuRglEghSpsOszg3814GWNnYkvNQkkTDJrutOwztDRMpRGn3elhdmFUA6mvPqrDnrBO+GawB6+CqcFzcpTHTUgP+mvnVtR++EV4BVMzCYg/h2WQAAAAASUVORK5CYII=");
      transform: translateY(2px)
    }

    input.xp-slider[type="range"]::-webkit-slider-runnable-track {
      width: 100%;
      height: 2px;
      box-sizing: border-box;
      background: #ecebe4;
      border-right: 1px solid #f3f2ea;
      border-bottom: 1px solid #f3f2ea;
      border-radius: 2px;
      box-shadow: 1px 0 0 white, 1px 1px 0 white, 0 1px 0 white, -1px 0 0 #9d9c99, -1px -1px 0 #9d9c99, 0 -1px 0 #9d9c99, -1px 1px 0 white, 1px -1px #9d9c99
    }

    input.xp-slider[type="range"]::-moz-range-track {
      width: 100%;
      height: 2px;
      box-sizing: border-box;
      background: #ecebe4;
      border-right: 1px solid #f3f2ea;
      border-bottom: 1px solid #f3f2ea;
      border-radius: 2px;
      box-shadow: 1px 0 0 white, 1px 1px 0 white, 0 1px 0 white, -1px 0 0 #9d9c99, -1px -1px 0 #9d9c99, 0 -1px 0 #9d9c99, -1px 1px 0 white, 1px -1px #9d9c99
    }

    input.xp-slider[type="range"][box]::-webkit-slider-thumb {
      background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAWCAIAAACZhvE0AAAABmJLR0QA/wD/AP+gvaeTAAAA+ElEQVQoke3SvUoDURAF4DN3bxaNBgTr2FmI2GwhdqKvYGfjG9iLCL6EtZ1g508jCEmTSiRgKwELIWGjIe7uJcSbOzMWkqgQrC087fk40wzlWefkvD5whffv+BYi8t4f7+/S6VWtwTe34UxyUZ70gCLpbS2HxC5Uys9zTessW4aOhUKcNBfrq/0NG5dKl2sXIiIyWYCIdLsvaZpeNx4MpsUYYwwZYwBMFwBUwcy/ia+9f/GXBBGiKAJgiXDwdOi4aA/bAvmsRaXlWqEX9uIjOxPH62H7ztaqs0s6fjJWBlDNkvJ8hfKsc//4OvRe9ccVPxq9FYOdzZUPLQNv/CfDFX4AAAAASUVORK5CYII=");
      transform: translateY(-10px)
    }

    input.xp-slider[type="range"][box]::-moz-range-thumb {
      background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAWCAIAAACZhvE0AAAABmJLR0QA/wD/AP+gvaeTAAAA+ElEQVQoke3SvUoDURAF4DN3bxaNBgTr2FmI2GwhdqKvYGfjG9iLCL6EtZ1g508jCEmTSiRgKwELIWGjIe7uJcSbOzMWkqgQrC087fk40wzlWefkvD5whffv+BYi8t4f7+/S6VWtwTe34UxyUZ70gCLpbS2HxC5Uys9zTessW4aOhUKcNBfrq/0NG5dKl2sXIiIyWYCIdLsvaZpeNx4MpsUYYwwZYwBMFwBUwcy/ia+9f/GXBBGiKAJgiXDwdOi4aA/bAvmsRaXlWqEX9uIjOxPH62H7ztaqs0s6fjJWBlDNkvJ8hfKsc//4OvRe9ccVPxq9FYOdzZUPLQNv/CfDFX4AAAAASUVORK5CYII=");
      transform: translateY(0px)
    }

    .xp-is-vertical>input.xp-slider[type="range"]::-webkit-slider-runnable-track {
      border-left: 1px solid #f3f2ea;
      border-right: 0;
      border-bottom: 1px solid #f3f2ea;
      box-shadow: -1px 0 0 white, -1px 1px 0 white, 0 1px 0 white, 1px 0 0 #9d9c99, 1px -1px 0 #9d9c99, 0 -1px 0 #9d9c99, 1px 1px 0 white, -1px -1px #9d9c99
    }

    .xp-is-vertical>input.xp-slider[type="range"]::-moz-range-track {
      border-left: 1px solid #f3f2ea;
      border-right: 0;
      border-bottom: 1px solid #f3f2ea;
      box-shadow: -1px 0 0 white, -1px 1px 0 white, 0 1px 0 white, 1px 0 0 #9d9c99, 1px -1px 0 #9d9c99, 0 -1px 0 #9d9c99, 1px 1px 0 white, -1px -1px #9d9c99
    }

    section.xp-tabs>menu[role="tablist"]>button {
      font-family: "Pixelated MS Sans Serif", Arial;
      font-size: 11px;
      box-sizing: border-box;
      border: none;
      background: #ece9d8;
      box-shadow: inset -1px -1px #0a0a0a, inset 1px 1px #ffffff, inset -2px -2px #808080, inset 2px 2px #dfdfdf;
      border-radius: 0;
      min-width: 75px;
      min-height: 23px;
      padding: 0 12px
    }

    section.xp-tabs>menu[role="tablist"]>button:not(:disabled):active {
      box-shadow: inset -1px -1px #ffffff, inset 1px 1px #0a0a0a, inset -2px -2px #dfdfdf, inset 2px 2px #808080
    }

    section.xp-tabs>menu[role="tablist"]>button:not(:disabled).active {
      box-shadow: inset -1px -1px #ffffff, inset 1px 1px #0a0a0a, inset -2px -2px #dfdfdf, inset 2px 2px #808080
    }

    section.xp-tabs>menu[role="tablist"]>button:focus,
    section.xp-tabs>menu[role="tablist"]>button.focused {
      outline: 1px dotted #000000;
      outline-offset: -4px
    }

    section.xp-tabs>menu[role="tablist"]>button::-moz-focus-inner {
      border: 0
    }

    section.xp-tabs>menu[role="tablist"]>button {
      font-family: "Pixelated MS Sans Serif", Arial;
      -webkit-font-smoothing: antialiased;
      font-size: 11px;
      box-sizing: border-box;
      border: 1px solid #003c74;
      background: linear-gradient(180deg, rgba(255, 255, 255, 1) 0%, rgba(236, 235, 229, 1) 86%, rgba(216, 208, 196, 1) 100%);
      box-shadow: none;
      border-radius: 3px
    }

    section.xp-tabs>menu[role="tablist"]>button:not(:disabled):active,
    section.xp-tabs>menu[role="tablist"]>button:not(:disabled).active {
      box-shadow: none;
      background: linear-gradient(180deg, rgba(205, 202, 195, 1) 0%, rgba(227, 227, 219, 1) 8%, rgba(229, 229, 222, 1) 94%, rgba(242, 242, 241, 1) 100%)
    }

    section.xp-tabs>menu[role="tablist"]>button:not(:disabled):hover {
      box-shadow: inset -1px 1px #fff0cf, inset 1px 2px #fdd889, inset -2px 2px #fbc761, inset 2px -2px #e5a01a
    }

    section.xp-tabs>menu[role="tablist"]>button:focus,
    section.xp-tabs>menu[role="tablist"]>button.focused {
      box-shadow: inset -1px 1px #cee7ff, inset 1px 2px #98b8ea, inset -2px 2px #bcd4f6, inset 1px -1px #89ade4, inset 2px -2px #89ade4
    }

    section.xp-tabs>menu[role="tablist"]>button::-moz-focus-inner {
      border: 0
    }

    section.xp-tabs>menu[role="tabpanel"] {
      position: relative;
      z-index: 2
    }

    section.xp-tabs>menu[role="tablist"] {
      position: relative;
      margin: 0 0 -2px 0;
      text-indent: 0;
      list-style-type: none;
      display: flex;
      padding-left: 3px
    }

    section.xp-tabs>menu[role="tablist"]>button {
      border-top-left-radius: 3px;
      border-top-right-radius: 3px;
      z-index: 1;
      display: block;
      color: #222;
      text-decoration: none;
      min-width: unset
    }

    section.xp-tabs>menu[role="tablist"]>button[aria-selected="true"] {
      padding-bottom: 2px;
      margin-top: -2px;
      background-color: #ece9d8;
      position: relative;
      z-index: 8;
      margin-left: -3px;
      margin-bottom: 1px
    }

    section.xp-tabs>menu[role="tablist"]>button:focus {
      outline: 1px dotted #222;
      outline-offset: -4px
    }

    section.xp-tabs>menu[role="tablist"].justified>button {
      flex-grow: 1;
      text-align: center
    }

    section.xp-tabs>article[role="tabpanel"] {
      padding: 14px;
      clear: both;
      background: linear-gradient(180deg, rgba(252, 252, 254, 1) 0%, rgba(244, 243, 238, 1) 100%);
      border: 1px solid #919b9c;
      position: relative;
      z-index: 2;
      margin-bottom: 9px
    }

    section.xp-tabs>menu[role="tablist"]>button {
      background: linear-gradient(180deg, rgba(255, 255, 255, 1) 0%, rgba(250, 250, 249, 1) 26%, rgba(240, 240, 234, 1) 95%, rgba(236, 235, 229, 1) 100%);
      margin-left: -1px;
      margin-right: 2px;
      border-radius: 0;
      border-color: #91a7b4;
      border-top-right-radius: 3px;
      border-top-left-radius: 3px;
      padding: 0 12px 3px
    }

    section.xp-tabs>menu[role="tablist"]>button:hover {
      box-shadow: unset;
      border-top: 1px solid #e68b2c;
      box-shadow: inset 0px 2px #ffc73c
    }

    section.xp-tabs>menu[role="tablist"]>button[aria-selected="true"] {
      background: #fcfcfe;
      border-color: #919b9c;
      margin-right: -1px;
      border-bottom: 1px solid transparent;
      border-top: 1px solid #e68b2c;
      box-shadow: inset 0px 2px #ffc73c
    }

    section.xp-tabs>menu[role="tablist"]>button[aria-selected="true"]:first-of-type::before {
      content: "";
      display: block;
      position: absolute;
      z-index: -1;
      top: 100%;
      left: -1px;
      height: 2px;
      width: 0;
      border-left: 1px solid #919b9c
    }

    section.xp-tabs>article[role="tabpanel"] {
      box-shadow: inset 1px 1px #fcfcfe, inset -1px -1px #fcfcfe, 1px 2px 2px 0px rgba(208, 206, 191, 0.75)
    }

    textarea.xp-textarea::selection {
      background: #2267cb;
      color: white
    }

    textarea.xp-textarea {
      font-family: "Pixelated MS Sans Serif", Arial;
      font-size: 11px;
      padding: 3px 4px;
      border: none;
      background-color: #ffffff;
      box-sizing: border-box;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      border-radius: 0
    }

    textarea.xp-textarea:focus {
      outline: none
    }

    input.xp-textbox[type="text"] {
      padding: 3px 4px;
      border: none;
      background-color: #ffffff;
      box-sizing: border-box;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      border-radius: 0;
      height: 21px;
      line-height: 2
    }

    input.xp-textbox[type="password"] {
      padding: 3px 4px;
      border: none;
      background-color: #ffffff;
      box-sizing: border-box;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      border-radius: 0;
      height: 21px;
      line-height: 2
    }

    input.xp-textbox[type="email"] {
      padding: 3px 4px;
      border: none;
      background-color: #ffffff;
      box-sizing: border-box;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      border-radius: 0;
      height: 21px;
      line-height: 2
    }

    input.xp-textbox[type="text"]:focus,
    input.xp-textbox[type="password"]:focus,
    input.xp-textbox[type="email"]:focus {
      outline: none
    }

    input.xp-textbox[type="text"],
    input.xp-textbox[type="password"],
    input.xp-textbox[type="email"] {
      height: 23px
    }

    ul.xp-tree-view {
      -webkit-font-smoothing: auto;
      border: 1px solid #7f9db9;
      padding: 2px 5px
    }

    ul.xp-tree-view {
      font-family: "Pixelated MS Sans Serif", Arial;
      font-size: 11px;
      display: block;
      background: #ffffff;
      padding: 6px;
      margin: 0
    }

    ul.xp-tree-view li {
      list-style-type: none;
      margin-top: 3px
    }

    ul.xp-tree-view a {
      text-decoration: none;
      color: #000
    }

    ul.xp-tree-view a:focus {
      background-color: #2267cb;
      color: #ffffff
    }

    ul.xp-tree-view ul {
      margin-top: 3px;
      margin-left: 16px;
      padding-left: 16px;
      border-left: 1px dotted #808080
    }

    ul.xp-tree-view ul>li {
      position: relative
    }

    ul.xp-tree-view ul>li::before {
      content: "";
      display: block;
      position: absolute;
      left: -16px;
      top: 6px;
      width: 12px;
      border-bottom: 1px dotted #808080
    }

    ul.xp-tree-view ul>li:last-child::after {
      content: "";
      display: block;
      position: absolute;
      left: -20px;
      top: 7px;
      bottom: 0px;
      width: 8px;
      background: #ffffff
    }

    ul.xp-tree-view ul details>summary:before {
      margin-left: -22px;
      position: relative;
      z-index: 1
    }

    ul.xp-tree-view details {
      margin-top: 0
    }

    ul.xp-tree-view details>summary:before {
      text-align: center;
      display: block;
      float: left;
      content: "+";
      border: 1px solid #808080;
      width: 8px;
      height: 9px;
      line-height: 9px;
      margin-right: 5px;
      padding-left: 1px;
      background-color: #fff
    }

    ul.xp-tree-view details[open] summary {
      margin-bottom: 0
    }

    ul.xp-tree-view details[open]>summary:before {
      content: "-"
    }

    .xp-window {
      font-size: 11px;
      box-shadow: inset -1px -1px #0a0a0a, inset 1px 1px #dfdfdf, inset -2px -2px #808080, inset 2px 2px #ffffff;
      background: #ece9d8;
      padding: 3px
    }

    .xp-window fieldset {
      margin-bottom: 9px
    }

    .xp-title-bar {
      font-size: 11px;
      background: black;
      padding: 3px 2px 3px 3px;
      display: flex;
      justify-content: space-between;
      align-items: center
    }

    .xp-title-bar-text {
      font-weight: bold;
      color: white;
      letter-spacing: 0;
      margin-right: 24px
    }

    .xp-title-bar-controls {
      display: flex
    }

    .xp-title-bar-controls button {
      padding: 0;
      display: block;
      min-width: 16px;
      min-height: 14px
    }

    .xp-title-bar-controls button:focus {
      outline: none
    }

    .xp-title-bar-controls button[aria-label="Minimize"] {}

    .xp-title-bar-controls button[aria-label="Maximize"] {}

    .xp-title-bar-controls button[aria-label="Help"] {}

    .xp-title-bar-controls button[aria-label="Close"] {}

    .xp-window-body {
      margin: 8px
    }

    .xp-window-body pre {
      margin: -8px
    }

    .xp-window {
      box-shadow: inset -1px -1px #00138c, inset 1px 1px #0831d9, inset -2px -2px #001ea0, inset 2px 2px #166aee, inset -3px -3px #003bda, inset 3px 3px #0855dd;
      border-top-left-radius: 8px;
      border-top-right-radius: 8px;
      padding: 0 0 3px 0;
      -webkit-font-smoothing: antialiased
    }

    .xp-title-bar {
      font-family: "sans-serif";
      background: linear-gradient(180deg, rgba(9, 151, 255, 1) 0%, rgba(0, 83, 238, 1) 8%, rgba(0, 80, 238, 1) 40%, rgba(0, 102, 255, 1) 88%, rgba(0, 102, 255, 1) 93%, rgba(0, 91, 255, 1) 95%, rgba(0, 61, 215, 1) 96%, rgba(0, 61, 215, 1) 100%);
      padding: 3px 5px 3px 3px;
      border-top: 1px solid #0831d9;
      border-left: 1px solid #0831d9;
      border-right: 1px solid #001ea0;
      border-top-left-radius: 8px;
      border-top-right-radius: 7px;
      font-size: 13px;
      text-shadow: 1px 1px #0f1089
    }

    .xp-title-bar-text {
      padding-left: 3px;
      cursor: default
    }

    .xp-title-bar-controls {
      display: flex
    }

    .xp-title-bar-controls button {
      min-width: 21px;
      min-height: 21px;
      margin-left: 2px;
      background-repeat: no-repeat;
      background-position: center;
      box-shadow: none;
      background-color: #0050ee;
      transition: background 100ms;
      border: none
    }

    .xp-title-bar-controls button:active,
    .xp-title-bar-controls button:hover,
    .xp-title-bar-controls button:focus {
      box-shadow: none !important
    }

    .xp-title-bar-controls button[aria-label="Minimize"] {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVCAYAAACpF6WWAAAABmJLR0QA/wD/AP+gvaeTAAAC2ElEQVQ4jaWVwYpcRRSGv1N1O0FBFxndzCZv4Epcia/g1icYca9mo7h3IUIgCMG8gaALX8EH8BGEEcZhSHqS7ulbVef8Ls7tnh5RNymoW1234av//8+pbgDOnlzq/KrrdcfZk0sBTGePL/Tlxw/47qfO1fVgsxO7Bn2INqAUaB0APHLddR32uwY3c+fdN9c8+/wBPL6QSdKjH2dOT4ypwnojXmxg7tC6iIARCZCgu3CH5jA3sZ3h5dZZr9e8xR/8+v0HFIDnr8T9FdxbGVM1VhNMFVbVKMWoBrXknIpRCxSDWoypwKrmPP/rFacnExPAy6243sJUxXYWNzPMLZW2AX1kHB7QhhDke1+UR8ZUSwFIaBvwYiNqgc0Otru0NreEtAbzEH3kGspIgoxEIYoZq8luoX0krBRoDXq/na3noa1nju04YwyDfFoCD9C5i9Yzpz5guBgOI9LaCOGCIdHD7hRun29IiCOlALuWFmIBuSD2q8BJu0F+Hvu9FojlIQfodhZzF1MFFogkKEDR7dFmyEAOMiO0hGqACsE/Mt01uDftrYCSn1kZWNWenN9ZOpHsYHt/ORLqWeVaUoGUdihgWrh7eCyKAyIEAe4GgqEjpXPPWUv2qtmRypI6rCzASDie1ffFQIThx9A2xNzzFmHGL9+8wX+N977egQyR/bovpofRlxPuKF3VfWL/M2zJEyOAHtl+McTwO0qzUFPVnSb+t+GyQxFj2Q+H4eBxpHQ43DSoFYT46IstYISJsIyxm9EwuqALxoAxDB+p1F3oGNpa42YuVDPCYaqGGThZFC8wDDpGE7Qwmi/gJrw50QZ4/vBOfz4PTt++5nINajCvKlMRZiJkqNjhFrlVutJyZmn4ALUBuzUP30ml9umzrT77sPPJV79zfvGSaXUfs6AQhMCsgmW7OAXHCBXCHQ8IKhqdhyedn799nx9+Wzrn7Onmtf+fzq9cZ083Avgb/56VnA0RSb0AAAAASUVORK5CYII=")
    }

    .xp-title-bar-controls button[aria-label="Minimize"]:hover {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVCAYAAACpF6WWAAAABmJLR0QA/wD/AP+gvaeTAAAC3klEQVQ4jaWVsa4cRRBFT1f3vH1Gz5ETJxCRIDISMjIHfAQ/QEiMiPwBllZC4hdMYstEBAiJT0AiICIBCbDR83p3Z6a7q4qgetkFyUiIllo7o945fe+t6hkAtk9f+Kuj+v8Zh1l9+/SFA6Ttk+f+4fv3+PxrWBocFjhW6Aprg5SgKQCYQTdoHdzjP0uDda3c2/zBFx/f8O33K+kwq3/2WHj7PkwF9gvs5gDWHlMHTAdQLdbXHiL2x87Ll7fc6E988+g9yhvXwtphM8FVAVWoDXAwBwdEQ3ECKECHkgM+FZhKYsrOL7/O3NwRCsBxhVczXE9hfenD1lBTG1Q9R2IeDppCa2Dm5CyUnDjty1zDdu3x0HEN6FwHuMX9af0Uh2lsgCckQRHO0KYXxdGhYijpBs3ieu2x3noUzYlIBguSnKG1D+jItGmA1GKj7qAJlPPs4TSACZBT6APqHvbMwk7TAKoN4IBaDnWWhm2igA54GzeXmS4VfIqqq5/tISFCgFxAHJLG76k7TGNDkwv7bVSV4cKJB2xYSwJyAReLjXFwA+9gi6CXSuuosCTII3UdSpKAlFCZBfKITmzE1SOOnhPKhdJTy4jAlAOul6UtIBPkCSRDJvJOBtrAPNFSQrlQerJfchTty0947XjwJPrxryPr0DOsnuh2aX809ZRfDzsNFyCHZXVoafQxie7/gC4N8miZfxtmo71G5joOR+3+d2jr0VI5RTUfPBwtlyFtgGvQK+gb6BMsAtXH+6DF1O74aN6Atsq8JoSEjWOYUgqojpa5Al3j1NWcWMdLpa5O2xv90NG1BnQ/G/fv/M7z/YQuzmbKFHEkg5PwkmACywmbhJ4FHTl2hFqdtm/Y7S1v3V05LkbafrXzD94RPnr4Az//diCXTE6OCDiCS0ZKRnEsT1jKONB7x+QKM8fWypt3Fx5/+i7f/Vgi/O2znR/m//aNMjNXVe+9u6r67tB9+2znAH8CuwBzYGmFBk4AAAAASUVORK5CYII=")
    }

    .xp-title-bar-controls button[aria-label="Minimize"]:not(:disabled):active {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVCAYAAACpF6WWAAAABmJLR0QA/wD/AP+gvaeTAAACAklEQVQ4ja2VO28TQRDHfzN7F8eKQOIRIUUIt5bo+A70KYAPkIqPkJYCyX1aehc0SYuQJSS+AghK01kiYITjUOR2KXb2bu/BQ4KRRncea3/zn8faAJycnYfNtgr/YpttFU7OzgOAzF9/CdM7nzl8+pzlagNSgAhoAVqC24nvCLhRjIlrYlpA8EwObnE6e8SHTyWy2Vbh/sMjll8d7FyPh9RFgCTwqJ1INIJFAAUCIEz2R7x78Zhib6wsV9/h2j0Y3QQ3bmBaNiB10WuY2JP4TmD5LbA3Voo6qKMIVCtRrWy1UsWZQgHVDJigjWmMaaaoBCmtt+aonQvxVAjRf2FRaa3MnlKYOhsG2pQrCtpWhkgrSQYtGnANtTKTa/65X3YCG7TIwJ3eJSU60M+OwgGlGRQ3rDK5ZJNPUO+jt5WmkvOVoQ90rg8NoZXAoDudhc6AOdS530PbSstsMKmP2gHqcAtS2QYcKD+uzPGTaa/5yWavVv2+QmuAtvwOq7dzUwYsH17LGYCmsv/WpNP3endT+VkWgNnLj83A8gE5F3sbBHxlQmxQgfoW2w+KWsBAdabMQoDgwQvgTZmP8c6w9OLSMzm40e9lWpX8UOWhquDqqu9VxWR/l4tLj8wX6zC9+4PDZ29Yru26/mkwedwST27vcnr8gLfv7fv5Yv1f/qPmi3UA+AmOhyVybMM72AAAAABJRU5ErkJggg==")
    }

    .xp-title-bar-controls button[aria-label="Maximize"] {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVCAYAAACpF6WWAAAABmJLR0QA/wD/AP+gvaeTAAACy0lEQVQ4jaWVzYokRRRGz43InJYBXUzrpjfzDiKuxFdwJfgEJYJLRzduhtm5GIQRfxDnDQQ38wS+gVt3Qgtt08xU91R1ZUTc+FzczOpSNy0TEBT5U6fO/e7NLABW357r9KLqVdfqm3MBDKsnZ/r8g3s8/rlycdnY7MSuQG2iNEgJSgUA7/G5q9of7wpcT5W37q55+tk9eHImk6Qvfpo4OTaGDOuNeLGBqUKpondoPQASVBfuUBymIrYTXG2d9XrN6/zBs6/fJQE8fymORrgzGkM2xgGGDGM2UjKyQU6xh2TkBMkgJ2NIMObYp3+95OR4YAC42orLLQxZbCdxPcFUwrQ0qC3i8A6lCUGc99m8R0w5JYCAlgYvNiIn2Ozg8eqI2663P92gLpIZ42A30NoClhKUcmseAK0bhoHZ/twAMFVRauRU2/+DuuJ7XUIcmALsSpTQe4zLh492lCKmFjlODsXF5EadJ+L37+9SNUMspmMP3U5iqmLIwHxBEiQg6eanzZCBHDSX6xZAlOj8K9NdgTtDlMLM1gzCwLIWclyb7/Nk+7KXhyOgHiXmdGOAAQlMM3eB99l4BngGdwNB04HpVGPnFLO6mGIGKTwszcAecDygbZbo3fBDaGliqvEULaPhWjrKvlzLSzaG5vC7xb3ejer6r+mYl8SgudER3QIoLfZxvDSldmgOvYnm/zCNRg1Ze9NnD1/jNstlNA+w9wPT5nBdIGcQ4v0HW8DoFqbdoJpRMCZB0SzSDG8KoAsdQkspXE+JbEZ3GLJhBk40xRM0g4oFsBvFoTVoRXhxemng8eId/nzeOXnjkvM1qMA0ZoYkzESXoWT0udlumaooufbI0BuoNNituf9mmNrHT7f65L3KR1/+xunZFcN4hFkn0ekCswwW4+IkHKMr0d3xDp2MWuX+ceWXr97hu1/nXqx+3Lzy/9PphWv1w5UA/gatL02qRrGFlAAAAABJRU5ErkJggg==")
    }

    .xp-title-bar-controls button[aria-label="Maximize"]:hover {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVCAYAAACpF6WWAAAABmJLR0QA/wD/AP+gvaeTAAACvklEQVQ4jaWVvY7kRBSFv7pV7p6BXQmJZCUEAYIIkRCS8wTEZESEpPyIYB+ACGlfYSU0OQnSPAERERIki/gTM7t0t+2quvcS3Gq6IRq0JZVsy+Wvzjn32gbg6vrGdwf15xn7Wf3q+sYB0tX1jb/95kt89Q0sDfYLHCp0hbVBStAUAMygG7QO7rFmabCulZe3f/Loo3v88KST9rP654+FNx7AVGC3wLM5gLXH1AHTAVSL+2sPEbtD5+nTW+7pT3z75TuUFy6EtcN2gk0BVagNcDAHB0RDcQIoQIeSAz4VmEpiys7Pv868eCkUgMMKf81wMYX1pQ9bQ01tUPUUiXk4aAqtgZmTs1By4rgvcw3btcdDn73Pnce7nwCekARFOEGbnhVH7w4EUAc5XiQ5QWsf0JHp/4ImImw5hj6g7pGhWeQF8OGjiGLpoX61ka+OfB2++wJ8E8X0RlSTs0yXCj4RK4gNHEBChAC5gDgkjSOAX4ApWAaTM/ttVJXhAkKxEdaSgJzBxSLLI9Q72CLoudI62kcS5JG6jiiSgJRQmQXyiE5sbL4FS9BzQjlTurbIVASmfILG07FKJsgTSIZ8vA/YJZgnWkooZ0qP9kuOoh3tq483KROkAS9ygmqBnmH1RLdz+6PpjyqPG7lE4Zw4P05yWAZoCZpBI9H9P9ClQc7/FJ+vP+ZOQy2gtfu/oa1HS+UEbvDew9FyGdIWuADdQN9Cn2ARqA6zQm8xtTs+mjygrTKvCSFhGpuklAKqo2U2oGu8dTUn1vFRqavTdkbfd3StAd3PxoPL3/ljN6GLs50yRRzJ4CS8JJjAcsImoWdBR44doVan7Rp2e8tr91cOi8WX//VXJj54+D1PftuTSyYnRwQcwSUjJaM4licsZRzovWOywcyxtfLq/YXHn77Fj7+MCl5d3/h+fr5/1O5w+kf9DVinM4OPooUXAAAAAElFTkSuQmCC")
    }

    .xp-title-bar-controls button[aria-label="Maximize"]:not(:disabled):active {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVCAYAAACpF6WWAAAABmJLR0QA/wD/AP+gvaeTAAAB/klEQVQ4jaWVzWoUQRDHf1U9+xFFxY94COIePAgefQPBBwhiXkAvPsJePQj7EF49eQnuE4j7BuLB40IQouAa3M0qZKY8dM10z07UhBTUdlN0//pfVdO9AExnC1sel3YRW61Lm84WBiDT2cLuXPvG7otXzA+XIAWIgBagPQj9OEcgDGJMQoppAVYx2rnJ/uQpB1/7yGpd2oPHz5gvAvSvxk0aIkBq8KB9kGgEiwAKGCCMtgd8er1HcWmozA9/wpW7MLgBYSvBtJdAGqI3MPGROMeYHxmXt5SiCeogAtVTVE9bPVUJrlBANQPW0GQRKpop6jF+/oiz2uTt505M42+tzMfzmpymtKmdg89jGtLcLIcWGTgumrz5mDbkdczqOX5yr6NyQ2kb2jSldtXkknU++Pqqit5WWqQu1+qELjCELtTT3ki/v/FBk4A5NIR/Q9tKPXXR6Hn6DVC7JaihWeqnpC8JqtKuqfwFqppGj8WIhDrfdjdlE7zhrTU0saKB1grdxnv3OZO1DsrTz04Bv3r1o5E3KASvbfA9/kKZxYfKcijqAQc1J2VmBlZBJUDlyqoYrxvlzdLVumK0c717M8yS1xvKCsoSTk66XpaMtocc/6r85b/9m92X75n/KLp3/38N8oNHt4bsjx9y8MU/relsYav1xf6jlselvfvw3QD+AN6+FyT7ZKzaAAAAAElFTkSuQmCC")
    }

    .xp-title-bar-controls button[aria-label="Help"] {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVCAYAAACpF6WWAAAABmJLR0QA/wD/AP+gvaeTAAADbklEQVQ4jaWVPYidRRSGnzPz3V3ummyRTfxJoluIJNiq+IOFTbCMWKXYRjubtRHSiIid6UNA8CdgYaciFyyCPxg2dkKwEUXQkMgak7t379177zcz5xyL+XJ3tc3AMBxm5p33vOedGQAGW0OfTNXvtw22hg4gg62hn1pf5dIgc2fX2Zs78wS5OKlACJAyAKjVcZ59Ec8TzNrMsZURH711hBu3FXF3P/9hy/E1oYkw2nN29qDNkLJjBsUqgDtkdVQhKbTJmbYwniqj0YjD/MnVD54jAAwnznIPlnpCE4VeA02EXhRCEKJADLU3QYgBgkAMQhOgF2u/+feEB/qBBmA8dXan0ERn2jqzFtoEp08KZ19oeOzBwL32x7Zx+Urmh5+VrB1zqzLFUNc1AKnAzp4TA+zNYTqHUyeE117ucagv/HLDmCXn0WOB9YcCm68sMZ62fHNdcQc3J4jQa2QfNJcKFgKkBDnDmacaDvWFr64VLn6ZabOz0hfe2Vji2dORV1/s8fVPhgCCgMgimwDQZiflDrBAUWdtVbh1x/ns20IxRx3+GRufflcA6C8LWUEdDDB3nANMAeappmBWNdq82JKS0xYwB6VufuRI3VgMMnWuAZDqjgXotHXa7DQR8LrQ3WsewRdHv35miY2XavDjr4bFDkkADxj/03SeYKmpVjEHr/ggwuEV4f1zPZ55IgJw+fvCpSsZC+Aui7TvXY4KqpBKrb6L1DSkKi4Om2cr4O/bxnufZ6795mQXrKmCqgo4FD/AtM21x1C9KrLPkuA8/nBd/MbHib/G3S4FR9BORzNBD4Km4rS53iJEqgSLisJ4Bncnzs6884sLjmMOZtUBakLuTvgP014EwYlRMATDMYE3P2lJXpkh4EI3D9mcomDFKSr7Pk1doea5WigVJxcnKxSFCxvLXH23jxqoy6KIRo1L98AUO8C0KMwSxAiO08R6okll+uTJGqcM2Z3sUAqUImipTFUdPwiaUmLWBqIIptBEQQS0S/f58xOKQEZIDsmkMitQkqNJsVRA68Pb7M2M46u73B6BJ2h7kSY4Io654KFqp4BKJHtNuWopaAFPBeYj1o9WpjLYGvqJo4Fzb1/n5vaYpreMiBEwzEEkglS7KAFFMA+YKmpgRLxk1tcyX1x4mlt3u2dysDW87/9pMtXFH/UvCuyr4gYlHLkAAAAASUVORK5CYII=")
    }

    .xp-title-bar-controls button[aria-label="Help"]:hover {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVCAYAAACpF6WWAAAABmJLR0QA/wD/AP+gvaeTAAADVElEQVQ4jaWVy4sdVRCHv3NO951HZkAmEgc0wReIuvG9UFBcROIqOyELXQr6F/jCbFxL4EIgCC4lZiGMCkKEQVGRCC5iUAi4UCGS0WScx739OI8qF9Uzc7NOQ0M/6nxVv19VnwZgvLapu03R2zmmbdHx2k0FcOO1m/ryMyucvQhdgmkHTYRcoE/gHKQCACKQBVIGVYvpEvR95PDcJufeXOKbKxE3bYu+f8Hz4CrUFUw62GkNGLOdZYCVAVjE3vfZipg0me3tLZbKH6yfeYJqcd7TZ5irYVRBKRAToCAKCvhiFTuACshQBYPXFdSVow7K3xstSwueCqDpYbeF+dqkd9lk3X8XnHgM7llh//jrBnzyPfxw1WxJCUSUEDxVcOzlpY0mO2aT1fRw3xE49Swcmoffr1vM3Stw7E544yUr4ttfTQ3q8A4qzwE0lZnmFIO/8IgBL16Gj9ahi2bRWyfhqQfg5NPw9RWzxO/JcHblwSBNhCaZn6nAHYfg+hZ89hNkheJgs4FPL9n6+RFkZ8/FA37P9KFSVfNQxOSkAu+eNyu6DGWASoDVwd+sILU1UAFN2M2sp10Era3rRS2BDlq8M0mvPQevPGnQn68BCxYjxRKK97d62icL9kNmURAAB8sLcPoEPH7UYs5fho9/ARZBBTSDdJ4yW2lMBvUOwuB6GebUeXj9RQP+uQUf/giXNiCPbLVkEAc5OAozlfbJPPUe6mDwouy39t7DlujtddjIEBZt8J1ASSDqSM5RmKl0T34VrGkhHFTrHEwi/NfCdgE/snnc/2QVcoBeHVlm5Q9DXw8wGapUb4175yuQOdDR8CyY5KKQHCSBhCOru3VOuwRtOthIUjYFWeD0cVg7NYzcsLHI4HkRg8as+1CTn22kgrNu1sP8Idaoh46Ygq63JJ2HqBAL5GRnyYqKzkBTpO0dHocUS+KcgwCuwPEzICMoNeQKYnD0OmyNvZImQp5mSh8NOmmF1YV/uTGpKZ0yVwcqr/gAikMrBzVIcEjtycFTBh8znhiVNEnI1hbHlnuaTnDjL3f0+Yc9r37wG9f+mRKqQHCK96B41Ad8FSgoEmrEBRTIOSN+hIgifeTocseF9x7lu6uVeTX+Yken7e39o3abouPPtxXgfx38dJDUBeIlAAAAAElFTkSuQmCC")
    }

    .xp-title-bar-controls button[aria-label="Help"]:not(:disabled):active {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVCAYAAACpF6WWAAAABmJLR0QA/wD/AP+gvaeTAAACwklEQVQ4jaWVz2tTSxTHP2fmpvmFlsS2ihWjqFTa91yIYpdd6FJ0oTtXrvwT3LoQ/ANcupWA4KPgRpSKxbd5720UFbSKGLVipLaptok/MjMuZnLvJHEjb+Aww0nuZ77fc05yAagvrLmNtnH/Z220jasvrDoAqS+suoMTK5y+cJlGcwMkARFQCagc6BF/RkDnfU50llMJOEtt5zbmr5zh2ZscstE2bubEeRprGka2+oeU9gDpgfP9F4nyYBFAAQ4QauN5nl47S1IuKhrNL7BlN+SroIsZTOUykNI+UpiEHX/G0Vh3lIuKJE2qvAeqYFGNUCoWOH5kkuk9Fa9IhOfLX7jzcIXNb5ZsCfHyUFGRohxIjmIhz7nj+6iOFnn0qsXXrqM2XmZqcgvjowWuL74bAA9Cg7J0l4Rj09upjhb56+9llt63QQnIKnN/TjA7XeXogQr3n3wKQgWcS6EqgyYROMdEpcyrZoelD21QKrjR/PtyHRAKhSSqc1zfVGkSgTWI4saDZX8OtfRgoVTyI2csPhcp/IX9CIoOYyNZKMXkWImTx7aDEpaa30DrDGqtj36lIfpGhhQ4d2iM2akqKOHmPx9prH3PoD1w2AN0ZGCgI6AIh/dXmJ2q8qLZ4dbDNb4bBzrJQLHafvtJACvSMQsq9+4oeYX/rXh1OmpOz7bNxmvAvniYI5x9fO4YPn7+4RvTi4GOp7kUKprgN3yZbP5EuPt4FfR6v8KhIIWqFNqzTQQM9LmZChdP7Rn+PKp7LCZA6bfSW6EJf+wqA6EhzvrdGrAuyvtjZp9QRzJ18Z/E1dtvfc20AiuADcp6F/Q3S212LLWdlWGlvVGJHzIWjIFudziMoTZeYLNjkfq9lju46yunLy3SaIWf61DtBiLOh4trYwXmLx7m2etQg/q9VvqOstY6Y4zrdrvOGOOstb/xjmo5gJ8c0nJkEuSY3gAAAABJRU5ErkJggg==")
    }

    .xp-title-bar-controls button[aria-label="Close"] {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVCAYAAACpF6WWAAAABmJLR0QA/wD/AP+gvaeTAAADfElEQVQ4jaWVPYhdRRTHf2fufZtE1wQDm2Q3u6xNII02FhaSLTSoldGAELRIIQQDEkst0loqqEhSSBCF+BEwkgVRtJKVEIKVVZqAyG42xPXte/vu23vn4xyLubn7ts7AZYb5+PE/5/zvDADLK30bjZM9alte6RuALK/07eWFDQbfX0I3N9BxhTU1FgMWPDgH0QNgKeXe1wCQEuprYr3NaP8Mix9eYeXfBcTMbOPj9ykOzSFFiY4GpK1NzDfgPaYKKbZAgxiwlLDoMd9g9ZhYbbE5GLDWe4Kla3/iANKwj0ztQaamoCiRsoeUJZQ9cA5zBVIUiCvAlbkXB67o9ruyx2h9lcf3OUoAq7bQ0RApS6weY8021jSY91jwWAg5HZpySrDcp3Y+JXAOVxQAWakFj442ScM+Wg2ZfuF1Zi5+jlYVVlVoNSJVQ3S4iW710cF/HP3iVw68dSELSBFxDil7k9CAjStse4Q1DXufPQHAkY+uosFj0UPwWGyw4Jm/ehOA6ZOnIUUwBaNrLbRBvceaHOr9D852G+Yu3cgHNUGKLHx3u1v759Rx0ISYAgpmO1AAa2q0tRIpsf7eG93ho1d+wywx/82tHeCrxyCF/FlCzBAmoFqPwTcQAsSEqWJirL17qoPMf/1HN149fRznDBFFSIhFRCOiOqE0BqypIfiJHBlixto7rzDZ1s48jThDxHCiuIdQa1M0WSiNPlumzZFIXp27/PMu6Ny3f+Ecu5VqToNo3F0o87myaMRMMTNmP7vRwdbPLXXjw1/ezt53htCGHj1ul9LoMzh6LEVME7Of/LADPP8iYNx/+zkA5LH9HL52F0Fz5VNAks9F7qB+R6mFwOyn1zvgvfMvZauYAcaDs890a4euryEacA+Bu8P3+WbyNRYaxr//lIHnTraXSVuENucP3jwGQP3LV3kuxvbnyFAxM7t7YobiwJPIvmncnr1IUYIApgjZ2GIBUY/EBkk+X4e+xrwnNp7hOHFny3jtjuYLJQSP1ts4KRBVpCgRJ1md0HnRaYDkkdhCQ8RCJIZEiErIdaKstpXq4BzWfwDBKKYaKEpAslKxbDFLFKTWOglLAYkRi4kYjEEAmV3M4S+v9O35g39z88IZBvdWmeqVmAgqDlQpnCCQoZYQTThTUlLQRGGKT4YeWWTp8o/c2nwqy11e6T/y+zQap+6N+h/Q0wtQDc5PFgAAAABJRU5ErkJggg==")
    }

    .xp-title-bar-controls button[aria-label="Close"]:hover {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVCAYAAACpF6WWAAAABmJLR0QA/wD/AP+gvaeTAAADR0lEQVQ4jaWVP4gdRRzHP7+Z3ffevUNDCARRUBRsLGwtREGwSqViJ9iJRINFghAvykFOckQhuRASi9MiErCzEK6wE5HD0srK0hCDkuPevX27O38tfnO370RsHFhmZmfns9/vb34zA8DO7l6eL2L+P6VpY97Z3csAsrO7l888OYNv74Jz0C6gayEG8A4QbWcgJ4gRvAeA4ME7fN+zv/oo04+u8MNfjyFNG/P0y6vwxFNQVQpt5gr0XiemqLAYtX8Idj10LbFpmM1m3KvGPP3Vd1TTiVGF9QjqWgGHSrJWRFHFItoXgZTAVvrUNbmq6B78weqKoQLUbttAHEHXqQLnwHVFsQMfNAzOaRi8hxCKk4SxFqksAAZQyKKBplH7L7wM754vP1vAYgHNARzMYD7T+vNteOMt6HtIiSwGsctQ73Wwa/UHzz2vNj/cKGrCoCp4uHlXx196FXJESCU6sgQNHvoW+mJ3a4Ojsn4NciwBznDrm2Hsndc1vsZgTIn7ETTnEscSy+Bh8+Iw+coXYAS2vh7evf8m1BZGVmtrEKUVaNepfe8glpTJGS5fGCBXt4f2xbdhOobpCCY1jCqkMlizrDSGQWkImlYpqd2N8xwrn74H08k/oBZjpZg/Wig32A5hUCrAJ9eOQz++DatjWJ3AygjGFmpBrGAlL0GdK0oLNCVVuwy8uTa0z32mKqdjGNeIFUQShrRsPy4leQGvXx8gNy6BtbC9rv3xCpzbglEFtYDJSIqYFP/F/uFev3xjAG5e0B0k5es768PY2etAghSQVMLGcvIfLpR38POPOmntbDlEyoSU9LlzScd/3dVFLieaZLUvOefMay/CIydgsgKjMVS15mVlYVJWeFyVnEQ3Qw5lFy7I+3O6P/f5/d5Dnv3+Fz1QvPNI1yEIOSak8mAMWAPRga8Rp0kuJoOoZbyDtiU1LWHR45yeblXTJuYnTlHP9sg+YOoR2VowBhGQyiIji1iDrQ1GSqqliEmB3PeEpuVgtqA/eZpFl/Tkf+XUfX5b+4D2wX3EVqrSGAwZKwoToDaCkYwRiCFSSyanSN95+pOneWbzFj89fFzjvbO7l5v2+B2VUsoxxhxCyDHGnFL6zztqvhjuqL8BQ01PLsz+KREAAAAASUVORK5CYII=")
    }

    .xp-title-bar-controls button[aria-label="Close"]:not(:disabled):active {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVCAYAAACpF6WWAAAABmJLR0QA/wD/AP+gvaeTAAAC0klEQVQ4ja2VzW4URxSFv3Oru43xgiABJhjMSCgoItmxBMlSJJRV2IUFGKHsAoMi3iEvECRsLGVFEhhMluzALEmiPEKyAGxjQMFKAvYgMdNVWVT1D/bsQknVXd3T96tz7q2rAaC3tB42+mX4P2OjX4bevZcBIOstrYfj+1a4MnOS/vNVnMAQmUEuMWYiM2HAmInCwElkAqXvfIDdU9OcvnqD3r2XQRv9MlyZ+ZR8fY1dmVFYDNhh9g7YBJniBk7gBAJMIoSAJPLJg3x2+zeyiXFj89kqnYmMPblj3ESWQLlFUF6BTJjiBiKO6g4Q1teYGDey6sWYxLgTOxQtFoLMKmURGoFCArVobTCAAZggN1FIFCb2HPmYT776hlzCAY6YPwKkC9PnuuzsHGXUMIDClIogCsGhmc8xwUcXLuOIdk1gBpLozHYRsPfEqahU2g7N1OQuN/Hoh2tYKsKRC5frPFoFTPZXevNYArbBBiQY5HUx4NGPc4gY3DnfRRKHExBgNQHNlBw04Np+oVh1l6ZJPPlprlYRwXG9tngd54RzEWimEUolnDVnUK0KL9+cr9cVMKozzCpwo7alNFa4Oja0II3luNGhs5dwZrgKmFJQCXlHaZZ+qA/3FuDa4nVkMXDy9DnMRXfmLIG35DS32MPWUtiZ7daKn96OKXi+uAAS+cQuPjxzEaWialROqz6mqvZsN66BlVvzyVpU+eLnhbgZsP/Lr5v8syWnTsJizwDw18P7IFi+Nc/2JmzA//7+oAa2+7bufamJ7z/+g+Unf6aPAyHQTA/B4NmdBSx1bqgvLaglWIu7TV8b7AMoBLyq54APDdc233g+ODA9AhIIIeA9eB/XpU9z6Cm9pyzTcxnwPlBMTrH5xmN3f33NF9/dIJ88iA+MGNF+WQbK0jMcegZDz2DgeTsoGQxKhkNPtneKY99+z91fXsWw3oN/3s9/1NLfAeA/4hdsCoYfkP8AAAAASUVORK5CYII=")
    }
  </style>
  <link rel="apple-touch-icon" href="data:image/png;base64,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">
  <link rel="shortcut icon" href="data:image/png;base64,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">
  <link rel="mask-icon" href="data:image/png;base64,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" color="red">
  <meta name="msapplication-TileColor" content="#008080">
  <meta name="msapplication-TileImage" content="data:image/png;base64,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">
  <meta name="theme-color" content="#000080">

  <meta name="viewport" content="width=device-width, user-scalable=no">

  <script>
    const CLASSIC_THEME_BASE64 = "data:text/css;base64,LypAaW1wb3J0ICIuLi8uLi9saWIvb3MtZ3VpL3dpbmRvd3MtOTguY3NzIjsqLwo6cm9vdCB7CgkvKiBUaGVzZSByZXNvdXJjZXMgYXJlIGdlbmVyYXRlZC4gKi8KCS8qIEpTOiBtYWtlVGhlbWVDU1NGaWxlKHJlbmRlclRoZW1lR3JhcGhpY3MoZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpKSkgKi8KCS0tY2hlY2tlcjogdXJsKCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFJQUFBQUNDQVlBQUFCeXRnMGtBQUFBRzBsRVFWUVlWMlA4Ly8vLy80TUhEekl3SGpodzRMKzl2VDBEQUhBRkNqNmVzcTNGQUFBQUFFbEZUa1N1UW1DQyIpOwoJLS1idXR0b24tYWN0aXZlLWJvcmRlci1pbWFnZTogdXJsKCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIwdmVyc2lvbiUzRCUyMjEuMSUyMiUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIyNTZweCUyMiUyMGhlaWdodCUzRCUyMjI1NnB4JTIyJTIwdmlld0JveCUzRCUyMjAlMjAwJTIwMjU2JTIwMjU2JTIyJTNFJTBBJTA5JTA5JTA5JTBBJTA5JTA5JTNDcGF0aCUyMGQlM0QlMjJNMCUyMDBoMjU2djI1NmgtMjU2di0yNTZ6JTIyJTIwZmlsbCUzRCUyMiUyMHJnYigwJTJDJTIwMCUyQyUyMDApJTIyJTJGJTNFJTBBJTA5JTA5JTNDcGF0aCUyMGQlM0QlMjJNMzIlMjAzMmgxOTJ2MTkyaC0xOTJ2LTE5MnolMjIlMjBmaWxsJTNEJTIyJTIwcmdiKDEyOCUyQyUyMDEyOCUyQyUyMDEyOCklMjIlMkYlM0UlMEElMDklMDklM0NwYXRoJTIwZCUzRCUyMk02NCUyMDY0aDEyOHYxMjhoLTEyOHYtMTI4eiUyMiUyMGZpbGwlM0QlMjIlMjByZ2IoMTkyJTJDJTIwMTkyJTJDJTIwMTkyKSUyMiUyRiUzRSUwQSUwOSUwQSUwOSUwOSUzQyUyRnN2ZyUzRSIpIDY0IC8gMnB4OwoJLS1idXR0b24tbm9ybWFsLWJvcmRlci1pbWFnZTogdXJsKCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIwdmVyc2lvbiUzRCUyMjEuMSUyMiUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIyNTZweCUyMiUyMGhlaWdodCUzRCUyMjI1NnB4JTIyJTIwdmlld0JveCUzRCUyMjAlMjAwJTIwMjU2JTIwMjU2JTIyJTNFJTBBJTA5JTA5JTA5JTBBJTA5JTA5JTNDcGF0aCUyMGQlM0QlMjJNMCUyMDBoMjI0djMyaC0xOTJ2MTkyaC0zMnYtMjI0eiUyMiUyMGZpbGwlM0QlMjIlMjByZ2IoMjU1JTJDJTIwMjU1JTJDJTIwMjU1KSUyMiUyRiUzRSUwQSUwOSUwOSUzQ3BhdGglMjBkJTNEJTIyTTIyNCUyMDBoMzJ2MjU2aC0yNTZ2LTMyaDIyNHYtMjI0eiUyMiUyMGZpbGwlM0QlMjIlMjByZ2IoMCUyQyUyMDAlMkMlMjAwKSUyMiUyRiUzRSUwQSUwOSUwOSUzQ3BhdGglMjBkJTNEJTIyTTMyJTIwMzJoMTYwdjMyaC0xMjh2MTI4aC0zMnYtMTYweiUyMiUyMGZpbGwlM0QlMjIlMjByZ2IoMjIzJTJDJTIwMjIzJTJDJTIwMjIzKSUyMiUyRiUzRSUwQSUwOSUwOSUzQ3BhdGglMjBkJTNEJTIyTTE5MiUyMDMyaDMydjE5MmgtMTkydi0zMmgxNjB2LTE2MHolMjIlMjBmaWxsJTNEJTIyJTIwcmdiKDEyOCUyQyUyMDEyOCUyQyUyMDEyOCklMjIlMkYlM0UlMEElMDklMDklM0NwYXRoJTIwZCUzRCUyMk02NCUyMDY0aDEyOHYxMjhoLTEyOHYtMTI4eiUyMiUyMGZpbGwlM0QlMjIlMjByZ2IoMTkyJTJDJTIwMTkyJTJDJTIwMTkyKSUyMiUyRiUzRSUwQSUwOSUwQSUwOSUwOSUzQyUyRnN2ZyUzRSIpIDY0IC8gMnB4OwoJLS1pbnNldC1kZWVwLWJvcmRlci1pbWFnZTogdXJsKCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIwdmVyc2lvbiUzRCUyMjEuMSUyMiUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIyNTZweCUyMiUyMGhlaWdodCUzRCUyMjI1NnB4JTIyJTIwdmlld0JveCUzRCUyMjAlMjAwJTIwMjU2JTIwMjU2JTIyJTNFJTBBJTA5JTA5JTA5JTBBJTA5JTA5JTNDcGF0aCUyMGQlM0QlMjJNMCUyMDBoMjI0djMyaC0xOTJ2MTkyaC0zMnYtMjI0eiUyMiUyMGZpbGwlM0QlMjIlMjByZ2IoMCUyQyUyMDAlMkMlMjAwKSUyMiUyRiUzRSUwQSUwOSUwOSUzQ3BhdGglMjBkJTNEJTIyTTIyNCUyMDBoMzJ2MjU2aC0yNTZ2LTMyaDIyNHYtMjI0eiUyMiUyMGZpbGwlM0QlMjIlMjByZ2IoMjU1JTJDJTIwMjU1JTJDJTIwMjU1KSUyMiUyRiUzRSUwQSUwOSUwOSUzQ3BhdGglMjBkJTNEJTIyTTMyJTIwMzJoMTYwdjMyaC0xMjh2MTI4aC0zMnYtMTYweiUyMiUyMGZpbGwlM0QlMjIlMjByZ2IoMTI4JTJDJTIwMTI4JTJDJTIwMTI4KSUyMiUyRiUzRSUwQSUwOSUwOSUzQ3BhdGglMjBkJTNEJTIyTTE5MiUyMDMyaDMydjE5MmgtMTkydi0zMmgxNjB2LTE2MHolMjIlMjBmaWxsJTNEJTIyJTIwcmdiKDIyMyUyQyUyMDIyMyUyQyUyMDIyMyklMjIlMkYlM0UlMEElMDklMDklM0NwYXRoJTIwZCUzRCUyMk02NCUyMDY0aDEyOHYxMjhoLTEyOHYtMTI4eiUyMiUyMGZpbGwlM0QlMjIlMjByZ2IoMTkyJTJDJTIwMTkyJTJDJTIwMTkyKSUyMiUyRiUzRSUwQSUwOSUwQSUwOSUwOSUzQyUyRnN2ZyUzRSIpIDY0IC8gMnB4OwoJLS1idXR0b24tZGVmYXVsdC1ib3JkZXItaW1hZ2U6IHVybCgiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHZlcnNpb24lM0QlMjIxLjElMjIlMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMjU2cHglMjIlMjBoZWlnaHQlM0QlMjIyNTZweCUyMiUyMHZpZXdCb3glM0QlMjIwJTIwMCUyMDI1NiUyMDI1NiUyMiUzRSUwQSUwOSUwOSUwOSUwQSUwOSUwOSUzQ3BhdGglMjBkJTNEJTIyTTAlMjAwaDI1NnYyNTZoLTI1NnYtMjU2eiUyMiUyMGZpbGwlM0QlMjIlMjByZ2IoMCUyQyUyMDAlMkMlMjAwKSUyMiUyRiUzRSUwQSUwOSUwOSUzQ3BhdGglMjBkJTNEJTIyTTMyJTIwMzJoMTYwdjMyaC0xMjh2MTI4aC0zMnYtMTYweiUyMiUyMGZpbGwlM0QlMjIlMjByZ2IoMjU1JTJDJTIwMjU1JTJDJTIwMjU1KSUyMiUyRiUzRSUwQSUwOSUwOSUzQ3BhdGglMjBkJTNEJTIyTTY0JTIwNjRoOTZ2MzJoLTY0djY0aC0zMnYtOTZ6JTIyJTIwZmlsbCUzRCUyMiUyMHJnYigyMjMlMkMlMjAyMjMlMkMlMjAyMjMpJTIyJTJGJTNFJTBBJTA5JTA5JTNDcGF0aCUyMGQlM0QlMjJNMTYwJTIwNjRoMzJ2MTI4aC0xMjh2LTMyaDk2di05NnolMjIlMjBmaWxsJTNEJTIyJTIwcmdiKDEyOCUyQyUyMDEyOCUyQyUyMDEyOCklMjIlMkYlM0UlMEElMDklMDklM0NwYXRoJTIwZCUzRCUyMk05NiUyMDk2aDY0djY0aC02NHYtNjR6JTIyJTIwZmlsbCUzRCUyMiUyMHJnYigxOTIlMkMlMjAxOTIlMkMlMjAxOTIpJTIyJTJGJTNFJTBBJTA5JTA5JTNDcmVjdCUyMHglM0QlMjIwJTIyJTIweSUzRCUyMjAlMjIlMjB3aWR0aCUzRCUyMjI1NiUyMiUyMGhlaWdodCUzRCUyMjI1NiUyMiUyMHN0cm9rZS13aWR0aCUzRCUyMjY0JTIyJTIwc3Ryb2tlJTNEJTIyJTIwcmdiKDAlMkMlMjAwJTJDJTIwMCklMjIlMjBmaWxsJTNEJTIybm9uZSUyMiUyRiUzRSUwQSUwOSUwQSUwOSUwOSUzQyUyRnN2ZyUzRSIpIDk2IC8gM3B4OwoJLS1idXR0b24tZGVmYXVsdC1hY3RpdmUtYm9yZGVyLWltYWdlOiB1cmwoImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjI1NnB4JTIyJTIwaGVpZ2h0JTNEJTIyMjU2cHglMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjAyNTYlMjAyNTYlMjIlM0UlMEElMDklMDklMDklMEElMDklMDklM0NwYXRoJTIwZCUzRCUyMk0wJTIwMGgyNTZ2MjU2aC0yNTZ2LTI1NnolMjIlMjBmaWxsJTNEJTIyJTIwcmdiKDAlMkMlMjAwJTJDJTIwMCklMjIlMkYlM0UlMEElMDklMDklM0NwYXRoJTIwZCUzRCUyMk0zMiUyMDMyaDE5MnYxOTJoLTE5MnYtMTkyeiUyMiUyMGZpbGwlM0QlMjIlMjByZ2IoMTI4JTJDJTIwMTI4JTJDJTIwMTI4KSUyMiUyRiUzRSUwQSUwOSUwOSUzQ3BhdGglMjBkJTNEJTIyTTY0JTIwNjRoMTI4djEyOGgtMTI4di0xMjh6JTIyJTIwZmlsbCUzRCUyMiUyMHJnYigxOTIlMkMlMjAxOTIlMkMlMjAxOTIpJTIyJTJGJTNFJTBBJTA5JTA5JTNDcmVjdCUyMHglM0QlMjIwJTIyJTIweSUzRCUyMjAlMjIlMjB3aWR0aCUzRCUyMjI1NiUyMiUyMGhlaWdodCUzRCUyMjI1NiUyMiUyMHN0cm9rZS13aWR0aCUzRCUyMjY0JTIyJTIwc3Ryb2tlJTNEJTIyJTIwcmdiKDAlMkMlMjAwJTJDJTIwMCklMjIlMjBmaWxsJTNEJTIybm9uZSUyMiUyRiUzRSUwQSUwOSUwQSUwOSUwOSUzQyUyRnN2ZyUzRSIpIDY0IC8gMnB4OwoJLS1zY3JvbGxiYXItYXJyb3dzLUJ1dHRvblRleHQ6IHVybCgiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDUUFBQUFKQ0FZQUFBQmFNbzV3QUFBQVcwbEVRVlE0VDJOa0dHU0FjWkM1aDRGV0R2clB3RUMwMlNocWtSMEVra0FIdUJ4TXlFS1lXWVE4aktFT1hRT3lvL0E1QnVad3FxdkJaaUErM3hNYmlsUUxJV3FsY1VKUmltd1B6alJFTGNkUVpBNmhSRWVSNGVSb0JnQm9YaEFLNm9pTWh3QUFBQUJKUlU1RXJrSmdnZz09Iik7CgktLXNjcm9sbGJhci1hcnJvd3MtR3JheVRleHQ6IHVybCgiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDUUFBQUFKQ0FZQUFBQmFNbzV3QUFBQVlFbEVRVlE0VDJOa0dHU0FjWkM1aDRFbURtcG9hUGpmME5CQWxObm9hdUdhUUJMb29ZWExVRUlXd3N3aTVDaHM2bEI4Z2V3b2ZJNkJPWndXYWpDQ0ZaL3ZpUTFGcW9VUXRSSTRvU2hGdGdkbkdxS1dZeWcxaDZpY1FLa2xwT2dIQU05bVFBckV2bTUrQUFBQUFFbEZUa1N1UW1DQyIpOwoJLS1zY3JvbGxiYXItYXJyb3dzLUJ1dHRvbkhpbGlnaHQ6IHVybCgiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDUUFBQUFKQ0FZQUFBQmFNbzV3QUFBQVlFbEVRVlE0VDJOa0dHU0FjWkM1aDRFbUR2ci8vLzkvUmtaR29zeEdWd3ZYQkpKQUR5MWNoaEt5RUdZV0lVZGhVNGZpQzJSSDRYTU16T0cwVUlNUnJQaDhUMndvVWkyRXFKWEFDVVVwc2owNDB4QzFIRU9wT1VUbEJFb3RJVVUvQUtYRlFBcXlUSjZEQUFBQUFFbEZUa1N1UW1DQyIpOwoJLS1zY3JvbGxiYXItc2l6ZTogMTNweDsKCS0tc2Nyb2xsYmFyLWJ1dHRvbi1pbm5lci1zaXplOiA5cHg7CgoJLyogQ29sb3JzICovCgktLUFjdGl2ZUJvcmRlcjogcmdiKDE5MiwgMTkyLCAxOTIpOwoJLS1BY3RpdmVUaXRsZTogcmdiKDAsIDAsIDEyOCk7CgktLUFwcFdvcmtzcGFjZTogcmdiKDEyOCwgMTI4LCAxMjgpOwoJLS1CYWNrZ3JvdW5kOiByZ2IoMCwgMTI4LCAxMjgpOwoJLS1CdXR0b25BbHRlcm5hdGVGYWNlOiByZ2IoMTgwLCAxODAsIDE4MCk7CgktLUJ1dHRvbkRrU2hhZG93OiByZ2IoMCwgMCwgMCk7CgktLUJ1dHRvbkZhY2U6IHJnYigxOTIsIDE5MiwgMTkyKTsKCS0tQnV0dG9uSGlsaWdodDogcmdiKDI1NSwgMjU1LCAyNTUpOwoJLS1CdXR0b25MaWdodDogcmdiKDIyMywgMjIzLCAyMjMpOwoJLS1CdXR0b25TaGFkb3c6IHJnYigxMjgsIDEyOCwgMTI4KTsKCS0tQnV0dG9uVGV4dDogcmdiKDAsIDAsIDApOwoJLS1HcmFkaWVudEFjdGl2ZVRpdGxlOiByZ2IoMTYsIDEzMiwgMjA4KTsKCS0tR3JhZGllbnRJbmFjdGl2ZVRpdGxlOiByZ2IoMTgxLCAxODEsIDE4MSk7CgktLUdyYXlUZXh0OiByZ2IoMTI4LCAxMjgsIDEyOCk7CgktLUhpbGlnaHQ6IHJnYigwLCAwLCAxMjgpOwoJLS1IaWxpZ2h0VGV4dDogcmdiKDI1NSwgMjU1LCAyNTUpOwoJLS1Ib3RUcmFja2luZ0NvbG9yOiByZ2IoMCwgMCwgMjU1KTsKCS0tSW5hY3RpdmVCb3JkZXI6IHJnYigxOTIsIDE5MiwgMTkyKTsKCS0tSW5hY3RpdmVUaXRsZTogcmdiKDEyOCwgMTI4LCAxMjgpOwoJLS1JbmFjdGl2ZVRpdGxlVGV4dDogcmdiKDE5MiwgMTkyLCAxOTIpOwoJLS1JbmZvVGV4dDogcmdiKDAsIDAsIDApOwoJLS1JbmZvV2luZG93OiByZ2IoMjU1LCAyNTUsIDIyNSk7CgktLU1lbnU6IHJnYigxOTIsIDE5MiwgMTkyKTsKCS0tTWVudVRleHQ6IHJnYigwLCAwLCAwKTsKCS0tU2Nyb2xsYmFyOiByZ2IoMTkyLCAxOTIsIDE5Mik7CgktLVRpdGxlVGV4dDogcmdiKDI1NSwgMjU1LCAyNTUpOwoJLS1XaW5kb3c6IHJnYigyNTUsIDI1NSwgMjU1KTsKCS0tV2luZG93RnJhbWU6IHJnYigwLCAwLCAwKTsKCS0tV2luZG93VGV4dDogcmdiKDAsIDAsIDApOwp9CgouaW5zZXQtZGVlcCB7Cglib3JkZXItc3R5bGU6IHNvbGlkOwoJYm9yZGVyLXdpZHRoOiAxcHg7Cglib3JkZXItY29sb3I6IHJnYigxMjgsIDEyOCwgMTI4KSByZ2IoMjU1LCAyNTUsIDI1NSkgcmdiKDI1NSwgMjU1LCAyNTUpIHJnYigxMjgsIDEyOCwgMTI4KTsKCWJvcmRlci1jb2xvcjogdmFyKC0tQnV0dG9uU2hhZG93KSB2YXIoLS1CdXR0b25IaWxpZ2h0KSB2YXIoLS1CdXR0b25IaWxpZ2h0KSB2YXIoLS1CdXR0b25TaGFkb3cpOwoJYmFja2dyb3VuZC1jb2xvcjogcmdiKDE5MiwgMTkyLCAxOTIpOwoJYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tQnV0dG9uRmFjZSk7Cgljb2xvcjogcmdiKDAsIDAsIDApOwoJY29sb3I6IHZhcigtLUJ1dHRvblRleHQpOwoJLyogYXMgZmFsbGJhY2sgKi8KCXBvc2l0aW9uOiByZWxhdGl2ZTsKCS8qIGZvciBwc2V1ZG8gZWxlbWVudChzKSAqLwoJLW8tYm9yZGVyLWltYWdlOiB1cmwoImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjI1NnB4JTIyJTIwaGVpZ2h0JTNEJTIyMjU2cHglMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjAyNTYlMjAyNTYlMjIlM0UlMEElMDklMDklMDklMEElMDklMDklM0NwYXRoJTIwZCUzRCUyMk0wJTIwMGgyMjR2MzJoLTE5MnYxOTJoLTMydi0yMjR6JTIyJTIwZmlsbCUzRCUyMiUyMHJnYigwJTJDJTIwMCUyQyUyMDApJTIyJTJGJTNFJTBBJTA5JTA5JTNDcGF0aCUyMGQlM0QlMjJNMjI0JTIwMGgzMnYyNTZoLTI1NnYtMzJoMjI0di0yMjR6JTIyJTIwZmlsbCUzRCUyMiUyMHJnYigyNTUlMkMlMjAyNTUlMkMlMjAyNTUpJTIyJTJGJTNFJTBBJTA5JTA5JTNDcGF0aCUyMGQlM0QlMjJNMzIlMjAzMmgxNjB2MzJoLTEyOHYxMjhoLTMydi0xNjB6JTIyJTIwZmlsbCUzRCUyMiUyMHJnYigxMjglMkMlMjAxMjglMkMlMjAxMjgpJTIyJTJGJTNFJTBBJTA5JTA5JTNDcGF0aCUyMGQlM0QlMjJNMTkyJTIwMzJoMzJ2MTkyaC0xOTJ2LTMyaDE2MHYtMTYweiUyMiUyMGZpbGwlM0QlMjIlMjByZ2IoMjIzJTJDJTIwMjIzJTJDJTIwMjIzKSUyMiUyRiUzRSUwQSUwOSUwOSUzQ3BhdGglMjBkJTNEJTIyTTY0JTIwNjRoMTI4djEyOGgtMTI4di0xMjh6JTIyJTIwZmlsbCUzRCUyMiUyMHJnYigxOTIlMkMlMjAxOTIlMkMlMjAxOTIpJTIyJTJGJTNFJTBBJTA5JTBBJTA5JTA5JTNDJTJGc3ZnJTNFIikgNjQgLyAycHg7CgkgICBib3JkZXItaW1hZ2U6IHVybCgiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHZlcnNpb24lM0QlMjIxLjElMjIlMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMjU2cHglMjIlMjBoZWlnaHQlM0QlMjIyNTZweCUyMiUyMHZpZXdCb3glM0QlMjIwJTIwMCUyMDI1NiUyMDI1NiUyMiUzRSUwQSUwOSUwOSUwOSUwQSUwOSUwOSUzQ3BhdGglMjBkJTNEJTIyTTAlMjAwaDIyNHYzMmgtMTkydjE5MmgtMzJ2LTIyNHolMjIlMjBmaWxsJTNEJTIyJTIwcmdiKDAlMkMlMjAwJTJDJTIwMCklMjIlMkYlM0UlMEElMDklMDklM0NwYXRoJTIwZCUzRCUyMk0yMjQlMjAwaDMydjI1NmgtMjU2di0zMmgyMjR2LTIyNHolMjIlMjBmaWxsJTNEJTIyJTIwcmdiKDI1NSUyQyUyMDI1NSUyQyUyMDI1NSklMjIlMkYlM0UlMEElMDklMDklM0NwYXRoJTIwZCUzRCUyMk0zMiUyMDMyaDE2MHYzMmgtMTI4djEyOGgtMzJ2LTE2MHolMjIlMjBmaWxsJTNEJTIyJTIwcmdiKDEyOCUyQyUyMDEyOCUyQyUyMDEyOCklMjIlMkYlM0UlMEElMDklMDklM0NwYXRoJTIwZCUzRCUyMk0xOTIlMjAzMmgzMnYxOTJoLTE5MnYtMzJoMTYwdi0xNjB6JTIyJTIwZmlsbCUzRCUyMiUyMHJnYigyMjMlMkMlMjAyMjMlMkMlMjAyMjMpJTIyJTJGJTNFJTBBJTA5JTA5JTNDcGF0aCUyMGQlM0QlMjJNNjQlMjA2NGgxMjh2MTI4aC0xMjh2LTEyOHolMjIlMjBmaWxsJTNEJTIyJTIwcmdiKDE5MiUyQyUyMDE5MiUyQyUyMDE5MiklMjIlMkYlM0UlMEElMDklMEElMDklMDklM0MlMkZzdmclM0UiKSA2NCAvIDJweDsKCS1vLWJvcmRlci1pbWFnZTogdmFyKC0taW5zZXQtZGVlcC1ib3JkZXItaW1hZ2UpOwoJICAgYm9yZGVyLWltYWdlOiB2YXIoLS1pbnNldC1kZWVwLWJvcmRlci1pbWFnZSk7Cglib3JkZXItY29sb3I6IHJnYigxMjgsIDEyOCwgMTI4KTsKCWJvcmRlci1jb2xvcjogdmFyKC0tQnV0dG9uU2hhZG93KTsKCWJvcmRlci1zdHlsZTogc29saWQ7Cglib3JkZXItd2lkdGg6IDJweCAycHg7Cn0KLm91dHNldC1kZWVwIHsKCWJvcmRlci1zdHlsZTogc29saWQ7Cglib3JkZXItd2lkdGg6IDFweDsKCWJvcmRlci1jb2xvcjogcmdiKDI1NSwgMjU1LCAyNTUpIHJnYigxMjgsIDEyOCwgMTI4KSByZ2IoMTI4LCAxMjgsIDEyOCkgcmdiKDI1NSwgMjU1LCAyNTUpOwoJYm9yZGVyLWNvbG9yOiB2YXIoLS1CdXR0b25IaWxpZ2h0KSB2YXIoLS1CdXR0b25TaGFkb3cpIHZhcigtLUJ1dHRvblNoYWRvdykgdmFyKC0tQnV0dG9uSGlsaWdodCk7CgliYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMTkyLCAxOTIsIDE5Mik7CgliYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1CdXR0b25GYWNlKTsKCWNvbG9yOiByZ2IoMCwgMCwgMCk7Cgljb2xvcjogdmFyKC0tQnV0dG9uVGV4dCk7CgkvKiBhcyBmYWxsYmFjayAqLwoJcG9zaXRpb246IHJlbGF0aXZlOwoJLyogZm9yIHBzZXVkbyBlbGVtZW50KHMpICovCgktby1ib3JkZXItaW1hZ2U6IHVybCgiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHZlcnNpb24lM0QlMjIxLjElMjIlMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMjU2cHglMjIlMjBoZWlnaHQlM0QlMjIyNTZweCUyMiUyMHZpZXdCb3glM0QlMjIwJTIwMCUyMDI1NiUyMDI1NiUyMiUzRSUwQSUwOSUwOSUwOSUwQSUwOSUwOSUzQ3BhdGglMjBkJTNEJTIyTTAlMjAwaDIyNHYzMmgtMTkydjE5MmgtMzJ2LTIyNHolMjIlMjBmaWxsJTNEJTIyJTIwcmdiKDI1NSUyQyUyMDI1NSUyQyUyMDI1NSklMjIlMkYlM0UlMEElMDklMDklM0NwYXRoJTIwZCUzRCUyMk0yMjQlMjAwaDMydjI1NmgtMjU2di0zMmgyMjR2LTIyNHolMjIlMjBmaWxsJTNEJTIyJTIwcmdiKDAlMkMlMjAwJTJDJTIwMCklMjIlMkYlM0UlMEElMDklMDklM0NwYXRoJTIwZCUzRCUyMk0zMiUyMDMyaDE2MHYzMmgtMTI4djEyOGgtMzJ2LTE2MHolMjIlMjBmaWxsJTNEJTIyJTIwcmdiKDIyMyUyQyUyMDIyMyUyQyUyMDIyMyklMjIlMkYlM0UlMEElMDklMDklM0NwYXRoJTIwZCUzRCUyMk0xOTIlMjAzMmgzMnYxOTJoLTE5MnYtMzJoMTYwdi0xNjB6JTIyJTIwZmlsbCUzRCUyMiUyMHJnYigxMjglMkMlMjAxMjglMkMlMjAxMjgpJTIyJTJGJTNFJTBBJTA5JTA5JTNDcGF0aCUyMGQlM0QlMjJNNjQlMjA2NGgxMjh2MTI4aC0xMjh2LTEyOHolMjIlMjBmaWxsJTNEJTIyJTIwcmdiKDE5MiUyQyUyMDE5MiUyQyUyMDE5MiklMjIlMkYlM0UlMEElMDklMEElMDklMDklM0MlMkZzdmclM0UiKSA2NCAvIDJweDsKCSAgIGJvcmRlci1pbWFnZTogdXJsKCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIwdmVyc2lvbiUzRCUyMjEuMSUyMiUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIyNTZweCUyMiUyMGhlaWdodCUzRCUyMjI1NnB4JTIyJTIwdmlld0JveCUzRCUyMjAlMjAwJTIwMjU2JTIwMjU2JTIyJTNFJTBBJTA5JTA5JTA5JTBBJTA5JTA5JTNDcGF0aCUyMGQlM0QlMjJNMCUyMDBoMjI0djMyaC0xOTJ2MTkyaC0zMnYtMjI0eiUyMiUyMGZpbGwlM0QlMjIlMjByZ2IoMjU1JTJDJTIwMjU1JTJDJTIwMjU1KSUyMiUyRiUzRSUwQSUwOSUwOSUzQ3BhdGglMjBkJTNEJTIyTTIyNCUyMDBoMzJ2MjU2aC0yNTZ2LTMyaDIyNHYtMjI0eiUyMiUyMGZpbGwlM0QlMjIlMjByZ2IoMCUyQyUyMDAlMkMlMjAwKSUyMiUyRiUzRSUwQSUwOSUwOSUzQ3BhdGglMjBkJTNEJTIyTTMyJTIwMzJoMTYwdjMyaC0xMjh2MTI4aC0zMnYtMTYweiUyMiUyMGZpbGwlM0QlMjIlMjByZ2IoMjIzJTJDJTIwMjIzJTJDJTIwMjIzKSUyMiUyRiUzRSUwQSUwOSUwOSUzQ3BhdGglMjBkJTNEJTIyTTE5MiUyMDMyaDMydjE5MmgtMTkydi0zMmgxNjB2LTE2MHolMjIlMjBmaWxsJTNEJTIyJTIwcmdiKDEyOCUyQyUyMDEyOCUyQyUyMDEyOCklMjIlMkYlM0UlMEElMDklMDklM0NwYXRoJTIwZCUzRCUyMk02NCUyMDY0aDEyOHYxMjhoLTEyOHYtMTI4eiUyMiUyMGZpbGwlM0QlMjIlMjByZ2IoMTkyJTJDJTIwMTkyJTJDJTIwMTkyKSUyMiUyRiUzRSUwQSUwOSUwQSUwOSUwOSUzQyUyRnN2ZyUzRSIpIDY0IC8gMnB4OwoJLW8tYm9yZGVyLWltYWdlOiB2YXIoLS1idXR0b24tbm9ybWFsLWJvcmRlci1pbWFnZSk7CgkgICBib3JkZXItaW1hZ2U6IHZhcigtLWJ1dHRvbi1ub3JtYWwtYm9yZGVyLWltYWdlKTsKCWJvcmRlci1jb2xvcjogcmdiKDIyMywgMjIzLCAyMjMpIHJnYigxMjgsIDEyOCwgMTI4KSByZ2IoMTI4LCAxMjgsIDEyOCkgcmdiKDIyMywgMjIzLCAyMjMpOwoJYm9yZGVyLWNvbG9yOiB2YXIoLS1CdXR0b25MaWdodCkgdmFyKC0tQnV0dG9uU2hhZG93KSB2YXIoLS1CdXR0b25TaGFkb3cpIHZhcigtLUJ1dHRvbkxpZ2h0KTsKCWJvcmRlci1zdHlsZTogc29saWQ7Cglib3JkZXItd2lkdGg6IDJweCAycHg7Cn0KLmluc2V0LXNoYWxsb3cgewoJYm9yZGVyLXN0eWxlOiBzb2xpZDsKCWJvcmRlci13aWR0aDogMXB4OwoJYm9yZGVyLWNvbG9yOiByZ2IoMTI4LCAxMjgsIDEyOCkgcmdiKDI1NSwgMjU1LCAyNTUpIHJnYigyNTUsIDI1NSwgMjU1KSByZ2IoMTI4LCAxMjgsIDEyOCk7Cglib3JkZXItY29sb3I6IHZhcigtLUJ1dHRvblNoYWRvdykgdmFyKC0tQnV0dG9uSGlsaWdodCkgdmFyKC0tQnV0dG9uSGlsaWdodCkgdmFyKC0tQnV0dG9uU2hhZG93KTsKCWJhY2tncm91bmQtY29sb3I6IHJnYigxOTIsIDE5MiwgMTkyKTsKCWJhY2tncm91bmQtY29sb3I6IHZhcigtLUJ1dHRvbkZhY2UpOwoJY29sb3I6IHJnYigwLCAwLCAwKTsKCWNvbG9yOiB2YXIoLS1CdXR0b25UZXh0KTsKfQoub3V0c2V0LXNoYWxsb3cgewoJYm9yZGVyLXN0eWxlOiBzb2xpZDsKCWJvcmRlci13aWR0aDogMXB4OwoJYm9yZGVyLWNvbG9yOiByZ2IoMjU1LCAyNTUsIDI1NSkgcmdiKDEyOCwgMTI4LCAxMjgpIHJnYigxMjgsIDEyOCwgMTI4KSByZ2IoMjU1LCAyNTUsIDI1NSk7Cglib3JkZXItY29sb3I6IHZhcigtLUJ1dHRvbkhpbGlnaHQpIHZhcigtLUJ1dHRvblNoYWRvdykgdmFyKC0tQnV0dG9uU2hhZG93KSB2YXIoLS1CdXR0b25IaWxpZ2h0KTsKCWJhY2tncm91bmQtY29sb3I6IHJnYigxOTIsIDE5MiwgMTkyKTsKCWJhY2tncm91bmQtY29sb3I6IHZhcigtLUJ1dHRvbkZhY2UpOwoJY29sb3I6IHJnYigwLCAwLCAwKTsKCWNvbG9yOiB2YXIoLS1CdXR0b25UZXh0KTsKfQoKLm9zLXdpbmRvdyAud2luZG93LXRpdGxlYmFyLApib2R5ID4gLndpbmRvdy10aXRsZWJhciB7CgliYWNrZ3JvdW5kOiByZ2IoMCwgMCwgMTI4KTsKCWJhY2tncm91bmQ6IHZhcigtLUFjdGl2ZVRpdGxlKTsKCWJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgcmdiKDAsIDAsIDEyOCkgMCUsIHJnYigxNiwgMTMyLCAyMDgpIDEwMCUpOwoJYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCB2YXIoLS1BY3RpdmVUaXRsZSkgMCUsIHZhcigtLUdyYWRpZW50QWN0aXZlVGl0bGUpIDEwMCUpOwoJCgljb2xvcjogcmdiKDI1NSwgMjU1LCAyNTUpOwoJCgljb2xvcjogdmFyKC0tVGl0bGVUZXh0KTsKfQoKLm9zLXdpbmRvdyAud2luZG93LXRpdGxlYmFyLCBib2R5ID4gLndpbmRvdy10aXRsZWJhciB7Cglmb250LWZhbWlseTogJ1NlZ29lIFVJJywgc2Fucy1zZXJpZjsKCWZvbnQtc2l6ZTogMTJweDsKfQoKLm9zLXdpbmRvdyAud2luZG93LXRpdGxlYmFyLApib2R5ID4gLndpbmRvdy10aXRsZWJhciB7Cglmb250LXdlaWdodDogYm9sZDsKfQoub3Mtd2luZG93Om5vdCguZm9jdXNlZCkgLndpbmRvdy10aXRsZWJhciB7CgliYWNrZ3JvdW5kOiBkYXJrZ3JheTsKCWJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgcmdiKDEyOCwgMTI4LCAxMjgpIDAlLCByZ2IoMTgxLCAxODEsIDE4MSkgMTAwJSk7CgliYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsIHZhcigtLUluYWN0aXZlVGl0bGUpIDAlLCB2YXIoLS1HcmFkaWVudEluYWN0aXZlVGl0bGUpIDEwMCUpOwoKCWNvbG9yOiByZ2IoMTkyLCAxOTIsIDE5Mik7CgoJY29sb3I6IHZhcigtLUluYWN0aXZlVGl0bGVUZXh0KTsKfQoub3Mtd2luZG93IHsKCS8qIE5lZWRlZCBmb3Igd2hlbiBtYXhpbWl6ZWQsIG90aGVyd2lzZSB3b3VsZCBiZSBwcm92aWRlZCBieSAlb3V0c2V0LWRlZXAgKi8KCWJhY2tncm91bmQ6IHJnYigxOTIsIDE5MiwgMTkyKTsKCWJhY2tncm91bmQ6IHZhcigtLUJ1dHRvbkZhY2UpOwoKCS8qIGJhY2tncm91bmQ6IHZhcigtLVdpbmRvdyk7ICovCgkvKmNvbG9yOiB2YXIoLS1XaW5kb3dUZXh0KTsqLwoJLypib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1XaW5kb3dGcmFtZSk7Ki8KCS8qIFRPRE86IHVzZSB3aW5kb3ctc3BlY2lmaWMgdGhlbWUgY29sb3JzOyBhbHNvIGRpZmZlcmVudCB0eXBlcyBvZiB3aW5kb3dzICovCgkvKiBwYWRkaW5nOiAycHg7ICovCn0KLm9zLXdpbmRvdzpub3QoLm1heGltaXplZCkgewoJYm9yZGVyLXN0eWxlOiBzb2xpZDsKCWJvcmRlci13aWR0aDogMXB4OwoJYm9yZGVyLWNvbG9yOiByZ2IoMjU1LCAyNTUsIDI1NSkgcmdiKDEyOCwgMTI4LCAxMjgpIHJnYigxMjgsIDEyOCwgMTI4KSByZ2IoMjU1LCAyNTUsIDI1NSk7Cglib3JkZXItY29sb3I6IHZhcigtLUJ1dHRvbkhpbGlnaHQpIHZhcigtLUJ1dHRvblNoYWRvdykgdmFyKC0tQnV0dG9uU2hhZG93KSB2YXIoLS1CdXR0b25IaWxpZ2h0KTsKCWJhY2tncm91bmQtY29sb3I6IHJnYigxOTIsIDE5MiwgMTkyKTsKCWJhY2tncm91bmQtY29sb3I6IHZhcigtLUJ1dHRvbkZhY2UpOwoJY29sb3I6IHJnYigwLCAwLCAwKTsKCWNvbG9yOiB2YXIoLS1CdXR0b25UZXh0KTsKCS8qIGFzIGZhbGxiYWNrICovCglwb3NpdGlvbjogcmVsYXRpdmU7CgkvKiBmb3IgcHNldWRvIGVsZW1lbnQocykgKi8KCS1vLWJvcmRlci1pbWFnZTogdXJsKCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIwdmVyc2lvbiUzRCUyMjEuMSUyMiUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIyNTZweCUyMiUyMGhlaWdodCUzRCUyMjI1NnB4JTIyJTIwdmlld0JveCUzRCUyMjAlMjAwJTIwMjU2JTIwMjU2JTIyJTNFJTBBJTA5JTA5JTA5JTBBJTA5JTA5JTNDcGF0aCUyMGQlM0QlMjJNMCUyMDBoMjI0djMyaC0xOTJ2MTkyaC0zMnYtMjI0eiUyMiUyMGZpbGwlM0QlMjIlMjByZ2IoMjU1JTJDJTIwMjU1JTJDJTIwMjU1KSUyMiUyRiUzRSUwQSUwOSUwOSUzQ3BhdGglMjBkJTNEJTIyTTIyNCUyMDBoMzJ2MjU2aC0yNTZ2LTMyaDIyNHYtMjI0eiUyMiUyMGZpbGwlM0QlMjIlMjByZ2IoMCUyQyUyMDAlMkMlMjAwKSUyMiUyRiUzRSUwQSUwOSUwOSUzQ3BhdGglMjBkJTNEJTIyTTMyJTIwMzJoMTYwdjMyaC0xMjh2MTI4aC0zMnYtMTYweiUyMiUyMGZpbGwlM0QlMjIlMjByZ2IoMjIzJTJDJTIwMjIzJTJDJTIwMjIzKSUyMiUyRiUzRSUwQSUwOSUwOSUzQ3BhdGglMjBkJTNEJTIyTTE5MiUyMDMyaDMydjE5MmgtMTkydi0zMmgxNjB2LTE2MHolMjIlMjBmaWxsJTNEJTIyJTIwcmdiKDEyOCUyQyUyMDEyOCUyQyUyMDEyOCklMjIlMkYlM0UlMEElMDklMDklM0NwYXRoJTIwZCUzRCUyMk02NCUyMDY0aDEyOHYxMjhoLTEyOHYtMTI4eiUyMiUyMGZpbGwlM0QlMjIlMjByZ2IoMTkyJTJDJTIwMTkyJTJDJTIwMTkyKSUyMiUyRiUzRSUwQSUwOSUwQSUwOSUwOSUzQyUyRnN2ZyUzRSIpIDY0IC8gMnB4OwoJICAgYm9yZGVyLWltYWdlOiB1cmwoImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjI1NnB4JTIyJTIwaGVpZ2h0JTNEJTIyMjU2cHglMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjAyNTYlMjAyNTYlMjIlM0UlMEElMDklMDklMDklMEElMDklMDklM0NwYXRoJTIwZCUzRCUyMk0wJTIwMGgyMjR2MzJoLTE5MnYxOTJoLTMydi0yMjR6JTIyJTIwZmlsbCUzRCUyMiUyMHJnYigyNTUlMkMlMjAyNTUlMkMlMjAyNTUpJTIyJTJGJTNFJTBBJTA5JTA5JTNDcGF0aCUyMGQlM0QlMjJNMjI0JTIwMGgzMnYyNTZoLTI1NnYtMzJoMjI0di0yMjR6JTIyJTIwZmlsbCUzRCUyMiUyMHJnYigwJTJDJTIwMCUyQyUyMDApJTIyJTJGJTNFJTBBJTA5JTA5JTNDcGF0aCUyMGQlM0QlMjJNMzIlMjAzMmgxNjB2MzJoLTEyOHYxMjhoLTMydi0xNjB6JTIyJTIwZmlsbCUzRCUyMiUyMHJnYigyMjMlMkMlMjAyMjMlMkMlMjAyMjMpJTIyJTJGJTNFJTBBJTA5JTA5JTNDcGF0aCUyMGQlM0QlMjJNMTkyJTIwMzJoMzJ2MTkyaC0xOTJ2LTMyaDE2MHYtMTYweiUyMiUyMGZpbGwlM0QlMjIlMjByZ2IoMTI4JTJDJTIwMTI4JTJDJTIwMTI4KSUyMiUyRiUzRSUwQSUwOSUwOSUzQ3BhdGglMjBkJTNEJTIyTTY0JTIwNjRoMTI4djEyOGgtMTI4di0xMjh6JTIyJTIwZmlsbCUzRCUyMiUyMHJnYigxOTIlMkMlMjAxOTIlMkMlMjAxOTIpJTIyJTJGJTNFJTBBJTA5JTBBJTA5JTA5JTNDJTJGc3ZnJTNFIikgNjQgLyAycHg7Cgktby1ib3JkZXItaW1hZ2U6IHZhcigtLWJ1dHRvbi1ub3JtYWwtYm9yZGVyLWltYWdlKTsKCSAgIGJvcmRlci1pbWFnZTogdmFyKC0tYnV0dG9uLW5vcm1hbC1ib3JkZXItaW1hZ2UpOwoJYm9yZGVyLWNvbG9yOiByZ2IoMjIzLCAyMjMsIDIyMykgcmdiKDEyOCwgMTI4LCAxMjgpIHJnYigxMjgsIDEyOCwgMTI4KSByZ2IoMjIzLCAyMjMsIDIyMyk7Cglib3JkZXItY29sb3I6IHZhcigtLUJ1dHRvbkxpZ2h0KSB2YXIoLS1CdXR0b25TaGFkb3cpIHZhcigtLUJ1dHRvblNoYWRvdykgdmFyKC0tQnV0dG9uTGlnaHQpOwoJYm9yZGVyLXN0eWxlOiBzb2xpZDsKCWJvcmRlci13aWR0aDogMnB4IDJweDsKfQoub3Mtd2luZG93ID4gKiB7CgkvKiBtYXJnaW46IDFweDsgKi8KfQoud2luZG93LWJ1dHRvbiB7CgltYXJnaW46IDJweCAwOwp9Ci53aW5kb3ctY2xvc2UtYnV0dG9uIHsKCW1hcmdpbi1sZWZ0OiAycHg7CgltYXJnaW4tcmlnaHQ6IDJweDsKfQoub3Mtd2luZG93IC53aW5kb3ctdGl0bGUtYXJlYSB7CgloZWlnaHQ6IDE2cHg7IC8qIDEwMCUgZG9lc24ndCB3b3JrICovCn0KLm9zLXdpbmRvdyAud2luZG93LXRpdGxlIHsKCXBvc2l0aW9uOiBhYnNvbHV0ZTsKCWxlZnQ6IDA7Cgl0b3A6IDA7CglyaWdodDogMDsKCWJvdHRvbTogMDsKCWRpc3BsYXk6IGlubGluZS1ibG9jayAhaW1wb3J0YW50OwoJbWFyZ2luOiAwOwoJcGFkZGluZzogMDsKCW92ZXJmbG93OiBoaWRkZW47Cgl0ZXh0LW92ZXJmbG93OiBlbGxpcHNpczsKCXdoaXRlLXNwYWNlOiBub3dyYXA7CglwYWRkaW5nLWxlZnQ6IDJweDsKfQoud2luZG93LWNsb3NlLWJ1dHRvbiB7CgkvKiBkaXNwbGF5OiBibG9jayAhaW1wb3J0YW50OyAqLwoJLyogZmxvYXQ6IHJpZ2h0OyAqLwoJLyogd2lkdGg6IDEzcHg7CgloZWlnaHQ6IDExcHg7ICovCn0KLndpbmRvdy1jbG9zZS1idXR0b24sCi53aW5kb3ctbWF4aW1pemUtYnV0dG9uLAoud2luZG93LW1pbmltaXplLWJ1dHRvbiB7CgliYWNrZ3JvdW5kLWltYWdlOiB1cmwoImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBRHdBQUFBS0NBWUFBQURvM3ozQ0FBQUFvVWxFUVZSSVM5VlZXdzdBSUFpYjl6LzBGcFpnQ09GUmdwbHVmOU1DbGhZZFYrKzdnZkRoWUx4WUR3K1V5aUhkNUY4UzVscjZ6TmE2WHB2L0t3aEhPYWhRcExCMStDd2Z5Y2dZcndtRTBXSzhNVHNJUjFhT0dzUitOWWtrWXpONS9wR3dWQTl4QS9kaXE4TGVIQ0t1UXhRK2FvWXQyeUpXdHBTTlp0aDBlZFJwR1ZDNWVHUWNTZzRoWExtbDNmZHBCZUhzOGV2V3lQS1g5cnVYVnFuWUNlQUhBOEl5QzlLMmtta0FBQUFBU1VWT1JLNUNZSUk9Iik7CgktbXMtaW50ZXJwb2xhdGlvbi1tb2RlOiBuZWFyZXN0LW5laWdoYm9yOwoJICAgIGltYWdlLXJlbmRlcmluZzogLW1vei1jcmlzcC1lZGdlczsKCSAgICBpbWFnZS1yZW5kZXJpbmc6IHBpeGVsYXRlZDsKCWRpc3BsYXk6IGJsb2NrOwoJd2lkdGg6IDE2cHg7CgloZWlnaHQ6IDE0cHg7CglwYWRkaW5nOiAwOwp9Cgoud2luZG93LWNsb3NlLWJ1dHRvbiB7CgliYWNrZ3JvdW5kLXBvc2l0aW9uOiBjYWxjKC0zICogMTNweCAtIDFweCkgMHB4Owp9Ci53aW5kb3ctbWF4aW1pemUtYnV0dG9uIHsKCWJhY2tncm91bmQtcG9zaXRpb246IGNhbGMoLTEgKiAxM3B4IC0gMXB4KSAwcHg7Cn0KLm1heGltaXplZCAud2luZG93LW1heGltaXplLWJ1dHRvbiB7CgliYWNrZ3JvdW5kLXBvc2l0aW9uOiBjYWxjKC0yICogMTNweCAtIDFweCkgMHB4Owp9Ci53aW5kb3ctbWluaW1pemUtYnV0dG9uIHsKCWJhY2tncm91bmQtcG9zaXRpb246IGNhbGMoLTAgKiAxM3B4IC0gMXB4KSAwcHg7Cn0KCi53aW5kb3ctY2xvc2UtYnV0dG9uOmhvdmVyOmFjdGl2ZSB7CgliYWNrZ3JvdW5kLXBvc2l0aW9uOiBjYWxjKC0zICogMTNweCAtIDBweCkgMXB4Owp9Ci53aW5kb3ctbWF4aW1pemUtYnV0dG9uOmhvdmVyOmFjdGl2ZSB7CgliYWNrZ3JvdW5kLXBvc2l0aW9uOiBjYWxjKC0xICogMTNweCAtIDBweCkgMXB4Owp9Ci5tYXhpbWl6ZWQgLndpbmRvdy1tYXhpbWl6ZS1idXR0b246aG92ZXI6YWN0aXZlIHsKCWJhY2tncm91bmQtcG9zaXRpb246IGNhbGMoLTIgKiAxM3B4IC0gMHB4KSAxcHg7Cn0KLndpbmRvdy1taW5pbWl6ZS1idXR0b246aG92ZXI6YWN0aXZlIHsKCWJhY2tncm91bmQtcG9zaXRpb246IGNhbGMoLTAgKiAxM3B4IC0gMHB4KSAxcHg7Cn0KCgoubWVudXMgewoJYmFja2dyb3VuZDogI2VjZTlkODsKCS8qYmFja2dyb3VuZDogdmFyKC0tTWVudSk7Ki8KCWNvbG9yOiByZ2IoMCwgMCwgMCk7Cgljb2xvcjogdmFyKC0tTWVudVRleHQpOwp9Ci5vcy13aW5kb3c6bm90KC5mb2N1c2VkKSAubWVudXMgewoJY29sb3I6IHJnYigxMjgsIDEyOCwgMTI4KTsKCWNvbG9yOiB2YXIoLS1HcmF5VGV4dCk7Cn0KLm1lbnVzICosIC5tZW51LXBvcHVwICogewoJZm9udC1mYW1pbHk6ICdTZWdvZSBVSScsIHNhbnMtc2VyaWY7Cglmb250LXNpemU6IDEycHg7Cn0KLm1lbnUtY29udGFpbmVyIHsKCW1hcmdpbi1ib3R0b206IDFweDsKfQoubWVudS1idXR0b24gewoJYm94LXNpemluZzogYm9yZGVyLWJveDsKCWhlaWdodDogMThweDsKCWxpbmUtaGVpZ2h0OiAxOwoJbWFyZ2luLXRvcDogMXB4OwoJbWFyZ2luLWJvdHRvbTogMXB4OwoJcGFkZGluZzogMnB4IDVweDsKCXBvc2l0aW9uOiByZWxhdGl2ZTsKCW91dGxpbmU6IDA7CgkvKiBAZXh0ZW5kIGJ1dHRvbi5saWdodHdlaWdodDsgKi8KCWJhY2tncm91bmQ6ICNlY2U5ZDg7CgkvKmJhY2tncm91bmQ6IHZhcigtLU1lbnUpOyovCn0KLyoKLm1lbnUtYnV0dG9uOmhvdmVyIHsKCWJveC1zaGFkb3c6IDFweCAxcHggMCByZ2IoMjU1LCAyNTUsIDI1NSkgaW5zZXQsIC0xcHggLTFweCAwIHJnYigxMjgsIDEyOCwgMTI4KSBpbnNldDsKCWJveC1zaGFkb3c6IDFweCAxcHggMCB2YXIoLS1CdXR0b25IaWxpZ2h0KSBpbnNldCwgLTFweCAtMXB4IDAgdmFyKC0tQnV0dG9uU2hhZG93KSBpbnNldDsKfQoubWVudS1idXR0b246YWN0aXZlLAoubWVudS1idXR0b24uYWN0aXZlIHsKCWJveC1zaGFkb3c6IDFweCAxcHggMCByZ2IoMTI4LCAxMjgsIDEyOCkgaW5zZXQsIC0xcHggLTFweCAwIHJnYigyNTUsIDI1NSwgMjU1KSBpbnNldDsKCWJveC1zaGFkb3c6IDFweCAxcHggMCB2YXIoLS1CdXR0b25TaGFkb3cpIGluc2V0LCAtMXB4IC0xcHggMCB2YXIoLS1CdXR0b25IaWxpZ2h0KSBpbnNldDsKCXRvcDogMXB4OwoJbGVmdDogMXB4Owp9CiovCgoKLm1lbnUtcG9wdXAgewoJZGlzcGxheTogYmxvY2s7CglwYWRkaW5nOiAycHg7CgliYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMTkyLCAxOTIsIDE5Mik7CgliYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1CdXR0b25GYWNlKTsKCWJvcmRlci10b3A6IDFweCBzb2xpZCByZ2IoMTkyLCAxOTIsIDE5Mik7Cglib3JkZXItdG9wOiAxcHggc29saWQgdmFyKC0tQnV0dG9uRmFjZSk7Cglib3JkZXItbGVmdDogMXB4IHNvbGlkIHJnYigxOTIsIDE5MiwgMTkyKTsKCWJvcmRlci1sZWZ0OiAxcHggc29saWQgdmFyKC0tQnV0dG9uRmFjZSk7Cglib3JkZXItcmlnaHQ6IDFweCBzb2xpZCByZ2IoMCwgMCwgMCk7Cglib3JkZXItcmlnaHQ6IDFweCBzb2xpZCB2YXIoLS1CdXR0b25Ea1NoYWRvdyk7Cglib3JkZXItYm90dG9tOiAxcHggc29saWQgcmdiKDAsIDAsIDApOwoJYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHZhcigtLUJ1dHRvbkRrU2hhZG93KTsKCS8qYm94LXNoYWRvdzogMXB4IDFweCAwIHJnYigyNTUsIDI1NSwgMjU1KSBpbnNldCwgLTFweCAtMXB4IDAgcmdiKDEyOCwgMTI4LCAxMjgpIGluc2V0OwoJYm94LXNoYWRvdzogMXB4IDFweCAwIHZhcigtLUJ1dHRvbkhpbGlnaHQpIGluc2V0LCAtMXB4IC0xcHggMCB2YXIoLS1CdXR0b25TaGFkb3cpIGluc2V0OyovCgliYWNrZ3JvdW5kOiByZ2IoMTkyLCAxOTIsIDE5Mik7CgliYWNrZ3JvdW5kOiB2YXIoLS1NZW51KTsKCWNvbG9yOiByZ2IoMCwgMCwgMCk7Cgljb2xvcjogdmFyKC0tTWVudVRleHQpOwp9Ci8qCi5tZW51LWl0ZW0gewoJcGFkZGluZzogMXB4IDNweDsKCW1hcmdpbjogMnB4Owp9Ci5tZW51LWl0ZW1bZGlzYWJsZWRdIHsKCWNvbG9yOiByZ2IoMTI4LCAxMjgsIDEyOCk7Cgljb2xvcjogdmFyKC0tR3JheVRleHQpOwoJdGV4dC1zaGFkb3c6IDAuOHB4IDAuOHB4IDBweCByZ2IoMjU1LCAyNTUsIDI1NSk7Cgl0ZXh0LXNoYWRvdzogMC44cHggMC44cHggMHB4IHZhcigtLUJ1dHRvbkhpbGlnaHQpOwp9Ci5tZW51LWl0ZW06Zm9jdXMsCi5tZW51LWl0ZW0uYWN0aXZlIHsKCWJhY2tncm91bmQ6IHJnYigwLCAwLCAxMjgpOwoJYmFja2dyb3VuZDogdmFyKC0tSGlsaWdodCk7Cgljb2xvcjogcmdiKDI1NSwgMjU1LCAyNTUpOwoJY29sb3I6IHZhcigtLUhpbGlnaHRUZXh0KTsKCXRleHQtc2hhZG93OiBub25lOwoJb3V0bGluZTogMDsKfQoqLwoubWVudS1pdGVtIC5tZW51LWl0ZW0tc2hvcnRjdXQgewoJcGFkZGluZy1sZWZ0OiAxMHB4Owp9Ci5tZW51LWhyIHsKCWJvcmRlcjogMDsKCWJvcmRlci10b3A6IDFweCBzb2xpZCByZ2IoMTI4LCAxMjgsIDEyOCk7Cglib3JkZXItdG9wOiAxcHggc29saWQgdmFyKC0tQnV0dG9uU2hhZG93KTsKCWJvcmRlci1ib3R0b206IDFweCBzb2xpZCByZ2IoMjU1LCAyNTUsIDI1NSk7Cglib3JkZXItYm90dG9tOiAxcHggc29saWQgdmFyKC0tQnV0dG9uSGlsaWdodCk7CgltYXJnaW46IDBweCAycHg7Cn0KLm1lbnUtaG90a2V5IHsKCXRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lOwp9CgoKOjotbW96LXNlbGVjdGlvbiB7CgliYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMCwgMCwgMTI4KTsKCWJhY2tncm91bmQtY29sb3I6IHZhcigtLUhpbGlnaHQpOwoJY29sb3I6IHJnYigyNTUsIDI1NSwgMjU1KTsKCWNvbG9yOiB2YXIoLS1IaWxpZ2h0VGV4dCk7Cn0KCgouc2Nyb2xsYmFyIHsKCWJhY2tncm91bmQ6IHVybCgiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBSUFBQUFDQ0FZQUFBQnl0ZzBrQUFBQUcwbEVRVlFZVjJQOC8vLy8vNE1IRHpJd0hqaHc0TCs5dlQwREFIQUZDajZlc3EzRkFBQUFBRWxGVGtTdVFtQ0MiKSByZXBlYXQ7CgliYWNrZ3JvdW5kOiB2YXIoLS1jaGVja2VyKSByZXBlYXQ7CgktbXMtaW50ZXJwb2xhdGlvbi1tb2RlOiBuZWFyZXN0LW5laWdoYm9yOwoJICAgIGltYWdlLXJlbmRlcmluZzogLW1vei1jcmlzcC1lZGdlczsKCSAgICBpbWFnZS1yZW5kZXJpbmc6IHBpeGVsYXRlZDsKfQouc2Nyb2xsYmFyLXRodW1iIHsKCWJhY2tncm91bmQtY29sb3I6IHJnYigxOTIsIDE5MiwgMTkyKTsKCWJhY2tncm91bmQtY29sb3I6IHZhcigtLUJ1dHRvbkZhY2UpOwoJYm9yZGVyLXRvcDogMXB4IHNvbGlkIHJnYigxOTIsIDE5MiwgMTkyKTsKCWJvcmRlci10b3A6IDFweCBzb2xpZCB2YXIoLS1CdXR0b25GYWNlKTsKCWJvcmRlci1sZWZ0OiAxcHggc29saWQgcmdiKDE5MiwgMTkyLCAxOTIpOwoJYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCB2YXIoLS1CdXR0b25GYWNlKTsKCWJvcmRlci1yaWdodDogMXB4IHNvbGlkIHJnYigwLCAwLCAwKTsKCWJvcmRlci1yaWdodDogMXB4IHNvbGlkIHZhcigtLUJ1dHRvbkRrU2hhZG93KTsKCWJvcmRlci1ib3R0b206IDFweCBzb2xpZCByZ2IoMCwgMCwgMCk7Cglib3JkZXItYm90dG9tOiAxcHggc29saWQgdmFyKC0tQnV0dG9uRGtTaGFkb3cpOwoJYm94LXNoYWRvdzogMXB4IDFweCAwIHJnYigyNTUsIDI1NSwgMjU1KSBpbnNldCwgLTFweCAtMXB4IDAgcmdiKDEyOCwgMTI4LCAxMjgpIGluc2V0OwoJYm94LXNoYWRvdzogMXB4IDFweCAwIHZhcigtLUJ1dHRvbkhpbGlnaHQpIGluc2V0LCAtMXB4IC0xcHggMCB2YXIoLS1CdXR0b25TaGFkb3cpIGluc2V0Owp9Ci5zY3JvbGxiYXItdHJhY2stcGllY2U6aG92ZXI6YWN0aXZlIHsKCWJhY2tncm91bmQ6IHVybCgiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBSUFBQUFDQ0FZQUFBQnl0ZzBrQUFBQUcwbEVRVlFZVjJQOC8vLy8vNE1IRHpJd0hqaHc0TCs5dlQwREFIQUZDajZlc3EzRkFBQUFBRWxGVGtTdVFtQ0MiKSByZXBlYXQ7CgliYWNrZ3JvdW5kOiB2YXIoLS1jaGVja2VyKSByZXBlYXQ7CgktbXMtaW50ZXJwb2xhdGlvbi1tb2RlOiBuZWFyZXN0LW5laWdoYm9yOwoJICAgIGltYWdlLXJlbmRlcmluZzogLW1vei1jcmlzcC1lZGdlczsKCSAgICBpbWFnZS1yZW5kZXJpbmc6IHBpeGVsYXRlZDsKCWJhY2tncm91bmQtY29sb3I6IHdoaXRlOwoJYmFja2dyb3VuZC1ibGVuZC1tb2RlOiBkaWZmZXJlbmNlOwoJLyogYmFja2dyb3VuZC1hdHRhY2htZW50OiBmaXhlZDsgYnJlYWtzIHRoZSBjaGVja2VyZWQgYmFja2dyb3VuZCBpbiBjaHJvbWUgKi8KfQouc2Nyb2xsYmFyLXRyYWNrLXBpZWNlLmluY3JlbWVudCB7CgliYWNrZ3JvdW5kLXBvc2l0aW9uOiBib3R0b207Cn0KLnNjcm9sbGJhci1jb3JuZXIgewoJYmFja2dyb3VuZC1jb2xvcjogcmdiKDE5MiwgMTkyLCAxOTIpOwoJYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tQnV0dG9uRmFjZSk7Cn0KCi5zY3JvbGxiYXItYnV0dG9uIHsKCWJhY2tncm91bmQtY29sb3I6IHJnYigxOTIsIDE5MiwgMTkyKTsKCWJhY2tncm91bmQtY29sb3I6IHZhcigtLUJ1dHRvbkZhY2UpOwoJYm9yZGVyLXRvcDogMXB4IHNvbGlkIHJnYigxOTIsIDE5MiwgMTkyKTsKCWJvcmRlci10b3A6IDFweCBzb2xpZCB2YXIoLS1CdXR0b25GYWNlKTsKCWJvcmRlci1sZWZ0OiAxcHggc29saWQgcmdiKDE5MiwgMTkyLCAxOTIpOwoJYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCB2YXIoLS1CdXR0b25GYWNlKTsKCWJvcmRlci1yaWdodDogMXB4IHNvbGlkIHJnYigwLCAwLCAwKTsKCWJvcmRlci1yaWdodDogMXB4IHNvbGlkIHZhcigtLUJ1dHRvbkRrU2hhZG93KTsKCWJvcmRlci1ib3R0b206IDFweCBzb2xpZCByZ2IoMCwgMCwgMCk7Cglib3JkZXItYm90dG9tOiAxcHggc29saWQgdmFyKC0tQnV0dG9uRGtTaGFkb3cpOwoJYm94LXNoYWRvdzogMXB4IDFweCAwIHJnYigyNTUsIDI1NSwgMjU1KSBpbnNldCwgLTFweCAtMXB4IDAgcmdiKDEyOCwgMTI4LCAxMjgpIGluc2V0OwoJYm94LXNoYWRvdzogMXB4IDFweCAwIHZhcigtLUJ1dHRvbkhpbGlnaHQpIGluc2V0LCAtMXB4IC0xcHggMCB2YXIoLS1CdXR0b25TaGFkb3cpIGluc2V0OwoJYmFja2dyb3VuZC1pbWFnZTogdXJsKCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNRQUFBQUpDQVlBQUFCYU1vNXdBQUFBVzBsRVFWUTRUMk5rR0dTQWNaQzVoNEZXRHZyUHdFQzAyU2hxa1IwRWtrQUh1QnhNeUVLWVdZUThqS0VPWFFPeW8vQTVCdVp3cXF2QlppQSszeE1iaWxRTElXcWxjVUpSaW13UHpqUkVMY2RRWkE2aFJFZVI0ZVJvQmdCb1hoQUs2b2lNaHdBQUFBQkpSVTVFcmtKZ2dnPT0iKTsKCWJhY2tncm91bmQtaW1hZ2U6IHZhcigtLXNjcm9sbGJhci1hcnJvd3MtQnV0dG9uVGV4dCk7CgktbXMtaW50ZXJwb2xhdGlvbi1tb2RlOiBuZWFyZXN0LW5laWdoYm9yOwoJICAgIGltYWdlLXJlbmRlcmluZzogLW1vei1jcmlzcC1lZGdlczsKCSAgICBpbWFnZS1yZW5kZXJpbmc6IHBpeGVsYXRlZDsKCXdpZHRoOiAxM3B4OwoJd2lkdGg6IHZhcigtLXNjcm9sbGJhci1zaXplKTsKCWhlaWdodDogMTNweDsKCWhlaWdodDogdmFyKC0tc2Nyb2xsYmFyLXNpemUpOwoJYm94LXNpemluZzogYm9yZGVyLWJveDsKfQouc2Nyb2xsYmFyLWJ1dHRvbjpub3QoLmRpc2FibGVkKTpob3ZlcjphY3RpdmUgewoJYm9yZGVyOiAxcHggc29saWQgcmdiKDEyOCwgMTI4LCAxMjgpOwoJYm9yZGVyOiAxcHggc29saWQgdmFyKC0tQnV0dG9uU2hhZG93KTsKCWJveC1zaGFkb3c6IG5vbmU7Cn0KLnNjcm9sbGJhci1idXR0b24uZGlzYWJsZWQgewoJYmFja2dyb3VuZC1pbWFnZTogdXJsKCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNRQUFBQUpDQVlBQUFCYU1vNXdBQUFBWUVsRVFWUTRUMk5rR0dTQWNaQzVoNEVtRG1wb2FQamYwTkJBbE5ub2F1R2FRQkxvb1lYTFVFSVd3c3dpNUNoczZsQjhnZXdvZkk2Qk9ad1dhakNDRlovdmlRMUZxb1VRdFJJNG9TaEZ0Z2RuR3FLV1l5ZzFoNmljUUtrbHBPZ0hBTTltUUFyRXZtNStBQUFBQUVsRlRrU3VRbUNDIiksIHVybCgiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDUUFBQUFKQ0FZQUFBQmFNbzV3QUFBQVlFbEVRVlE0VDJOa0dHU0FjWkM1aDRFbUR2ci8vLzkvUmtaR29zeEdWd3ZYQkpKQUR5MWNoaEt5RUdZV0lVZGhVNGZpQzJSSDRYTU16T0cwVUlNUnJQaDhUMndvVWkyRXFKWEFDVVVwc2owNDB4QzFIRU9wT1VUbEJFb3RJVVUvQUtYRlFBcXlUSjZEQUFBQUFFbEZUa1N1UW1DQyIpOwoJYmFja2dyb3VuZC1pbWFnZTogdmFyKC0tc2Nyb2xsYmFyLWFycm93cy1HcmF5VGV4dCksIHZhcigtLXNjcm9sbGJhci1hcnJvd3MtQnV0dG9uSGlsaWdodCk7Cn0KCi5zY3JvbGxiYXItYnV0dG9uLmhvcml6b250YWwuZGVjcmVtZW50LmRpc2FibGVkIHsKCWJhY2tncm91bmQtcG9zaXRpb246IC8qIGxlZnQgYXJyb3cgKi8KCQljYWxjKDlweCAqIC0zICsgMXB4KSAxcHgsCgkJY2FsYyg5cHggKiAtMyArIDJweCkgMnB4OwoJYmFja2dyb3VuZC1wb3NpdGlvbjogLyogbGVmdCBhcnJvdyAqLwoJCWNhbGModmFyKC0tc2Nyb2xsYmFyLWJ1dHRvbi1pbm5lci1zaXplKSAqIC0zICsgMXB4KSAxcHgsCgkJY2FsYyh2YXIoLS1zY3JvbGxiYXItYnV0dG9uLWlubmVyLXNpemUpICogLTMgKyAycHgpIDJweDsKfQouc2Nyb2xsYmFyLWJ1dHRvbi5ob3Jpem9udGFsLmluY3JlbWVudC5kaXNhYmxlZCB7CgliYWNrZ3JvdW5kLXBvc2l0aW9uOiAvKiByaWdodCBhcnJvdyAqLwoJCWNhbGMoOXB4ICogLTIgKyAxcHgpIDFweCwKCQljYWxjKDlweCAqIC0yICsgMnB4KSAycHg7CgliYWNrZ3JvdW5kLXBvc2l0aW9uOiAvKiByaWdodCBhcnJvdyAqLwoJCWNhbGModmFyKC0tc2Nyb2xsYmFyLWJ1dHRvbi1pbm5lci1zaXplKSAqIC0yICsgMXB4KSAxcHgsCgkJY2FsYyh2YXIoLS1zY3JvbGxiYXItYnV0dG9uLWlubmVyLXNpemUpICogLTIgKyAycHgpIDJweDsKfQouc2Nyb2xsYmFyLWJ1dHRvbi52ZXJ0aWNhbC5kZWNyZW1lbnQuZGlzYWJsZWQgewoJYmFja2dyb3VuZC1wb3NpdGlvbjogLyogdXAgYXJyb3cgKi8KCQljYWxjKDlweCAqIC0xICsgMXB4KSAxcHgsCgkJY2FsYyg5cHggKiAtMSArIDJweCkgMnB4OwoJYmFja2dyb3VuZC1wb3NpdGlvbjogLyogdXAgYXJyb3cgKi8KCQljYWxjKHZhcigtLXNjcm9sbGJhci1idXR0b24taW5uZXItc2l6ZSkgKiAtMSArIDFweCkgMXB4LAoJCWNhbGModmFyKC0tc2Nyb2xsYmFyLWJ1dHRvbi1pbm5lci1zaXplKSAqIC0xICsgMnB4KSAycHg7Cn0KLnNjcm9sbGJhci1idXR0b24udmVydGljYWwuaW5jcmVtZW50LmRpc2FibGVkIHsKCWJhY2tncm91bmQtcG9zaXRpb246IC8qIGRvd24gYXJyb3cgKi8KCQljYWxjKDlweCAqIC0wICsgMXB4KSAxcHgsCgkJY2FsYyg5cHggKiAtMCArIDJweCkgMnB4OwoJYmFja2dyb3VuZC1wb3NpdGlvbjogLyogZG93biBhcnJvdyAqLwoJCWNhbGModmFyKC0tc2Nyb2xsYmFyLWJ1dHRvbi1pbm5lci1zaXplKSAqIC0wICsgMXB4KSAxcHgsCgkJY2FsYyh2YXIoLS1zY3JvbGxiYXItYnV0dG9uLWlubmVyLXNpemUpICogLTAgKyAycHgpIDJweDsKfQoKLnNjcm9sbGJhci1idXR0b24uaG9yaXpvbnRhbC5kZWNyZW1lbnQgewoJYmFja2dyb3VuZC1wb3NpdGlvbjogY2FsYyg5cHggKiAtMyArIDFweCkgMXB4OwoJYmFja2dyb3VuZC1wb3NpdGlvbjogY2FsYyh2YXIoLS1zY3JvbGxiYXItYnV0dG9uLWlubmVyLXNpemUpICogLTMgKyAxcHgpIDFweDsgLyogbGVmdCAqLwp9Ci5zY3JvbGxiYXItYnV0dG9uLmhvcml6b250YWwuaW5jcmVtZW50IHsKCWJhY2tncm91bmQtcG9zaXRpb246IGNhbGMoOXB4ICogLTIgKyAxcHgpIDFweDsKCWJhY2tncm91bmQtcG9zaXRpb246IGNhbGModmFyKC0tc2Nyb2xsYmFyLWJ1dHRvbi1pbm5lci1zaXplKSAqIC0yICsgMXB4KSAxcHg7IC8qIHJpZ2h0ICovCn0KLnNjcm9sbGJhci1idXR0b24udmVydGljYWwuZGVjcmVtZW50IHsKCWJhY2tncm91bmQtcG9zaXRpb246IGNhbGMoOXB4ICogLTEgKyAxcHgpIDFweDsKCWJhY2tncm91bmQtcG9zaXRpb246IGNhbGModmFyKC0tc2Nyb2xsYmFyLWJ1dHRvbi1pbm5lci1zaXplKSAqIC0xICsgMXB4KSAxcHg7IC8qIHVwICovCn0KLnNjcm9sbGJhci1idXR0b24udmVydGljYWwuaW5jcmVtZW50IHsKCWJhY2tncm91bmQtcG9zaXRpb246IGNhbGMoOXB4ICogLTAgKyAxcHgpIDFweDsKCWJhY2tncm91bmQtcG9zaXRpb246IGNhbGModmFyKC0tc2Nyb2xsYmFyLWJ1dHRvbi1pbm5lci1zaXplKSAqIC0wICsgMXB4KSAxcHg7IC8qIGRvd24gKi8KfQoKOjotd2Via2l0LXNjcm9sbGJhciwKOjotd2Via2l0LXNjcm9sbGJhci10aHVtYiwKOjotd2Via2l0LXNjcm9sbGJhci1idXR0b24gewoJd2lkdGg6IDEzcHg7Cgl3aWR0aDogdmFyKC0tc2Nyb2xsYmFyLXNpemUpOwoJaGVpZ2h0OiAxM3B4OwoJaGVpZ2h0OiB2YXIoLS1zY3JvbGxiYXItc2l6ZSk7Cn0KCjo6LXdlYmtpdC1zY3JvbGxiYXIgewoJYmFja2dyb3VuZDogdXJsKCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFJQUFBQUNDQVlBQUFCeXRnMGtBQUFBRzBsRVFWUVlWMlA4Ly8vLy80TUhEekl3SGpodzRMKzl2VDBEQUhBRkNqNmVzcTNGQUFBQUFFbEZUa1N1UW1DQyIpIHJlcGVhdDsKCWJhY2tncm91bmQ6IHZhcigtLWNoZWNrZXIpIHJlcGVhdDsKCWltYWdlLXJlbmRlcmluZzogcGl4ZWxhdGVkOwp9Cjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWIgewoJYmFja2dyb3VuZC1jb2xvcjogcmdiKDE5MiwgMTkyLCAxOTIpOwoJYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tQnV0dG9uRmFjZSk7Cglib3JkZXItdG9wOiAxcHggc29saWQgcmdiKDE5MiwgMTkyLCAxOTIpOwoJYm9yZGVyLXRvcDogMXB4IHNvbGlkIHZhcigtLUJ1dHRvbkZhY2UpOwoJYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCByZ2IoMTkyLCAxOTIsIDE5Mik7Cglib3JkZXItbGVmdDogMXB4IHNvbGlkIHZhcigtLUJ1dHRvbkZhY2UpOwoJYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgcmdiKDAsIDAsIDApOwoJYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgdmFyKC0tQnV0dG9uRGtTaGFkb3cpOwoJYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHJnYigwLCAwLCAwKTsKCWJvcmRlci1ib3R0b206IDFweCBzb2xpZCB2YXIoLS1CdXR0b25Ea1NoYWRvdyk7Cglib3gtc2hhZG93OiAxcHggMXB4IDAgcmdiKDI1NSwgMjU1LCAyNTUpIGluc2V0LCAtMXB4IC0xcHggMCByZ2IoMTI4LCAxMjgsIDEyOCkgaW5zZXQ7Cglib3gtc2hhZG93OiAxcHggMXB4IDAgdmFyKC0tQnV0dG9uSGlsaWdodCkgaW5zZXQsIC0xcHggLTFweCAwIHZhcigtLUJ1dHRvblNoYWRvdykgaW5zZXQ7Cn0KOjotd2Via2l0LXNjcm9sbGJhci1jb3JuZXIgewoJYmFja2dyb3VuZC1jb2xvcjogcmdiKDE5MiwgMTkyLCAxOTIpOwoJYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tQnV0dG9uRmFjZSk7Cn0KCjo6LXdlYmtpdC1zY3JvbGxiYXItYnV0dG9uIHsKCWJhY2tncm91bmQtY29sb3I6IHJnYigxOTIsIDE5MiwgMTkyKTsKCWJhY2tncm91bmQtY29sb3I6IHZhcigtLUJ1dHRvbkZhY2UpOwoJYm9yZGVyLXRvcDogMXB4IHNvbGlkIHJnYigxOTIsIDE5MiwgMTkyKTsKCWJvcmRlci10b3A6IDFweCBzb2xpZCB2YXIoLS1CdXR0b25GYWNlKTsKCWJvcmRlci1sZWZ0OiAxcHggc29saWQgcmdiKDE5MiwgMTkyLCAxOTIpOwoJYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCB2YXIoLS1CdXR0b25GYWNlKTsKCWJvcmRlci1yaWdodDogMXB4IHNvbGlkIHJnYigwLCAwLCAwKTsKCWJvcmRlci1yaWdodDogMXB4IHNvbGlkIHZhcigtLUJ1dHRvbkRrU2hhZG93KTsKCWJvcmRlci1ib3R0b206IDFweCBzb2xpZCByZ2IoMCwgMCwgMCk7Cglib3JkZXItYm90dG9tOiAxcHggc29saWQgdmFyKC0tQnV0dG9uRGtTaGFkb3cpOwoJYm94LXNoYWRvdzogMXB4IDFweCAwIHJnYigyNTUsIDI1NSwgMjU1KSBpbnNldCwgLTFweCAtMXB4IDAgcmdiKDEyOCwgMTI4LCAxMjgpIGluc2V0OwoJYm94LXNoYWRvdzogMXB4IDFweCAwIHZhcigtLUJ1dHRvbkhpbGlnaHQpIGluc2V0LCAtMXB4IC0xcHggMCB2YXIoLS1CdXR0b25TaGFkb3cpIGluc2V0OwoJYmFja2dyb3VuZC1pbWFnZTogdXJsKCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNRQUFBQUpDQVlBQUFCYU1vNXdBQUFBVzBsRVFWUTRUMk5rR0dTQWNaQzVoNEZXRHZyUHdFQzAyU2hxa1IwRWtrQUh1QnhNeUVLWVdZUThqS0VPWFFPeW8vQTVCdVp3cXF2QlppQSszeE1iaWxRTElXcWxjVUpSaW13UHpqUkVMY2RRWkE2aFJFZVI0ZVJvQmdCb1hoQUs2b2lNaHdBQUFBQkpSVTVFcmtKZ2dnPT0iKTsKCWJhY2tncm91bmQtaW1hZ2U6IHZhcigtLXNjcm9sbGJhci1hcnJvd3MtQnV0dG9uVGV4dCk7CglpbWFnZS1yZW5kZXJpbmc6IHBpeGVsYXRlZDsKCXdpZHRoOiAxM3B4OwoJd2lkdGg6IHZhcigtLXNjcm9sbGJhci1zaXplKTsKCWhlaWdodDogMTNweDsKCWhlaWdodDogdmFyKC0tc2Nyb2xsYmFyLXNpemUpOwoJYm94LXNpemluZzogYm9yZGVyLWJveDsKfQoKOjotd2Via2l0LXNjcm9sbGJhci1idXR0b246bm90KC5kaXNhYmxlZCk6aG92ZXI6YWN0aXZlIHsKCWJvcmRlcjogMXB4IHNvbGlkIHJnYigxMjgsIDEyOCwgMTI4KTsKCWJvcmRlcjogMXB4IHNvbGlkIHZhcigtLUJ1dHRvblNoYWRvdyk7Cglib3gtc2hhZG93OiBub25lOwp9Cgo6Oi13ZWJraXQtc2Nyb2xsYmFyLWJ1dHRvbi5kaXNhYmxlZCB7CgliYWNrZ3JvdW5kLWltYWdlOiB1cmwoImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ1FBQUFBSkNBWUFBQUJhTW81d0FBQUFZRWxFUVZRNFQyTmtHR1NBY1pDNWg0RW1EbXBvYVBqZjBOQkFsTm5vYXVHYVFCTG9vWVhMVUVJV3dzd2k1Q2hzNmxCOGdld29mSTZCT1p3V2FqQ0NGWi92aVExRnFvVVF0Ukk0b1NoRnRnZG5HcUtXWXlnMWg2aWNRS2tscE9nSEFNOW1RQXJFdm01K0FBQUFBRWxGVGtTdVFtQ0MiKSwgdXJsKCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNRQUFBQUpDQVlBQUFCYU1vNXdBQUFBWUVsRVFWUTRUMk5rR0dTQWNaQzVoNEVtRHZyLy8vOS9Sa1pHb3N4R1Z3dlhCSkpBRHkxY2hoS3lFR1lXSVVkaFU0ZmlDMlJINFhNTXpPRzBVSU1SclBoOFQyd29VaTJFcUpYQUNVVXBzajA0MHhDMUhFT3BPVVRsQkVvdElVVS9BS1hGUUFxeVRKNkRBQUFBQUVsRlRrU3VRbUNDIik7CgliYWNrZ3JvdW5kLWltYWdlOiB2YXIoLS1zY3JvbGxiYXItYXJyb3dzLUdyYXlUZXh0KSwgdmFyKC0tc2Nyb2xsYmFyLWFycm93cy1CdXR0b25IaWxpZ2h0KTsKfQoKOjotd2Via2l0LXNjcm9sbGJhci1idXR0b24uaG9yaXpvbnRhbC5kZWNyZW1lbnQuZGlzYWJsZWQgewoJYmFja2dyb3VuZC1wb3NpdGlvbjogLyogbGVmdCBhcnJvdyAqLwoJCWNhbGMoOXB4ICogLTMgKyAxcHgpIDFweCwKCQljYWxjKDlweCAqIC0zICsgMnB4KSAycHg7CgliYWNrZ3JvdW5kLXBvc2l0aW9uOiAvKiBsZWZ0IGFycm93ICovCgkJY2FsYyh2YXIoLS1zY3JvbGxiYXItYnV0dG9uLWlubmVyLXNpemUpICogLTMgKyAxcHgpIDFweCwKCQljYWxjKHZhcigtLXNjcm9sbGJhci1idXR0b24taW5uZXItc2l6ZSkgKiAtMyArIDJweCkgMnB4Owp9Cgo6Oi13ZWJraXQtc2Nyb2xsYmFyLWJ1dHRvbi5ob3Jpem9udGFsLmluY3JlbWVudC5kaXNhYmxlZCB7CgliYWNrZ3JvdW5kLXBvc2l0aW9uOiAvKiByaWdodCBhcnJvdyAqLwoJCWNhbGMoOXB4ICogLTIgKyAxcHgpIDFweCwKCQljYWxjKDlweCAqIC0yICsgMnB4KSAycHg7CgliYWNrZ3JvdW5kLXBvc2l0aW9uOiAvKiByaWdodCBhcnJvdyAqLwoJCWNhbGModmFyKC0tc2Nyb2xsYmFyLWJ1dHRvbi1pbm5lci1zaXplKSAqIC0yICsgMXB4KSAxcHgsCgkJY2FsYyh2YXIoLS1zY3JvbGxiYXItYnV0dG9uLWlubmVyLXNpemUpICogLTIgKyAycHgpIDJweDsKfQoKOjotd2Via2l0LXNjcm9sbGJhci1idXR0b24udmVydGljYWwuZGVjcmVtZW50LmRpc2FibGVkIHsKCWJhY2tncm91bmQtcG9zaXRpb246IC8qIHVwIGFycm93ICovCgkJY2FsYyg5cHggKiAtMSArIDFweCkgMXB4LAoJCWNhbGMoOXB4ICogLTEgKyAycHgpIDJweDsKCWJhY2tncm91bmQtcG9zaXRpb246IC8qIHVwIGFycm93ICovCgkJY2FsYyh2YXIoLS1zY3JvbGxiYXItYnV0dG9uLWlubmVyLXNpemUpICogLTEgKyAxcHgpIDFweCwKCQljYWxjKHZhcigtLXNjcm9sbGJhci1idXR0b24taW5uZXItc2l6ZSkgKiAtMSArIDJweCkgMnB4Owp9Cgo6Oi13ZWJraXQtc2Nyb2xsYmFyLWJ1dHRvbi52ZXJ0aWNhbC5pbmNyZW1lbnQuZGlzYWJsZWQgewoJYmFja2dyb3VuZC1wb3NpdGlvbjogLyogZG93biBhcnJvdyAqLwoJCWNhbGMoOXB4ICogLTAgKyAxcHgpIDFweCwKCQljYWxjKDlweCAqIC0wICsgMnB4KSAycHg7CgliYWNrZ3JvdW5kLXBvc2l0aW9uOiAvKiBkb3duIGFycm93ICovCgkJY2FsYyh2YXIoLS1zY3JvbGxiYXItYnV0dG9uLWlubmVyLXNpemUpICogLTAgKyAxcHgpIDFweCwKCQljYWxjKHZhcigtLXNjcm9sbGJhci1idXR0b24taW5uZXItc2l6ZSkgKiAtMCArIDJweCkgMnB4Owp9Cgo6Oi13ZWJraXQtc2Nyb2xsYmFyLWJ1dHRvbi5ob3Jpem9udGFsLmRlY3JlbWVudCB7CgliYWNrZ3JvdW5kLXBvc2l0aW9uOiBjYWxjKDlweCAqIC0zICsgMXB4KSAxcHg7CgliYWNrZ3JvdW5kLXBvc2l0aW9uOiBjYWxjKHZhcigtLXNjcm9sbGJhci1idXR0b24taW5uZXItc2l6ZSkgKiAtMyArIDFweCkgMXB4OwoJLyogbGVmdCAqLwp9Cgo6Oi13ZWJraXQtc2Nyb2xsYmFyLWJ1dHRvbi5ob3Jpem9udGFsLmluY3JlbWVudCB7CgliYWNrZ3JvdW5kLXBvc2l0aW9uOiBjYWxjKDlweCAqIC0yICsgMXB4KSAxcHg7CgliYWNrZ3JvdW5kLXBvc2l0aW9uOiBjYWxjKHZhcigtLXNjcm9sbGJhci1idXR0b24taW5uZXItc2l6ZSkgKiAtMiArIDFweCkgMXB4OwoJLyogcmlnaHQgKi8KfQoKOjotd2Via2l0LXNjcm9sbGJhci1idXR0b24udmVydGljYWwuZGVjcmVtZW50IHsKCWJhY2tncm91bmQtcG9zaXRpb246IGNhbGMoOXB4ICogLTEgKyAxcHgpIDFweDsKCWJhY2tncm91bmQtcG9zaXRpb246IGNhbGModmFyKC0tc2Nyb2xsYmFyLWJ1dHRvbi1pbm5lci1zaXplKSAqIC0xICsgMXB4KSAxcHg7CgkvKiB1cCAqLwp9Cgo6Oi13ZWJraXQtc2Nyb2xsYmFyLWJ1dHRvbi52ZXJ0aWNhbC5pbmNyZW1lbnQgewoJYmFja2dyb3VuZC1wb3NpdGlvbjogY2FsYyg5cHggKiAtMCArIDFweCkgMXB4OwoJYmFja2dyb3VuZC1wb3NpdGlvbjogY2FsYyh2YXIoLS1zY3JvbGxiYXItYnV0dG9uLWlubmVyLXNpemUpICogLTAgKyAxcHgpIDFweDsKCS8qIGRvd24gKi8KfQo6Oi13ZWJraXQtc2Nyb2xsYmFyLWJ1dHRvbjpob3ZlcjphY3RpdmUgewoJYm9yZGVyOiAxcHggc29saWQgcmdiKDEyOCwgMTI4LCAxMjgpOwoJYm9yZGVyOiAxcHggc29saWQgdmFyKC0tQnV0dG9uU2hhZG93KTsKCWJveC1zaGFkb3c6IG5vbmU7Cn0KOjotd2Via2l0LXNjcm9sbGJhci1idXR0b246ZGlzYWJsZWQgewoJYmFja2dyb3VuZC1pbWFnZTogdXJsKCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNRQUFBQUpDQVlBQUFCYU1vNXdBQUFBWUVsRVFWUTRUMk5rR0dTQWNaQzVoNEVtRG1wb2FQamYwTkJBbE5ub2F1R2FRQkxvb1lYTFVFSVd3c3dpNUNoczZsQjhnZXdvZkk2Qk9ad1dhakNDRlovdmlRMUZxb1VRdFJJNG9TaEZ0Z2RuR3FLV1l5ZzFoNmljUUtrbHBPZ0hBTTltUUFyRXZtNStBQUFBQUVsRlRrU3VRbUNDIiksIHVybCgiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDUUFBQUFKQ0FZQUFBQmFNbzV3QUFBQVlFbEVRVlE0VDJOa0dHU0FjWkM1aDRFbUR2ci8vLzkvUmtaR29zeEdWd3ZYQkpKQUR5MWNoaEt5RUdZV0lVZGhVNGZpQzJSSDRYTU16T0cwVUlNUnJQaDhUMndvVWkyRXFKWEFDVVVwc2owNDB4QzFIRU9wT1VUbEJFb3RJVVUvQUtYRlFBcXlUSjZEQUFBQUFFbEZUa1N1UW1DQyIpOwoJYmFja2dyb3VuZC1pbWFnZTogdmFyKC0tc2Nyb2xsYmFyLWFycm93cy1HcmF5VGV4dCksIHZhcigtLXNjcm9sbGJhci1hcnJvd3MtQnV0dG9uSGlsaWdodCk7Cn0KCjo6LXdlYmtpdC1zY3JvbGxiYXItYnV0dG9uOmhvcml6b250YWw6ZGVjcmVtZW50OmRpc2FibGVkIHsKCWJhY2tncm91bmQtcG9zaXRpb246IC8qIGxlZnQgYXJyb3cgKi8KCQljYWxjKDlweCAqIC0zICsgMXB4KSAxcHgsCgkJY2FsYyg5cHggKiAtMyArIDJweCkgMnB4OwoJYmFja2dyb3VuZC1wb3NpdGlvbjogLyogbGVmdCBhcnJvdyAqLwoJCWNhbGModmFyKC0tc2Nyb2xsYmFyLWJ1dHRvbi1pbm5lci1zaXplKSAqIC0zICsgMXB4KSAxcHgsCgkJY2FsYyh2YXIoLS1zY3JvbGxiYXItYnV0dG9uLWlubmVyLXNpemUpICogLTMgKyAycHgpIDJweDsKfQo6Oi13ZWJraXQtc2Nyb2xsYmFyLWJ1dHRvbjpob3Jpem9udGFsOmluY3JlbWVudDpkaXNhYmxlZCB7CgliYWNrZ3JvdW5kLXBvc2l0aW9uOiAvKiByaWdodCBhcnJvdyAqLwoJCWNhbGMoOXB4ICogLTIgKyAxcHgpIDFweCwKCQljYWxjKDlweCAqIC0yICsgMnB4KSAycHg7CgliYWNrZ3JvdW5kLXBvc2l0aW9uOiAvKiByaWdodCBhcnJvdyAqLwoJCWNhbGModmFyKC0tc2Nyb2xsYmFyLWJ1dHRvbi1pbm5lci1zaXplKSAqIC0yICsgMXB4KSAxcHgsCgkJY2FsYyh2YXIoLS1zY3JvbGxiYXItYnV0dG9uLWlubmVyLXNpemUpICogLTIgKyAycHgpIDJweDsKfQo6Oi13ZWJraXQtc2Nyb2xsYmFyLWJ1dHRvbjp2ZXJ0aWNhbDpkZWNyZW1lbnQ6ZGlzYWJsZWQgewoJYmFja2dyb3VuZC1wb3NpdGlvbjogLyogdXAgYXJyb3cgKi8KCQljYWxjKDlweCAqIC0xICsgMXB4KSAxcHgsCgkJY2FsYyg5cHggKiAtMSArIDJweCkgMnB4OwoJYmFja2dyb3VuZC1wb3NpdGlvbjogLyogdXAgYXJyb3cgKi8KCQljYWxjKHZhcigtLXNjcm9sbGJhci1idXR0b24taW5uZXItc2l6ZSkgKiAtMSArIDFweCkgMXB4LAoJCWNhbGModmFyKC0tc2Nyb2xsYmFyLWJ1dHRvbi1pbm5lci1zaXplKSAqIC0xICsgMnB4KSAycHg7Cn0KOjotd2Via2l0LXNjcm9sbGJhci1idXR0b246dmVydGljYWw6aW5jcmVtZW50OmRpc2FibGVkIHsKCWJhY2tncm91bmQtcG9zaXRpb246IC8qIGRvd24gYXJyb3cgKi8KCQljYWxjKDlweCAqIC0wICsgMXB4KSAxcHgsCgkJY2FsYyg5cHggKiAtMCArIDJweCkgMnB4OwoJYmFja2dyb3VuZC1wb3NpdGlvbjogLyogZG93biBhcnJvdyAqLwoJCWNhbGModmFyKC0tc2Nyb2xsYmFyLWJ1dHRvbi1pbm5lci1zaXplKSAqIC0wICsgMXB4KSAxcHgsCgkJY2FsYyh2YXIoLS1zY3JvbGxiYXItYnV0dG9uLWlubmVyLXNpemUpICogLTAgKyAycHgpIDJweDsKfQoKOjotd2Via2l0LXNjcm9sbGJhci1idXR0b246aG9yaXpvbnRhbDpkZWNyZW1lbnQuZGlzYWJsZWQgewoJYmFja2dyb3VuZC1wb3NpdGlvbjogLyogbGVmdCBhcnJvdyAqLwoJCWNhbGMoOXB4ICogLTMgKyAxcHgpIDFweCwKCQljYWxjKDlweCAqIC0zICsgMnB4KSAycHg7CgliYWNrZ3JvdW5kLXBvc2l0aW9uOiAvKiBsZWZ0IGFycm93ICovCgkJY2FsYyh2YXIoLS1zY3JvbGxiYXItYnV0dG9uLWlubmVyLXNpemUpICogLTMgKyAxcHgpIDFweCwKCQljYWxjKHZhcigtLXNjcm9sbGJhci1idXR0b24taW5uZXItc2l6ZSkgKiAtMyArIDJweCkgMnB4Owp9Cgo6Oi13ZWJraXQtc2Nyb2xsYmFyLWJ1dHRvbjpob3Jpem9udGFsOmRlY3JlbWVudCB7CgliYWNrZ3JvdW5kLXBvc2l0aW9uOiBjYWxjKDlweCAqIC0zICsgMXB4KSAxcHg7CgliYWNrZ3JvdW5kLXBvc2l0aW9uOiBjYWxjKHZhcigtLXNjcm9sbGJhci1idXR0b24taW5uZXItc2l6ZSkgKiAtMyArIDFweCkgMXB4OwoJLyogbGVmdCAqLwp9Cjo6LXdlYmtpdC1zY3JvbGxiYXItYnV0dG9uOmhvcml6b250YWw6aW5jcmVtZW50LmRpc2FibGVkIHsKCWJhY2tncm91bmQtcG9zaXRpb246IC8qIHJpZ2h0IGFycm93ICovCgkJY2FsYyg5cHggKiAtMiArIDFweCkgMXB4LAoJCWNhbGMoOXB4ICogLTIgKyAycHgpIDJweDsKCWJhY2tncm91bmQtcG9zaXRpb246IC8qIHJpZ2h0IGFycm93ICovCgkJY2FsYyh2YXIoLS1zY3JvbGxiYXItYnV0dG9uLWlubmVyLXNpemUpICogLTIgKyAxcHgpIDFweCwKCQljYWxjKHZhcigtLXNjcm9sbGJhci1idXR0b24taW5uZXItc2l6ZSkgKiAtMiArIDJweCkgMnB4Owp9Cjo6LXdlYmtpdC1zY3JvbGxiYXItYnV0dG9uOmhvcml6b250YWw6aW5jcmVtZW50IHsKCWJhY2tncm91bmQtcG9zaXRpb246IGNhbGMoOXB4ICogLTIgKyAxcHgpIDFweDsKCWJhY2tncm91bmQtcG9zaXRpb246IGNhbGModmFyKC0tc2Nyb2xsYmFyLWJ1dHRvbi1pbm5lci1zaXplKSAqIC0yICsgMXB4KSAxcHg7CgkvKiByaWdodCAqLwp9Cjo6LXdlYmtpdC1zY3JvbGxiYXItYnV0dG9uOnZlcnRpY2FsOmRlY3JlbWVudC5kaXNhYmxlZCB7CgliYWNrZ3JvdW5kLXBvc2l0aW9uOiAvKiB1cCBhcnJvdyAqLwoJCWNhbGMoOXB4ICogLTEgKyAxcHgpIDFweCwKCQljYWxjKDlweCAqIC0xICsgMnB4KSAycHg7CgliYWNrZ3JvdW5kLXBvc2l0aW9uOiAvKiB1cCBhcnJvdyAqLwoJCWNhbGModmFyKC0tc2Nyb2xsYmFyLWJ1dHRvbi1pbm5lci1zaXplKSAqIC0xICsgMXB4KSAxcHgsCgkJY2FsYyh2YXIoLS1zY3JvbGxiYXItYnV0dG9uLWlubmVyLXNpemUpICogLTEgKyAycHgpIDJweDsKfQo6Oi13ZWJraXQtc2Nyb2xsYmFyLWJ1dHRvbjp2ZXJ0aWNhbDpkZWNyZW1lbnQgewoJYmFja2dyb3VuZC1wb3NpdGlvbjogY2FsYyg5cHggKiAtMSArIDFweCkgMXB4OwoJYmFja2dyb3VuZC1wb3NpdGlvbjogY2FsYyh2YXIoLS1zY3JvbGxiYXItYnV0dG9uLWlubmVyLXNpemUpICogLTEgKyAxcHgpIDFweDsKCS8qIHVwICovCn0KOjotd2Via2l0LXNjcm9sbGJhci1idXR0b246dmVydGljYWw6aW5jcmVtZW50LmRpc2FibGVkIHsKCWJhY2tncm91bmQtcG9zaXRpb246IC8qIGRvd24gYXJyb3cgKi8KCQljYWxjKDlweCAqIC0wICsgMXB4KSAxcHgsCgkJY2FsYyg5cHggKiAtMCArIDJweCkgMnB4OwoJYmFja2dyb3VuZC1wb3NpdGlvbjogLyogZG93biBhcnJvdyAqLwoJCWNhbGModmFyKC0tc2Nyb2xsYmFyLWJ1dHRvbi1pbm5lci1zaXplKSAqIC0wICsgMXB4KSAxcHgsCgkJY2FsYyh2YXIoLS1zY3JvbGxiYXItYnV0dG9uLWlubmVyLXNpemUpICogLTAgKyAycHgpIDJweDsKfQo6Oi13ZWJraXQtc2Nyb2xsYmFyLWJ1dHRvbjp2ZXJ0aWNhbDppbmNyZW1lbnQgewoJYmFja2dyb3VuZC1wb3NpdGlvbjogY2FsYyg5cHggKiAtMCArIDFweCkgMXB4OwoJYmFja2dyb3VuZC1wb3NpdGlvbjogY2FsYyh2YXIoLS1zY3JvbGxiYXItYnV0dG9uLWlubmVyLXNpemUpICogLTAgKyAxcHgpIDFweDsKCS8qIGRvd24gKi8KfQoKOjotd2Via2l0LXNjcm9sbGJhci10cmFjay1waWVjZTpob3ZlcjphY3RpdmUgewoJYmFja2dyb3VuZDogdXJsKCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFJQUFBQUNDQVlBQUFCeXRnMGtBQUFBRzBsRVFWUVlWMlA4Ly8vLy80TUhEekl3SGpodzRMKzl2VDBEQUhBRkNqNmVzcTNGQUFBQUFFbEZUa1N1UW1DQyIpIHJlcGVhdDsKCWJhY2tncm91bmQ6IHZhcigtLWNoZWNrZXIpIHJlcGVhdDsKCWltYWdlLXJlbmRlcmluZzogcGl4ZWxhdGVkOwoJYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7CgliYWNrZ3JvdW5kLWJsZW5kLW1vZGU6IGRpZmZlcmVuY2U7CgkvKiBiYWNrZ3JvdW5kLWF0dGFjaG1lbnQ6IGZpeGVkOyBicmVha3MgdGhlIGNoZWNrZXJlZCBiYWNrZ3JvdW5kIGluIGNocm9tZSAqLwp9Cgo6Oi13ZWJraXQtc2Nyb2xsYmFyLXRyYWNrLXBpZWNlLmluY3JlbWVudCB7CgliYWNrZ3JvdW5kLXBvc2l0aW9uOiBib3R0b207Cn0KOjotd2Via2l0LXNjcm9sbGJhci10cmFjay1waWVjZTppbmNyZW1lbnQgewoJYmFja2dyb3VuZC1wb3NpdGlvbjogYm90dG9tOwp9CgovKiB0dXJuIG9mZiBkb3VibGUgYnV0dG9ucyAqLwo6Oi13ZWJraXQtc2Nyb2xsYmFyLWJ1dHRvbjpzdGFydDppbmNyZW1lbnQsCjo6LXdlYmtpdC1zY3JvbGxiYXItYnV0dG9uOmVuZDpkZWNyZW1lbnQgewoJZGlzcGxheTogbm9uZTsKfQoKLyojIHNvdXJjZU1hcHBpbmdVUkw9d2luZG93cy05OC5jc3MubWFwICovCgoKCi8qIEN1c3RvbSB0aGVtZXMgdG8gd2luZG93cyBYUCBzdHlsZSAqLwoubWVudXMsCi5jb21wb25lbnQtYXJlYSwKLnN0YXR1cy1hcmVhIHsKCWJhY2tncm91bmQtY29sb3I6ICNlZWVjZGQgIWltcG9ydGFudDsKfQoKLnRvb2wgewoJYm9yZGVyOiBub25lICFpbXBvcnRhbnQ7Cglib3JkZXItdG9wOiBub25lICFpbXBvcnRhbnQ7Cglib3JkZXItcmlnaHQ6IG5vbmUgIWltcG9ydGFudDsKCWJvcmRlci1ib3R0b206IG5vbmUgIWltcG9ydGFudDsKCWJvcmRlci1sZWZ0OiBub25lICFpbXBvcnRhbnQ7Cglib3gtc2hhZG93OiBub25lICFpbXBvcnRhbnQ7CgliYWNrZ3JvdW5kLWltYWdlOiBub25lICFpbXBvcnRhbnQ7Cglib3JkZXItaW1hZ2U6IG5vbmUgIWltcG9ydGFudDsKCWJvcmRlci1pbWFnZS13aWR0aDogMHB4ICFpbXBvcnRhbnQ7CglwYWRkaW5nOiA4cHggIWltcG9ydGFudDsKfQoKLnRvb2wuc2VsZWN0ZWQgewoJYmFja2dyb3VuZC1jb2xvcjogI2Y4ZjhmOCAhaW1wb3J0YW50OwoJYm9yZGVyLXJhZGl1czogNHB4ICFpbXBvcnRhbnQ7Cglib3JkZXI6IDFweCBzb2xpZCAjOWY5ZjlmICFpbXBvcnRhbnQ7Cn0KCi5tZW51cyB7CiAgaGVpZ2h0OiAyNnB4ICFpbXBvcnRhbnQ7Cn0KCi5zdGF0dXMtYXJlYSB7CiAgaGVpZ2h0OiAxOHB4ICFpbXBvcnRhbnQ7Cn0KCi5zdGF0dXMtdGV4dCB7CiAgLypmb250LXNpemU6IDdweCAhaW1wb3J0YW50OyovCiAgbGV0dGVyLXNwYWNpbmc6IDAuNXB4Owp9CgoubWVudS1idXR0b24gewogIG1hcmdpbi10b3A6IDRweCAhaW1wb3J0YW50OwogIG1hcmdpbi1ib3R0b206IGF1dG8gIWltcG9ydGFudDsKICBtYXJnaW4tcmlnaHQ6IDZweCAhaW1wb3J0YW50OwogIG1hcmdpbi1sZWZ0OiA0cHggIWltcG9ydGFudDsKfQoKLm1lbnUtY29udGFpbmVyOmhvdmVyLCAubWVudS1jb250YWluZXI6YWN0aXZlLCAubWVudS1idXR0b246aG92ZXIsIC5tZW51LWJ1dHRvbjphY3RpdmUgewogIGJhY2tncm91bmQtY29sb3I6ICMzMTY5YzY7CiAgY29sb3I6IHdoaXRlOwogIHRyYW5zaXRpb24tZHVyYXRpb246IDBtczsKICB0cmFuc2l0aW9uLXByb3BlcnR5OiBub25lOwp9CgoubWVudS1idXR0b24gewogIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwwLDAsMCk7Cn0KCi5tZW51LXBvcHVwIHsKICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmZmZmICFpbXBvcnRhbnQ7CiAgYm9yZGVyOiAxcHggc29saWQgI2FkYWE5YyAhaW1wb3J0YW50OwogIGJveC1zaGFkb3c6IDJweCAycHggMnB4IGdyZXkgIWltcG9ydGFudDsKfQoKLm1lbnUtaHIgewogIGJvcmRlcjogMHB4IHNvbGlkICNhZGFhOWMgIWltcG9ydGFudDsKICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2FkYWE5YyAhaW1wb3J0YW50Owp9CgoubWVudS1pdGVtIHsKICAvKnBhZGRpbmc6IDBweCAhaW1wb3J0YW50OyovCiAgcGFkZGluZy10b3A6IDRweCAhaW1wb3J0YW50OwogIHBhZGRpbmctYm90dG9tOiA0cHggIWltcG9ydGFudDsKfQoKLm1lbnUtaXRlbTpob3ZlciB7CgliYWNrZ3JvdW5kLWNvbG9yOiAjMzE2OWM2OwoJY29sb3I6IHdoaXRlOwp9CgoubWVudXMgewoJYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHdoaXRlOwp9CgouaG9yaXpvbnRhbCB7Cglib3JkZXItdG9wOiAxcHggc29saWQgI2FkYWE5YzsKCWJvcmRlci1yaWdodDogMXB4IHNvbGlkICNhZGFhOWM7Cglib3JkZXItYm90dG9tOiAxcHggc29saWQgI2FkYWE5YzsKfQoKLmNvbXBvbmVudC1hcmVhIHsKCWJvcmRlci10b3A6IDFweCBzb2xpZCB3aGl0ZTsKfQoKLnRvb2w6aG92ZXIgewoJYmFja2dyb3VuZC1jb2xvcjogI2ZkZmRmYiAhaW1wb3J0YW50OwoJYm9yZGVyOiAxcHggc29saWQgI2NlY2VjMyAhaW1wb3J0YW50OwoJYm9yZGVyLXJhZGl1czogNHB4ICFpbXBvcnRhbnQ7Cgl0cmFuc2l0aW9uLWR1cmF0aW9uOiAwbXMgIWltcG9ydGFudDsKCWJveC1zaGFkb3c6IDFweCAxcHggMXB4ICNjZWNlYzMgIWltcG9ydGFudDsKfQoKLyogQGltcG9ydCAiLi4vLi4vbGliL29zLWd1aS93aW5kb3dzLWRlZmF1bHQuY3NzIjsgKi8KLyogQGltcG9ydCAiLi4vLi4vbGliL29zLWd1aS9wZWdneXMtcGFzdGVscy5jc3MiOyAqLwoKOnJvb3QgewoJLS10aGVtZS1sb2FkZWQ6ICJjbGFzc2ljLmNzcyI7Cn0KCi5qc3BhaW50IHsKCWJhY2tncm91bmQ6IHZhcigtLUJ1dHRvbkZhY2UpOwp9CmJvZHksCi5jYW52YXMtYXJlYSB7CgliYWNrZ3JvdW5kOiB2YXIoLS1BcHBXb3Jrc3BhY2UpOwp9Ci5jYW52YXMtYXJlYSB7Cglib3JkZXI6IDFweCBpbnNldDsKfQouY2FudmFzLWFyZWEgPiBjYW52YXMgewoJYmFja2dyb3VuZDogdmFyKC0tY2hlY2tlcik7CgkvKiAxNnB4IGlzIGEgY29tbW9uIGdyaWQgc2l6ZSwgYnV0IHRoYXQgZ2l2ZXMgOHB4IGdyaWQgY2VsbHMsIGFuZCBvdXIgbWF4IHpvb20gaXMgOHggKi8KCS8qYmFja2dyb3VuZC1zaXplOiAxNnB4OyovCgliYWNrZ3JvdW5kLXNpemU6IDhweDsKfQoKQG1lZGlhIChyZXNvbHV0aW9uOiAxeCksIChyZXNvbHV0aW9uOiAyeCksIChtaW4tcmVzb2x1dGlvbjogM3gpIHsKCSogewoJCWltYWdlLXJlbmRlcmluZzogLW1vei1jcmlzcC1lZGdlczsKCQlpbWFnZS1yZW5kZXJpbmc6IGNyaXNwLWVkZ2VzOwoJCWltYWdlLXJlbmRlcmluZzogcGl4ZWxhdGVkOwoJfQp9Ci5kaXNhYmxlLWFhLWZvci10aGluZ3MtYXQtbWFpbi1jYW52YXMtc2NhbGUgLm1haW4tY2FudmFzLAouZGlzYWJsZS1hYS1mb3ItdGhpbmdzLWF0LW1haW4tY2FudmFzLXNjYWxlIC5zZWxlY3Rpb24gY2FudmFzIHsKCWltYWdlLXJlbmRlcmluZzogLW1vei1jcmlzcC1lZGdlczsKCWltYWdlLXJlbmRlcmluZzogY3Jpc3AtZWRnZXM7CglpbWFnZS1yZW5kZXJpbmc6IHBpeGVsYXRlZDsKfQoKLnNlbGVjdGlvbjphZnRlciwKLnRleHRib3g6YWZ0ZXIgewoJY29udGVudDogJyc7Cglwb3NpdGlvbjogYWJzb2x1dGU7CglsZWZ0OiAwcHg7Cgl0b3A6IDBweDsKCXJpZ2h0OiAwcHg7Cglib3R0b206IDBweDsKCW91dGxpbmU6IDFweCBkYXNoZWQgYmxhY2s7Cglib3gtc2hhZG93OiAwIDAgMCAxcHggd2hpdGU7Cn0KLmhhbmRsZSB7CgliYWNrZ3JvdW5kOiB2YXIoLS1IaWxpZ2h0KTsKfQoudXNlbGVzcy1oYW5kbGUgewoJYmFja2dyb3VuZDogdmFyKC0tSGlsaWdodFRleHQpOyAvKiBAVE9ETzogLS1CdXR0b25IaWxpZ2h0PyAtLVdpbmRvdz8gKi8KCWJveC1zaGFkb3c6IDFweCAxcHggMCB2YXIoLS1IaWxpZ2h0KSBpbnNldDsKfQoucmVzaXplLWdob3N0IHsKCW91dGxpbmU6IDFweCBkb3R0ZWQgYmxhY2s7CgkvKm91dGxpbmU6IDFweCBkb3R0ZWQgaW52ZXJ0OyovCgkvKiBJIHdhbnQgdGhpcyB0byBiZSBpbnZlcnR5LCBidXQgaW4gY2hyb21lIHRoaXMgbWFrZXMgaXQgaW52aXNpYmxlICovCn0KCi5zdGF0dXMtYXJlYSB7Cglmb250LWZhbWlseTogJ1NlZ29lIFVJJywgc2Fucy1zZXJpZjsKCWZvbnQtc2l6ZTogMTJweDsKCWNvbG9yOiB2YXIoLS1CdXR0b25UZXh0KTsKCXBhZGRpbmc6IDNweCAycHg7CglwYWRkaW5nLXRvcDogNHB4OwoJYm9yZGVyLXRvcDogMXB4IHNvbGlkIHZhcigtLUJ1dHRvblNoYWRvdyk7CglvdXRsaW5lOiAxcHggc29saWQgdmFyKC0tQnV0dG9uU2hhZG93KTsKCW91dGxpbmUtb2Zmc2V0OiAxcHg7Cn0KCi50ZXh0LXRvb2xiYXItYnV0dG9uLWdyb3VwIGJ1dHRvbjpub3QoOmZpcnN0LWNoaWxkKSB7CgltYXJnaW4tbGVmdDogMDsKfQoudGV4dC10b29sYmFyLWJ1dHRvbi1ncm91cCBidXR0b246bm90KDpsYXN0LWNoaWxkKSB7CgltYXJnaW4tcmlnaHQ6IDA7Cn0KCi50b29sLW9wdGlvbnMgewoJYm9yZGVyOiAxcHggc29saWQgdmFyKC0tQnV0dG9uSGlsaWdodCk7Cglib3JkZXItdG9wLWNvbG9yOiB2YXIoLS1CdXR0b25TaGFkb3cpOwoJYm9yZGVyLWxlZnQtY29sb3I6IHZhcigtLUJ1dHRvblNoYWRvdyk7Cn0KLnRvb2wgewoJbWFyZ2luOiAwOwoJcGFkZGluZzogMDsKCXdpZHRoOiAyNXB4OwoJaGVpZ2h0OiAyNXB4OwoJYm9yZGVyOiAwOwoJLypib3JkZXItcmlnaHQ6IDFweCBzb2xpZCB2YXIoLS1CdXR0b25Ea1NoYWRvdyk7Cglib3JkZXItYm90dG9tOiAxcHggc29saWQgdmFyKC0tQnV0dG9uRGtTaGFkb3cpOyovCgliYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDsKCW91dGxpbmU6IDA7Cn0KLnRvb2w6YmVmb3JlIHsKCWNvbnRlbnQ6ICIgIjsKCXBvc2l0aW9uOiBhYnNvbHV0ZTsKCXotaW5kZXg6IDE7Cgl0b3A6IDBweDsKCWxlZnQ6IDBweDsKCXJpZ2h0OiAwcHg7Cglib3R0b206IDBweDsKCS8qYm9yZGVyLXRvcDogMXB4IHNvbGlkIHZhcigtLUJ1dHRvbkhpbGlnaHQpOwoJYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCB2YXIoLS1CdXR0b25IaWxpZ2h0KTsKCWJvcmRlci1yaWdodDogMXB4IHNvbGlkIHZhcigtLUJ1dHRvblNoYWRvdyk7Cglib3JkZXItYm90dG9tOiAxcHggc29saWQgdmFyKC0tQnV0dG9uU2hhZG93KTsqLwp9Ci50b29sOmhvdmVyOmFjdGl2ZSB7CglwYWRkaW5nOiAxcHg7CgliYWNrZ3JvdW5kOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50Owp9Ci50b29sOmhvdmVyOmFjdGl2ZSwKLnRvb2wuc2VsZWN0ZWQgewoJcGFkZGluZy1ib3R0b206IDJweDsKCXRvcDogMHB4OwoJbGVmdDogMHB4OwoJcmlnaHQ6IDBweDsKCWJvdHRvbTogMHB4OwoJLypib3JkZXItdG9wOiAxcHggc29saWQgdmFyKC0tQnV0dG9uRGtTaGFkb3cpOwoJYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCB2YXIoLS1CdXR0b25Ea1NoYWRvdyk7Cglib3JkZXItcmlnaHQ6IDFweCBzb2xpZCB2YXIoLS1CdXR0b25IaWxpZ2h0KTsKCWJvcmRlci1ib3R0b206IDFweCBzb2xpZCB2YXIoLS1CdXR0b25IaWxpZ2h0KTsqLwp9Ci50b29sOmhvdmVyOmFjdGl2ZTpiZWZvcmUsCi50b29sLnNlbGVjdGVkOmJlZm9yZSB7Cgl0b3A6IDBweDsKCWxlZnQ6IDBweDsKCXJpZ2h0OiAwcHg7Cglib3R0b206IDBweDsKCS8qYm9yZGVyLXRvcDogMXB4IHNvbGlkIHZhcigtLUJ1dHRvblNoYWRvdyk7Cglib3JkZXItbGVmdDogMXB4IHNvbGlkIHZhcigtLUJ1dHRvblNoYWRvdyk7Cglib3JkZXItcmlnaHQ6IDFweCBzb2xpZCB2YXIoLS1CdXR0b25GYWNlKTsKCWJvcmRlci1ib3R0b206IDFweCBzb2xpZCB2YXIoLS1CdXR0b25GYWNlKTsqLwp9Ci50b29sLnNlbGVjdGVkLAouY3VycmVudC1jb2xvcnMgewoJYmFja2dyb3VuZDogdmFyKC0tY2hlY2tlcik7Cn0KCi50b29scyB7CgloZWlnaHQ6IDIwMHB4OwoJd2lkdGg6IDUwcHg7Cn0KCgouY3VycmVudC1jb2xvcnMgewoJYm94LXNpemluZzogYm9yZGVyLWJveDsKCS1tb3otYm94LXNpemluZzogYm9yZGVyLWJveDsKfQouY29sb3Itc2VsZWN0aW9uIHsKCWJveC1zaXppbmc6IGJvcmRlci1ib3g7CgktbW96LWJveC1zaXppbmc6IGJvcmRlci1ib3g7Cglib3JkZXItdG9wOiAxcHggc29saWQgdmFyKC0tQnV0dG9uSGlsaWdodCk7Cglib3JkZXItbGVmdDogMXB4IHNvbGlkIHZhcigtLUJ1dHRvbkhpbGlnaHQpOwoJYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgdmFyKC0tQnV0dG9uU2hhZG93KTsKCWJvcmRlci1ib3R0b206IDFweCBzb2xpZCB2YXIoLS1CdXR0b25TaGFkb3cpOwp9Ci5jb2xvci1zZWxlY3Rpb246YWZ0ZXIgewoJY29udGVudDogJyc7Cglwb3NpdGlvbjogYWJzb2x1dGU7CglsZWZ0OiAwcHg7Cgl0b3A6IDBweDsKCXJpZ2h0OiAwcHg7Cglib3R0b206IDBweDsKCS8qIEBUT0RPOiBCdXR0b25BbHRlcm5hdGVGYWNlPyAqLwoJYm9yZGVyOiAxcHggc29saWQgdmFyKC0tQnV0dG9uRmFjZSk7Cn0KLmN1cnJlbnQtY29sb3JzLAouY29sb3ItYnV0dG9uIHsKCWJvcmRlci10b3A6IDFweCBzb2xpZCB2YXIoLS1CdXR0b25TaGFkb3cpOwoJYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCB2YXIoLS1CdXR0b25TaGFkb3cpOwoJLyogQFRPRE86IHZhcigtLUJ1dHRvbkFsdGVybmF0ZUZhY2UpPyAqLwoJYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgdmFyKC0tQnV0dG9uRmFjZSk7Cglib3JkZXItYm90dG9tOiAxcHggc29saWQgdmFyKC0tQnV0dG9uRmFjZSk7CgkvKmJveC1zaGFkb3c6IDFweCAxcHggMHB4IHZhcigtLUJ1dHRvbkRrU2hhZG93KSBpbnNldDsqLwp9Ci5zd2F0Y2g6YmVmb3JlIHsKCWNvbnRlbnQ6ICcnOwoJcG9zaXRpb246IGFic29sdXRlOwoJbGVmdDogMDsKCXRvcDogMDsKCXJpZ2h0OiAwOwoJYm90dG9tOiAwOwp9Ci5jb2xvci1zZWxlY3Rpb246YmVmb3JlIHsKCWxlZnQ6IDFweDsKCXRvcDogMXB4OwoJcmlnaHQ6IDFweDsKCWJvdHRvbTogMXB4Owp9Ci5jb2xvci1idXR0b246YmVmb3JlLAouY3VycmVudC1jb2xvcnM6YmVmb3JlLAouc3dhdGNoLnBhdHRlcm46YmVmb3JlIHsKCWJvcmRlci1sZWZ0OiAxcHggc29saWQgdmFyKC0tQnV0dG9uRGtTaGFkb3cpOwoJYm9yZGVyLXRvcDogMXB4IHNvbGlkIHZhcigtLUJ1dHRvbkRrU2hhZG93KTsKfQouc3dhdGNoLnBhdHRlcm46YmVmb3JlIHsKCWJvcmRlci1yaWdodDogMXB4IHNvbGlkIHZhcigtLUJ1dHRvbkRrU2hhZG93KTsKCWJvcmRlci1ib3R0b206IDFweCBzb2xpZCB2YXIoLS1CdXR0b25Ea1NoYWRvdyk7Cn0KLmN1cnJlbnQtY29sb3JzOmFmdGVyLAouY29sb3ItYnV0dG9uOmFmdGVyIHsKCWNvbnRlbnQ6ICcnOwoJcG9zaXRpb246IGFic29sdXRlOwoJbGVmdDogLTFweDsKCXRvcDogLTFweDsKCXJpZ2h0OiAtMnB4OwoJYm90dG9tOiAtMnB4OwoJYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgdmFyKC0tQnV0dG9uSGlsaWdodCk7Cglib3JkZXItYm90dG9tOiAxcHggc29saWQgdmFyKC0tQnV0dG9uSGlsaWdodCk7Cn0KCgouY29tcG9uZW50LWdob3N0LmRvY2sgewoJb3V0bGluZTogMXB4IHNvbGlkIGJsYWNrOwoJLypvdXRsaW5lOiAxcHggc29saWQgaW52ZXJ0OyovCn0KLmNvbXBvbmVudC1naG9zdDpub3QoLmRvY2spIHsKCW91dGxpbmU6IDFweCBkb3R0ZWQgYmxhY2s7CgkvKm91dGxpbmU6IDFweCBkb3R0ZWQgaW52ZXJ0OyovCn0KLmNvbXBvbmVudC1naG9zdDpub3QoLmRvY2spOmFmdGVyLAouY29tcG9uZW50LWdob3N0Om5vdCguZG9jayk6YmVmb3JlIHsKCWNvbnRlbnQ6ICcnOwoJcG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAwOyByaWdodDogMDsgdG9wOiAwOyBib3R0b206IDA7CglvdXRsaW5lOiAxcHggZG90dGVkIGJsYWNrOwoJLypvdXRsaW5lOiAxcHggZG90dGVkIGludmVydDsqLwp9Ci5jb21wb25lbnQtZ2hvc3Q6bm90KC5kb2NrKTphZnRlciB7CglvdXRsaW5lLW9mZnNldDogMXB4Owp9Ci5jb21wb25lbnQtZ2hvc3Q6bm90KC5kb2NrKTpiZWZvcmUgewoJb3V0bGluZS1vZmZzZXQ6IDJweDsKfQoKCi50b29sLXdpbmRvdyB7CgliYWNrZ3JvdW5kOiB2YXIoLS1CdXR0b25GYWNlKTsKCWJvcmRlci10b3A6IDFweCBzb2xpZCB2YXIoLS1CdXR0b25MaWdodCk7Cglib3JkZXItbGVmdDogMXB4IHNvbGlkIHZhcigtLUJ1dHRvbkxpZ2h0KTsKCWJvcmRlci1yaWdodDogMXB4IHNvbGlkIHZhcigtLVdpbmRvd0ZyYW1lKTsKCWJvcmRlci1ib3R0b206IDFweCBzb2xpZCB2YXIoLS1XaW5kb3dGcmFtZSk7CglwYWRkaW5nOiAycHg7Cn0KLnRvb2wtd2luZG93OmFmdGVyIHsKCWNvbnRlbnQ6ICcnOwoJcG9pbnRlci1ldmVudHM6IG5vbmU7Cglwb3NpdGlvbjogYWJzb2x1dGU7CglsZWZ0OiAwOwoJdG9wOiAwOwoJcmlnaHQ6IDA7Cglib3R0b206IDA7Cglib3JkZXItdG9wOiAxcHggc29saWQgdmFyKC0tQnV0dG9uSGlsaWdodCk7Cglib3JkZXItbGVmdDogMXB4IHNvbGlkIHZhcigtLUJ1dHRvbkhpbGlnaHQpOwoJYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgdmFyKC0tQnV0dG9uU2hhZG93KTsKCWJvcmRlci1ib3R0b206IDFweCBzb2xpZCB2YXIoLS1CdXR0b25TaGFkb3cpOwp9Ci53aW5kb3cgPiAqIHsKCW1hcmdpbjogMXB4Owp9Ci50b29sLXdpbmRvdyAud2luZG93LXRpdGxlYmFyIHsKCWJhY2tncm91bmQ6IHZhcigtLUFjdGl2ZVRpdGxlKTsgLyogZmFsbGJhY2sgdG8gc3RhbmRhcmQgY29sb3IgKi8KCWJhY2tncm91bmQ6IC1tb3otbGluZWFyLWdyYWRpZW50KGxlZnQsIHZhcigtLUFjdGl2ZVRpdGxlKSAwJSwgdmFyKC0tR3JhZGllbnRBY3RpdmVUaXRsZSkgMTAwJSk7IC8qIEZGMy42KyAqLwoJYmFja2dyb3VuZDogLXdlYmtpdC1ncmFkaWVudChsaW5lYXIsIGxlZnQgdG9wLCByaWdodCB0b3AsIGNvbG9yLXN0b3AoMCUsIHZhcigtLUFjdGl2ZVRpdGxlKSksIGNvbG9yLXN0b3AoMTAwJSwgdmFyKC0tR3JhZGllbnRBY3RpdmVUaXRsZSkpKTsgLyogQ2hyb21lLCBTYWZhcmk0KyAqLwoJYmFja2dyb3VuZDogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQobGVmdCwgdmFyKC0tQWN0aXZlVGl0bGUpIDAlLCB2YXIoLS1HcmFkaWVudEFjdGl2ZVRpdGxlKSAxMDAlKTsgLyogQ2hyb21lMTArLCBTYWZhcmk1LjErICovCgliYWNrZ3JvdW5kOiAtby1saW5lYXItZ3JhZGllbnQobGVmdCwgdmFyKC0tQWN0aXZlVGl0bGUpIDAlLCB2YXIoLS1HcmFkaWVudEFjdGl2ZVRpdGxlKSAxMDAlKTsgLyogT3BlcmEgMTEuMTArICovCgliYWNrZ3JvdW5kOiAtbXMtbGluZWFyLWdyYWRpZW50KGxlZnQsIHZhcigtLUFjdGl2ZVRpdGxlKSAwJSwgdmFyKC0tR3JhZGllbnRBY3RpdmVUaXRsZSkgMTAwJSk7IC8qIElFMTArICovCgliYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsIHZhcigtLUFjdGl2ZVRpdGxlKSAwJSwgdmFyKC0tR3JhZGllbnRBY3RpdmVUaXRsZSkgMTAwJSk7IC8qIFczQyAqLwoKCWNvbG9yOiB2YXIoLS1UaXRsZVRleHQpOwoJZm9udC1mYW1pbHk6ICdTZWdvZSBVSScsIHNhbnMtc2VyaWY7Cglmb250LXNpemU6IDEycHg7CgloZWlnaHQ6IDE1cHg7Cn0KLnRvb2wtd2luZG93IC53aW5kb3ctdGl0bGUgewoJcGFkZGluZy1sZWZ0OiAycHg7Cn0KLnRvb2wtd2luZG93IC53aW5kb3ctY2xvc2UtYnV0dG9uIHsKCXdpZHRoOiAxM3B4OwoJaGVpZ2h0OiAxMXB4OwoJYmFja2dyb3VuZC1wb3NpdGlvbjogOHB4IDA7Cn0KLnRvb2wtd2luZG93IC53aW5kb3ctY2xvc2UtYnV0dG9uOmhvdmVyOmFjdGl2ZSB7CgliYWNrZ3JvdW5kLXBvc2l0aW9uOiA5cHggMXB4Owp9Ci50b29sLXdpbmRvdyAud2luZG93LXRpdGxlYmFyIGJ1dHRvbiB7CgltYXJnaW46IDJweDsKfQoud2luZG93LWNvbnRlbnQgewoJZm9udC1mYW1pbHk6IEFyaWFsLCBzYW5zLXNlcmlmOwoJZm9udC1zaXplOiAxNnB4Owp9CgouaGVscC13aW5kb3cgLml0ZW0gewoJZm9udC1mYW1pbHk6ICdTZWdvZSBVSScsIHNhbnMtc2VyaWY7Cglmb250LXNpemU6IDEycHg7CglwYWRkaW5nOiAwIDJweDsKCXBvc2l0aW9uOiByZWxhdGl2ZTsgLyogZm9yIDo6YWZ0ZXIgKi8KfQouaGVscC13aW5kb3cgLml0ZW06aG92ZXIgewoJdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7Cgljb2xvcjogIzAwMDBGRjsKCWN1cnNvcjogcG9pbnRlcjsKfQouaGVscC13aW5kb3cgbGk6YmVmb3JlIHsKCWJhY2tncm91bmQtaW1hZ2U6IHVybCgiLi4vLi4vaW1hZ2VzL2hlbHAtaWNvbnMucG5nIik7Cn0KLmhlbHAtd2luZG93Om5vdCguZm9jdXNlZCkgLml0ZW0uc2VsZWN0ZWQgewoJYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tQnV0dG9uRmFjZSk7Cgljb2xvcjogdmFyKC0tQnV0dG9uVGV4dCk7IC8qID8/ICovCn0KLmhlbHAtd2luZG93LmZvY3VzZWQgLml0ZW0uc2VsZWN0ZWQgewoJYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tSGlsaWdodCk7Cgljb2xvcjogdmFyKC0tSGlsaWdodFRleHQpOwoJLyogQFRPRE86IHNlcGFyYXRlIGZvY3VzIHN0YXRlIG9mIHRoZSBpdGVtICovCglvdXRsaW5lOiAxcHggZG90dGVkIGJsYWNrOwoJb3V0bGluZS1vZmZzZXQ6IC0xcHg7Cn0KLyogQFRPRE86IHNlcGFyYXRlIGZvY3VzIHN0YXRlIG9mIHRoZSBpdGVtOyB3aGlsZSBtb3VzZSBkb3duLCB0aGUgbWFpbiBoaWdobGlnaHQgZG9lcyBub3QgbW92ZSB3aXRoIHRoZSBhcnJvdyBrZXlzIGJ1dCB0aGlzIGRvZXMsIGFtb25nIG90aGVyIGRpZmZlcmVuY2VzICovCi8qIC5oZWxwLXdpbmRvdy5mb2N1c2VkIC5pdGVtLnNlbGVjdGVkOjphZnRlciB7Cgljb250ZW50OiAiIjsKCXBvc2l0aW9uOiBhYnNvbHV0ZTsKCWxlZnQ6IDA7Cgl0b3A6IDA7CglyaWdodDogMDsKCWJvdHRvbTogMDsKCWJvcmRlcjogMXB4IGRvdHRlZCB3aGl0ZTsKCW1peC1ibGVuZC1tb2RlOiBkaWZmZXJlbmNlOwp9ICovCgppbnB1dFt0eXBlPXRleHRdLAppbnB1dFt0eXBlPXVybF0gewoJLyogQFRPRE86IGZhbmN5IDNkIGluc2V0IGJvcmRlciAobWlnaHQgbmVlZCBhIHN1cnJvdW5kaW5nIGVsZW1lbnQgYmVjYXVzZSBwc2V1ZG8gZWxlbWVudHMgd29uJ3Qgd29yayB3aXRoIGlucHV0KSAqLwoJLyogSSBndWVzcyBhbiBpbWFnZSBib3JkZXIgY291bGQgd29yazsgbWF5YmUgSSBzaG91bGQgYmUgdXNpbmcgKHN2ZykgaW1hZ2UgYm9yZGVycyBmb3Igc3R1ZmYgKi8KCS8qIChjc3MgaW5zZXQgYm9yZGVyIHN0eWxlIGRvZXNuJ3QgbG9vayBnb29kIGFuZCBpc24ndCBjb25zaXN0ZW50IGJldHdlZW4gYnJvd3NlcnMpICovCglib3JkZXI6IDFweCBzb2xpZCBncmF5OwoJYmFja2dyb3VuZDogdmFyKC0tV2luZG93KTsKCWNvbG9yOiB2YXIoLS1XaW5kb3dUZXh0KTsKfQoKaW5wdXRbdHlwZT1udW1iZXJdLm5vLXNwaW5uZXI6Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24sCmlucHV0W3R5cGU9bnVtYmVyXS5uby1zcGlubmVyOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uIHsKCS13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTsKCW1hcmdpbjogMDsKfQppbnB1dFt0eXBlPW51bWJlcl0ubm8tc3Bpbm5lciB7CgktbW96LWFwcGVhcmFuY2U6IHRleHRmaWVsZDsKfQoKaW5wdXQ6aW52YWxpZCB7Cglib3gtc2hhZG93OiAwIDAgMCAycHggcmVkOwp9Ci5wYXJ0aWFsLXVybC1sYWJlbCB7CglvcGFjaXR5OiAwLjY7Cn0KCi5tZW51LXBvcHVwIHRyIC5tZW51LWl0ZW0tbGFiZWwgewoJcGFkZGluZy10b3A6IDRweCAhaW1wb3J0YW50OwoJcGFkZGluZy1ib3R0b206IDRweCAhaW1wb3J0YW50Owp9Cgo6OnNlbGVjdGlvbiB7Cgljb2xvcjogd2hpdGUgIWltcG9ydGFudDsKCWJhY2tncm91bmQtY29sb3I6ICMzMTZhYzUgIWltcG9ydGFudDsKfQ==";
  </script>
  <script>
    (() => {
      const default_theme = "classic.css";
      const theme_storage_key = "jspaint theme";
      const href_for = theme => CLASSIC_THEME_BASE64;

      let current_theme;
      try {
        current_theme = localStorage[theme_storage_key] || default_theme;
      } catch (error) {
        current_theme = default_theme;
      }

      let iid;

      function wait_for_theme_loaded(theme, callback) {
        clearInterval(iid);
        iid = setInterval(() => {
          const theme_loaded =
            getComputedStyle(document.documentElement)
            .getPropertyValue("--theme-loaded")
            .replace(/['"]+/g, "").trim();
          if (theme_loaded === theme) {
            clearInterval(iid);
            callback();
          }
        }, 15);
      }

      const theme_link = document.createElement("link");
      theme_link.rel = "stylesheet";
      theme_link.type = "text/css";
      theme_link.href = href_for(current_theme);
      theme_link.id = "theme-link";
      document.head.appendChild(theme_link);

      window.get_theme = () => current_theme;

      window.set_theme = theme => {
        current_theme = theme;

        try {
          localStorage[theme_storage_key] = theme;
          // eslint-disable-next-line no-empty
        } catch (error) {}

        const signal_theme_load = () => {
          $(window).triggerHandler("theme-load");
          $(window).trigger("resize"); // not exactly, but get dynamic cursor to update its offset
        };

        wait_for_theme_loaded(theme, signal_theme_load);
        theme_link.href = href_for(theme);
        signal_theme_load();
      };
    })();
  </script>
</head>

<body>
  <script>
    /*! jQuery v3.4.1 | (c) JS Foundation and other contributors | jquery.org/license */ ! function(e, t) {
      "use strict";
      "object" == typeof module && "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function(e) {
        if (!e.document) throw new Error("jQuery requires a window with a document");
        return t(e)
      } : t(e)
    }("undefined" != typeof window ? window : this, function(C, e) {
      "use strict";
      var t = [],
        E = C.document,
        r = Object.getPrototypeOf,
        s = t.slice,
        g = t.concat,
        u = t.push,
        i = t.indexOf,
        n = {},
        o = n.toString,
        v = n.hasOwnProperty,
        a = v.toString,
        l = a.call(Object),
        y = {},
        m = function(e) {
          return "function" == typeof e && "number" != typeof e.nodeType
        },
        x = function(e) {
          return null != e && e === e.window
        },
        c = {
          type: !0,
          src: !0,
          nonce: !0,
          noModule: !0
        };

      function b(e, t, n) {
        var r, i, o = (n = n || E).createElement("script");
        if (o.text = e, t)
          for (r in c)(i = t[r] || t.getAttribute && t.getAttribute(r)) && o.setAttribute(r, i);
        n.head.appendChild(o).parentNode.removeChild(o)
      }

      function w(e) {
        return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? n[o.call(e)] || "object" : typeof e
      }
      var f = "3.4.1",
        k = function(e, t) {
          return new k.fn.init(e, t)
        },
        p = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

      function d(e) {
        var t = !!e && "length" in e && e.length,
          n = w(e);
        return !m(e) && !x(e) && ("array" === n || 0 === t || "number" == typeof t && 0 < t && t - 1 in e)
      }
      k.fn = k.prototype = {
        jquery: f,
        constructor: k,
        length: 0,
        toArray: function() {
          return s.call(this)
        },
        get: function(e) {
          return null == e ? s.call(this) : e < 0 ? this[e + this.length] : this[e]
        },
        pushStack: function(e) {
          var t = k.merge(this.constructor(), e);
          return t.prevObject = this, t
        },
        each: function(e) {
          return k.each(this, e)
        },
        map: function(n) {
          return this.pushStack(k.map(this, function(e, t) {
            return n.call(e, t, e)
          }))
        },
        slice: function() {
          return this.pushStack(s.apply(this, arguments))
        },
        first: function() {
          return this.eq(0)
        },
        last: function() {
          return this.eq(-1)
        },
        eq: function(e) {
          var t = this.length,
            n = +e + (e < 0 ? t : 0);
          return this.pushStack(0 <= n && n < t ? [this[n]] : [])
        },
        end: function() {
          return this.prevObject || this.constructor()
        },
        push: u,
        sort: t.sort,
        splice: t.splice
      }, k.extend = k.fn.extend = function() {
        var e, t, n, r, i, o, a = arguments[0] || {},
          s = 1,
          u = arguments.length,
          l = !1;
        for ("boolean" == typeof a && (l = a, a = arguments[s] || {}, s++), "object" == typeof a || m(a) || (a = {}), s === u && (a = this, s--); s < u; s++)
          if (null != (e = arguments[s]))
            for (t in e) r = e[t], "__proto__" !== t && a !== r && (l && r && (k.isPlainObject(r) || (i = Array.isArray(r))) ? (n = a[t], o = i && !Array.isArray(n) ? [] : i || k.isPlainObject(n) ? n : {}, i = !1, a[t] = k.extend(l, o, r)) : void 0 !== r && (a[t] = r));
        return a
      }, k.extend({
        expando: "jQuery" + (f + Math.random()).replace(/\D/g, ""),
        isReady: !0,
        error: function(e) {
          throw new Error(e)
        },
        noop: function() {},
        isPlainObject: function(e) {
          var t, n;
          return !(!e || "[object Object]" !== o.call(e)) && (!(t = r(e)) || "function" == typeof(n = v.call(t, "constructor") && t.constructor) && a.call(n) === l)
        },
        isEmptyObject: function(e) {
          var t;
          for (t in e) return !1;
          return !0
        },
        globalEval: function(e, t) {
          b(e, {
            nonce: t && t.nonce
          })
        },
        each: function(e, t) {
          var n, r = 0;
          if (d(e)) {
            for (n = e.length; r < n; r++)
              if (!1 === t.call(e[r], r, e[r])) break
          } else
            for (r in e)
              if (!1 === t.call(e[r], r, e[r])) break;
          return e
        },
        trim: function(e) {
          return null == e ? "" : (e + "").replace(p, "")
        },
        makeArray: function(e, t) {
          var n = t || [];
          return null != e && (d(Object(e)) ? k.merge(n, "string" == typeof e ? [e] : e) : u.call(n, e)), n
        },
        inArray: function(e, t, n) {
          return null == t ? -1 : i.call(t, e, n)
        },
        merge: function(e, t) {
          for (var n = +t.length, r = 0, i = e.length; r < n; r++) e[i++] = t[r];
          return e.length = i, e
        },
        grep: function(e, t, n) {
          for (var r = [], i = 0, o = e.length, a = !n; i < o; i++) !t(e[i], i) !== a && r.push(e[i]);
          return r
        },
        map: function(e, t, n) {
          var r, i, o = 0,
            a = [];
          if (d(e))
            for (r = e.length; o < r; o++) null != (i = t(e[o], o, n)) && a.push(i);
          else
            for (o in e) null != (i = t(e[o], o, n)) && a.push(i);
          return g.apply([], a)
        },
        guid: 1,
        support: y
      }), "function" == typeof Symbol && (k.fn[Symbol.iterator] = t[Symbol.iterator]), k.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(e, t) {
        n["[object " + t + "]"] = t.toLowerCase()
      });
      var h = function(n) {
        var e, d, b, o, i, h, f, g, w, u, l, T, C, a, E, v, s, c, y, k = "sizzle" + 1 * new Date,
          m = n.document,
          S = 0,
          r = 0,
          p = ue(),
          x = ue(),
          N = ue(),
          A = ue(),
          D = function(e, t) {
            return e === t && (l = !0), 0
          },
          j = {}.hasOwnProperty,
          t = [],
          q = t.pop,
          L = t.push,
          H = t.push,
          O = t.slice,
          P = function(e, t) {
            for (var n = 0, r = e.length; n < r; n++)
              if (e[n] === t) return n;
            return -1
          },
          R = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
          M = "[\\x20\\t\\r\\n\\f]",
          I = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
          W = "\\[" + M + "*(" + I + ")(?:" + M + "*([*^$|!~]?=)" + M + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + I + "))|)" + M + "*\\]",
          $ = ":(" + I + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + W + ")*)|.*)\\)|)",
          F = new RegExp(M + "+", "g"),
          B = new RegExp("^" + M + "+|((?:^|[^\\\\])(?:\\\\.)*)" + M + "+$", "g"),
          _ = new RegExp("^" + M + "*," + M + "*"),
          z = new RegExp("^" + M + "*([>+~]|" + M + ")" + M + "*"),
          U = new RegExp(M + "|>"),
          X = new RegExp($),
          V = new RegExp("^" + I + "$"),
          G = {
            ID: new RegExp("^#(" + I + ")"),
            CLASS: new RegExp("^\\.(" + I + ")"),
            TAG: new RegExp("^(" + I + "|[*])"),
            ATTR: new RegExp("^" + W),
            PSEUDO: new RegExp("^" + $),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + M + "*(even|odd|(([+-]|)(\\d*)n|)" + M + "*(?:([+-]|)" + M + "*(\\d+)|))" + M + "*\\)|)", "i"),
            bool: new RegExp("^(?:" + R + ")$", "i"),
            needsContext: new RegExp("^" + M + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + M + "*((?:-\\d)?\\d*)" + M + "*\\)|)(?=[^-]|$)", "i")
          },
          Y = /HTML$/i,
          Q = /^(?:input|select|textarea|button)$/i,
          J = /^h\d$/i,
          K = /^[^{]+\{\s*\[native \w/,
          Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
          ee = /[+~]/,
          te = new RegExp("\\\\([\\da-f]{1,6}" + M + "?|(" + M + ")|.)", "ig"),
          ne = function(e, t, n) {
            var r = "0x" + t - 65536;
            return r != r || n ? t : r < 0 ? String.fromCharCode(r + 65536) : String.fromCharCode(r >> 10 | 55296, 1023 & r | 56320)
          },
          re = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
          ie = function(e, t) {
            return t ? "\0" === e ? "\ufffd" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e
          },
          oe = function() {
            T()
          },
          ae = be(function(e) {
            return !0 === e.disabled && "fieldset" === e.nodeName.toLowerCase()
          }, {
            dir: "parentNode",
            next: "legend"
          });
        try {
          H.apply(t = O.call(m.childNodes), m.childNodes), t[m.childNodes.length].nodeType
        } catch (e) {
          H = {
            apply: t.length ? function(e, t) {
              L.apply(e, O.call(t))
            } : function(e, t) {
              var n = e.length,
                r = 0;
              while (e[n++] = t[r++]);
              e.length = n - 1
            }
          }
        }

        function se(t, e, n, r) {
          var i, o, a, s, u, l, c, f = e && e.ownerDocument,
            p = e ? e.nodeType : 9;
          if (n = n || [], "string" != typeof t || !t || 1 !== p && 9 !== p && 11 !== p) return n;
          if (!r && ((e ? e.ownerDocument || e : m) !== C && T(e), e = e || C, E)) {
            if (11 !== p && (u = Z.exec(t)))
              if (i = u[1]) {
                if (9 === p) {
                  if (!(a = e.getElementById(i))) return n;
                  if (a.id === i) return n.push(a), n
                } else if (f && (a = f.getElementById(i)) && y(e, a) && a.id === i) return n.push(a), n
              } else {
                if (u[2]) return H.apply(n, e.getElementsByTagName(t)), n;
                if ((i = u[3]) && d.getElementsByClassName && e.getElementsByClassName) return H.apply(n, e.getElementsByClassName(i)), n
              } if (d.qsa && !A[t + " "] && (!v || !v.test(t)) && (1 !== p || "object" !== e.nodeName.toLowerCase())) {
              if (c = t, f = e, 1 === p && U.test(t)) {
                (s = e.getAttribute("id")) ? s = s.replace(re, ie): e.setAttribute("id", s = k), o = (l = h(t)).length;
                while (o--) l[o] = "#" + s + " " + xe(l[o]);
                c = l.join(","), f = ee.test(t) && ye(e.parentNode) || e
              }
              try {
                return H.apply(n, f.querySelectorAll(c)), n
              } catch (e) {
                A(t, !0)
              } finally {
                s === k && e.removeAttribute("id")
              }
            }
          }
          return g(t.replace(B, "$1"), e, n, r)
        }

        function ue() {
          var r = [];
          return function e(t, n) {
            return r.push(t + " ") > b.cacheLength && delete e[r.shift()], e[t + " "] = n
          }
        }

        function le(e) {
          return e[k] = !0, e
        }

        function ce(e) {
          var t = C.createElement("fieldset");
          try {
            return !!e(t)
          } catch (e) {
            return !1
          } finally {
            t.parentNode && t.parentNode.removeChild(t), t = null
          }
        }

        function fe(e, t) {
          var n = e.split("|"),
            r = n.length;
          while (r--) b.attrHandle[n[r]] = t
        }

        function pe(e, t) {
          var n = t && e,
            r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex;
          if (r) return r;
          if (n)
            while (n = n.nextSibling)
              if (n === t) return -1;
          return e ? 1 : -1
        }

        function de(t) {
          return function(e) {
            return "input" === e.nodeName.toLowerCase() && e.type === t
          }
        }

        function he(n) {
          return function(e) {
            var t = e.nodeName.toLowerCase();
            return ("input" === t || "button" === t) && e.type === n
          }
        }

        function ge(t) {
          return function(e) {
            return "form" in e ? e.parentNode && !1 === e.disabled ? "label" in e ? "label" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && ae(e) === t : e.disabled === t : "label" in e && e.disabled === t
          }
        }

        function ve(a) {
          return le(function(o) {
            return o = +o, le(function(e, t) {
              var n, r = a([], e.length, o),
                i = r.length;
              while (i--) e[n = r[i]] && (e[n] = !(t[n] = e[n]))
            })
          })
        }

        function ye(e) {
          return e && "undefined" != typeof e.getElementsByTagName && e
        }
        for (e in d = se.support = {}, i = se.isXML = function(e) {
            var t = e.namespaceURI,
              n = (e.ownerDocument || e).documentElement;
            return !Y.test(t || n && n.nodeName || "HTML")
          }, T = se.setDocument = function(e) {
            var t, n, r = e ? e.ownerDocument || e : m;
            return r !== C && 9 === r.nodeType && r.documentElement && (a = (C = r).documentElement, E = !i(C), m !== C && (n = C.defaultView) && n.top !== n && (n.addEventListener ? n.addEventListener("unload", oe, !1) : n.attachEvent && n.attachEvent("onunload", oe)), d.attributes = ce(function(e) {
              return e.className = "i", !e.getAttribute("className")
            }), d.getElementsByTagName = ce(function(e) {
              return e.appendChild(C.createComment("")), !e.getElementsByTagName("*").length
            }), d.getElementsByClassName = K.test(C.getElementsByClassName), d.getById = ce(function(e) {
              return a.appendChild(e).id = k, !C.getElementsByName || !C.getElementsByName(k).length
            }), d.getById ? (b.filter.ID = function(e) {
              var t = e.replace(te, ne);
              return function(e) {
                return e.getAttribute("id") === t
              }
            }, b.find.ID = function(e, t) {
              if ("undefined" != typeof t.getElementById && E) {
                var n = t.getElementById(e);
                return n ? [n] : []
              }
            }) : (b.filter.ID = function(e) {
              var n = e.replace(te, ne);
              return function(e) {
                var t = "undefined" != typeof e.getAttributeNode && e.getAttributeNode("id");
                return t && t.value === n
              }
            }, b.find.ID = function(e, t) {
              if ("undefined" != typeof t.getElementById && E) {
                var n, r, i, o = t.getElementById(e);
                if (o) {
                  if ((n = o.getAttributeNode("id")) && n.value === e) return [o];
                  i = t.getElementsByName(e), r = 0;
                  while (o = i[r++])
                    if ((n = o.getAttributeNode("id")) && n.value === e) return [o]
                }
                return []
              }
            }), b.find.TAG = d.getElementsByTagName ? function(e, t) {
              return "undefined" != typeof t.getElementsByTagName ? t.getElementsByTagName(e) : d.qsa ? t.querySelectorAll(e) : void 0
            } : function(e, t) {
              var n, r = [],
                i = 0,
                o = t.getElementsByTagName(e);
              if ("*" === e) {
                while (n = o[i++]) 1 === n.nodeType && r.push(n);
                return r
              }
              return o
            }, b.find.CLASS = d.getElementsByClassName && function(e, t) {
              if ("undefined" != typeof t.getElementsByClassName && E) return t.getElementsByClassName(e)
            }, s = [], v = [], (d.qsa = K.test(C.querySelectorAll)) && (ce(function(e) {
              a.appendChild(e).innerHTML = "<a id='" + k + "'></a><select id='" + k + "-\r\\' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && v.push("[*^$]=" + M + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || v.push("\\[" + M + "*(?:value|" + R + ")"), e.querySelectorAll("[id~=" + k + "-]").length || v.push("~="), e.querySelectorAll(":checked").length || v.push(":checked"), e.querySelectorAll("a#" + k + "+*").length || v.push(".#.+[+~]")
            }), ce(function(e) {
              e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
              var t = C.createElement("input");
              t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && v.push("name" + M + "*[*^$|!~]?="), 2 !== e.querySelectorAll(":enabled").length && v.push(":enabled", ":disabled"), a.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && v.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), v.push(",.*:")
            })), (d.matchesSelector = K.test(c = a.matches || a.webkitMatchesSelector || a.mozMatchesSelector || a.oMatchesSelector || a.msMatchesSelector)) && ce(function(e) {
              d.disconnectedMatch = c.call(e, "*"), c.call(e, "[s!='']:x"), s.push("!=", $)
            }), v = v.length && new RegExp(v.join("|")), s = s.length && new RegExp(s.join("|")), t = K.test(a.compareDocumentPosition), y = t || K.test(a.contains) ? function(e, t) {
              var n = 9 === e.nodeType ? e.documentElement : e,
                r = t && t.parentNode;
              return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r)))
            } : function(e, t) {
              if (t)
                while (t = t.parentNode)
                  if (t === e) return !0;
              return !1
            }, D = t ? function(e, t) {
              if (e === t) return l = !0, 0;
              var n = !e.compareDocumentPosition - !t.compareDocumentPosition;
              return n || (1 & (n = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !d.sortDetached && t.compareDocumentPosition(e) === n ? e === C || e.ownerDocument === m && y(m, e) ? -1 : t === C || t.ownerDocument === m && y(m, t) ? 1 : u ? P(u, e) - P(u, t) : 0 : 4 & n ? -1 : 1)
            } : function(e, t) {
              if (e === t) return l = !0, 0;
              var n, r = 0,
                i = e.parentNode,
                o = t.parentNode,
                a = [e],
                s = [t];
              if (!i || !o) return e === C ? -1 : t === C ? 1 : i ? -1 : o ? 1 : u ? P(u, e) - P(u, t) : 0;
              if (i === o) return pe(e, t);
              n = e;
              while (n = n.parentNode) a.unshift(n);
              n = t;
              while (n = n.parentNode) s.unshift(n);
              while (a[r] === s[r]) r++;
              return r ? pe(a[r], s[r]) : a[r] === m ? -1 : s[r] === m ? 1 : 0
            }), C
          }, se.matches = function(e, t) {
            return se(e, null, null, t)
          }, se.matchesSelector = function(e, t) {
            if ((e.ownerDocument || e) !== C && T(e), d.matchesSelector && E && !A[t + " "] && (!s || !s.test(t)) && (!v || !v.test(t))) try {
              var n = c.call(e, t);
              if (n || d.disconnectedMatch || e.document && 11 !== e.document.nodeType) return n
            } catch (e) {
              A(t, !0)
            }
            return 0 < se(t, C, null, [e]).length
          }, se.contains = function(e, t) {
            return (e.ownerDocument || e) !== C && T(e), y(e, t)
          }, se.attr = function(e, t) {
            (e.ownerDocument || e) !== C && T(e);
            var n = b.attrHandle[t.toLowerCase()],
              r = n && j.call(b.attrHandle, t.toLowerCase()) ? n(e, t, !E) : void 0;
            return void 0 !== r ? r : d.attributes || !E ? e.getAttribute(t) : (r = e.getAttributeNode(t)) && r.specified ? r.value : null
          }, se.escape = function(e) {
            return (e + "").replace(re, ie)
          }, se.error = function(e) {
            throw new Error("Syntax error, unrecognized expression: " + e)
          }, se.uniqueSort = function(e) {
            var t, n = [],
              r = 0,
              i = 0;
            if (l = !d.detectDuplicates, u = !d.sortStable && e.slice(0), e.sort(D), l) {
              while (t = e[i++]) t === e[i] && (r = n.push(i));
              while (r--) e.splice(n[r], 1)
            }
            return u = null, e
          }, o = se.getText = function(e) {
            var t, n = "",
              r = 0,
              i = e.nodeType;
            if (i) {
              if (1 === i || 9 === i || 11 === i) {
                if ("string" == typeof e.textContent) return e.textContent;
                for (e = e.firstChild; e; e = e.nextSibling) n += o(e)
              } else if (3 === i || 4 === i) return e.nodeValue
            } else
              while (t = e[r++]) n += o(t);
            return n
          }, (b = se.selectors = {
            cacheLength: 50,
            createPseudo: le,
            match: G,
            attrHandle: {},
            find: {},
            relative: {
              ">": {
                dir: "parentNode",
                first: !0
              },
              " ": {
                dir: "parentNode"
              },
              "+": {
                dir: "previousSibling",
                first: !0
              },
              "~": {
                dir: "previousSibling"
              }
            },
            preFilter: {
              ATTR: function(e) {
                return e[1] = e[1].replace(te, ne), e[3] = (e[3] || e[4] || e[5] || "").replace(te, ne), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4)
              },
              CHILD: function(e) {
                return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || se.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && se.error(e[0]), e
              },
              PSEUDO: function(e) {
                var t, n = !e[6] && e[2];
                return G.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && X.test(n) && (t = h(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3))
              }
            },
            filter: {
              TAG: function(e) {
                var t = e.replace(te, ne).toLowerCase();
                return "*" === e ? function() {
                  return !0
                } : function(e) {
                  return e.nodeName && e.nodeName.toLowerCase() === t
                }
              },
              CLASS: function(e) {
                var t = p[e + " "];
                return t || (t = new RegExp("(^|" + M + ")" + e + "(" + M + "|$)")) && p(e, function(e) {
                  return t.test("string" == typeof e.className && e.className || "undefined" != typeof e.getAttribute && e.getAttribute("class") || "")
                })
              },
              ATTR: function(n, r, i) {
                return function(e) {
                  var t = se.attr(e, n);
                  return null == t ? "!=" === r : !r || (t += "", "=" === r ? t === i : "!=" === r ? t !== i : "^=" === r ? i && 0 === t.indexOf(i) : "*=" === r ? i && -1 < t.indexOf(i) : "$=" === r ? i && t.slice(-i.length) === i : "~=" === r ? -1 < (" " + t.replace(F, " ") + " ").indexOf(i) : "|=" === r && (t === i || t.slice(0, i.length + 1) === i + "-"))
                }
              },
              CHILD: function(h, e, t, g, v) {
                var y = "nth" !== h.slice(0, 3),
                  m = "last" !== h.slice(-4),
                  x = "of-type" === e;
                return 1 === g && 0 === v ? function(e) {
                  return !!e.parentNode
                } : function(e, t, n) {
                  var r, i, o, a, s, u, l = y !== m ? "nextSibling" : "previousSibling",
                    c = e.parentNode,
                    f = x && e.nodeName.toLowerCase(),
                    p = !n && !x,
                    d = !1;
                  if (c) {
                    if (y) {
                      while (l) {
                        a = e;
                        while (a = a[l])
                          if (x ? a.nodeName.toLowerCase() === f : 1 === a.nodeType) return !1;
                        u = l = "only" === h && !u && "nextSibling"
                      }
                      return !0
                    }
                    if (u = [m ? c.firstChild : c.lastChild], m && p) {
                      d = (s = (r = (i = (o = (a = c)[k] || (a[k] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] || [])[0] === S && r[1]) && r[2], a = s && c.childNodes[s];
                      while (a = ++s && a && a[l] || (d = s = 0) || u.pop())
                        if (1 === a.nodeType && ++d && a === e) {
                          i[h] = [S, s, d];
                          break
                        }
                    } else if (p && (d = s = (r = (i = (o = (a = e)[k] || (a[k] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] || [])[0] === S && r[1]), !1 === d)
                      while (a = ++s && a && a[l] || (d = s = 0) || u.pop())
                        if ((x ? a.nodeName.toLowerCase() === f : 1 === a.nodeType) && ++d && (p && ((i = (o = a[k] || (a[k] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] = [S, d]), a === e)) break;
                    return (d -= v) === g || d % g == 0 && 0 <= d / g
                  }
                }
              },
              PSEUDO: function(e, o) {
                var t, a = b.pseudos[e] || b.setFilters[e.toLowerCase()] || se.error("unsupported pseudo: " + e);
                return a[k] ? a(o) : 1 < a.length ? (t = [e, e, "", o], b.setFilters.hasOwnProperty(e.toLowerCase()) ? le(function(e, t) {
                  var n, r = a(e, o),
                    i = r.length;
                  while (i--) e[n = P(e, r[i])] = !(t[n] = r[i])
                }) : function(e) {
                  return a(e, 0, t)
                }) : a
              }
            },
            pseudos: {
              not: le(function(e) {
                var r = [],
                  i = [],
                  s = f(e.replace(B, "$1"));
                return s[k] ? le(function(e, t, n, r) {
                  var i, o = s(e, null, r, []),
                    a = e.length;
                  while (a--)(i = o[a]) && (e[a] = !(t[a] = i))
                }) : function(e, t, n) {
                  return r[0] = e, s(r, null, n, i), r[0] = null, !i.pop()
                }
              }),
              has: le(function(t) {
                return function(e) {
                  return 0 < se(t, e).length
                }
              }),
              contains: le(function(t) {
                return t = t.replace(te, ne),
                  function(e) {
                    return -1 < (e.textContent || o(e)).indexOf(t)
                  }
              }),
              lang: le(function(n) {
                return V.test(n || "") || se.error("unsupported lang: " + n), n = n.replace(te, ne).toLowerCase(),
                  function(e) {
                    var t;
                    do {
                      if (t = E ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang")) return (t = t.toLowerCase()) === n || 0 === t.indexOf(n + "-")
                    } while ((e = e.parentNode) && 1 === e.nodeType);
                    return !1
                  }
              }),
              target: function(e) {
                var t = n.location && n.location.hash;
                return t && t.slice(1) === e.id
              },
              root: function(e) {
                return e === a
              },
              focus: function(e) {
                return e === C.activeElement && (!C.hasFocus || C.hasFocus()) && !!(e.type || e.href || ~e.tabIndex)
              },
              enabled: ge(!1),
              disabled: ge(!0),
              checked: function(e) {
                var t = e.nodeName.toLowerCase();
                return "input" === t && !!e.checked || "option" === t && !!e.selected
              },
              selected: function(e) {
                return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected
              },
              empty: function(e) {
                for (e = e.firstChild; e; e = e.nextSibling)
                  if (e.nodeType < 6) return !1;
                return !0
              },
              parent: function(e) {
                return !b.pseudos.empty(e)
              },
              header: function(e) {
                return J.test(e.nodeName)
              },
              input: function(e) {
                return Q.test(e.nodeName)
              },
              button: function(e) {
                var t = e.nodeName.toLowerCase();
                return "input" === t && "button" === e.type || "button" === t
              },
              text: function(e) {
                var t;
                return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase())
              },
              first: ve(function() {
                return [0]
              }),
              last: ve(function(e, t) {
                return [t - 1]
              }),
              eq: ve(function(e, t, n) {
                return [n < 0 ? n + t : n]
              }),
              even: ve(function(e, t) {
                for (var n = 0; n < t; n += 2) e.push(n);
                return e
              }),
              odd: ve(function(e, t) {
                for (var n = 1; n < t; n += 2) e.push(n);
                return e
              }),
              lt: ve(function(e, t, n) {
                for (var r = n < 0 ? n + t : t < n ? t : n; 0 <= --r;) e.push(r);
                return e
              }),
              gt: ve(function(e, t, n) {
                for (var r = n < 0 ? n + t : n; ++r < t;) e.push(r);
                return e
              })
            }
          }).pseudos.nth = b.pseudos.eq, {
            radio: !0,
            checkbox: !0,
            file: !0,
            password: !0,
            image: !0
          }) b.pseudos[e] = de(e);
        for (e in {
            submit: !0,
            reset: !0
          }) b.pseudos[e] = he(e);

        function me() {}

        function xe(e) {
          for (var t = 0, n = e.length, r = ""; t < n; t++) r += e[t].value;
          return r
        }

        function be(s, e, t) {
          var u = e.dir,
            l = e.next,
            c = l || u,
            f = t && "parentNode" === c,
            p = r++;
          return e.first ? function(e, t, n) {
            while (e = e[u])
              if (1 === e.nodeType || f) return s(e, t, n);
            return !1
          } : function(e, t, n) {
            var r, i, o, a = [S, p];
            if (n) {
              while (e = e[u])
                if ((1 === e.nodeType || f) && s(e, t, n)) return !0
            } else
              while (e = e[u])
                if (1 === e.nodeType || f)
                  if (i = (o = e[k] || (e[k] = {}))[e.uniqueID] || (o[e.uniqueID] = {}), l && l === e.nodeName.toLowerCase()) e = e[u] || e;
                  else {
                    if ((r = i[c]) && r[0] === S && r[1] === p) return a[2] = r[2];
                    if ((i[c] = a)[2] = s(e, t, n)) return !0
                  } return !1
          }
        }

        function we(i) {
          return 1 < i.length ? function(e, t, n) {
            var r = i.length;
            while (r--)
              if (!i[r](e, t, n)) return !1;
            return !0
          } : i[0]
        }

        function Te(e, t, n, r, i) {
          for (var o, a = [], s = 0, u = e.length, l = null != t; s < u; s++)(o = e[s]) && (n && !n(o, r, i) || (a.push(o), l && t.push(s)));
          return a
        }

        function Ce(d, h, g, v, y, e) {
          return v && !v[k] && (v = Ce(v)), y && !y[k] && (y = Ce(y, e)), le(function(e, t, n, r) {
            var i, o, a, s = [],
              u = [],
              l = t.length,
              c = e || function(e, t, n) {
                for (var r = 0, i = t.length; r < i; r++) se(e, t[r], n);
                return n
              }(h || "*", n.nodeType ? [n] : n, []),
              f = !d || !e && h ? c : Te(c, s, d, n, r),
              p = g ? y || (e ? d : l || v) ? [] : t : f;
            if (g && g(f, p, n, r), v) {
              i = Te(p, u), v(i, [], n, r), o = i.length;
              while (o--)(a = i[o]) && (p[u[o]] = !(f[u[o]] = a))
            }
            if (e) {
              if (y || d) {
                if (y) {
                  i = [], o = p.length;
                  while (o--)(a = p[o]) && i.push(f[o] = a);
                  y(null, p = [], i, r)
                }
                o = p.length;
                while (o--)(a = p[o]) && -1 < (i = y ? P(e, a) : s[o]) && (e[i] = !(t[i] = a))
              }
            } else p = Te(p === t ? p.splice(l, p.length) : p), y ? y(null, t, p, r) : H.apply(t, p)
          })
        }

        function Ee(e) {
          for (var i, t, n, r = e.length, o = b.relative[e[0].type], a = o || b.relative[" "], s = o ? 1 : 0, u = be(function(e) {
              return e === i
            }, a, !0), l = be(function(e) {
              return -1 < P(i, e)
            }, a, !0), c = [function(e, t, n) {
              var r = !o && (n || t !== w) || ((i = t).nodeType ? u(e, t, n) : l(e, t, n));
              return i = null, r
            }]; s < r; s++)
            if (t = b.relative[e[s].type]) c = [be(we(c), t)];
            else {
              if ((t = b.filter[e[s].type].apply(null, e[s].matches))[k]) {
                for (n = ++s; n < r; n++)
                  if (b.relative[e[n].type]) break;
                return Ce(1 < s && we(c), 1 < s && xe(e.slice(0, s - 1).concat({
                  value: " " === e[s - 2].type ? "*" : ""
                })).replace(B, "$1"), t, s < n && Ee(e.slice(s, n)), n < r && Ee(e = e.slice(n)), n < r && xe(e))
              }
              c.push(t)
            } return we(c)
        }
        return me.prototype = b.filters = b.pseudos, b.setFilters = new me, h = se.tokenize = function(e, t) {
          var n, r, i, o, a, s, u, l = x[e + " "];
          if (l) return t ? 0 : l.slice(0);
          a = e, s = [], u = b.preFilter;
          while (a) {
            for (o in n && !(r = _.exec(a)) || (r && (a = a.slice(r[0].length) || a), s.push(i = [])), n = !1, (r = z.exec(a)) && (n = r.shift(), i.push({
                value: n,
                type: r[0].replace(B, " ")
              }), a = a.slice(n.length)), b.filter) !(r = G[o].exec(a)) || u[o] && !(r = u[o](r)) || (n = r.shift(), i.push({
              value: n,
              type: o,
              matches: r
            }), a = a.slice(n.length));
            if (!n) break
          }
          return t ? a.length : a ? se.error(e) : x(e, s).slice(0)
        }, f = se.compile = function(e, t) {
          var n, v, y, m, x, r, i = [],
            o = [],
            a = N[e + " "];
          if (!a) {
            t || (t = h(e)), n = t.length;
            while (n--)(a = Ee(t[n]))[k] ? i.push(a) : o.push(a);
            (a = N(e, (v = o, m = 0 < (y = i).length, x = 0 < v.length, r = function(e, t, n, r, i) {
              var o, a, s, u = 0,
                l = "0",
                c = e && [],
                f = [],
                p = w,
                d = e || x && b.find.TAG("*", i),
                h = S += null == p ? 1 : Math.random() || .1,
                g = d.length;
              for (i && (w = t === C || t || i); l !== g && null != (o = d[l]); l++) {
                if (x && o) {
                  a = 0, t || o.ownerDocument === C || (T(o), n = !E);
                  while (s = v[a++])
                    if (s(o, t || C, n)) {
                      r.push(o);
                      break
                    } i && (S = h)
                }
                m && ((o = !s && o) && u--, e && c.push(o))
              }
              if (u += l, m && l !== u) {
                a = 0;
                while (s = y[a++]) s(c, f, t, n);
                if (e) {
                  if (0 < u)
                    while (l--) c[l] || f[l] || (f[l] = q.call(r));
                  f = Te(f)
                }
                H.apply(r, f), i && !e && 0 < f.length && 1 < u + y.length && se.uniqueSort(r)
              }
              return i && (S = h, w = p), c
            }, m ? le(r) : r))).selector = e
          }
          return a
        }, g = se.select = function(e, t, n, r) {
          var i, o, a, s, u, l = "function" == typeof e && e,
            c = !r && h(e = l.selector || e);
          if (n = n || [], 1 === c.length) {
            if (2 < (o = c[0] = c[0].slice(0)).length && "ID" === (a = o[0]).type && 9 === t.nodeType && E && b.relative[o[1].type]) {
              if (!(t = (b.find.ID(a.matches[0].replace(te, ne), t) || [])[0])) return n;
              l && (t = t.parentNode), e = e.slice(o.shift().value.length)
            }
            i = G.needsContext.test(e) ? 0 : o.length;
            while (i--) {
              if (a = o[i], b.relative[s = a.type]) break;
              if ((u = b.find[s]) && (r = u(a.matches[0].replace(te, ne), ee.test(o[0].type) && ye(t.parentNode) || t))) {
                if (o.splice(i, 1), !(e = r.length && xe(o))) return H.apply(n, r), n;
                break
              }
            }
          }
          return (l || f(e, c))(r, t, !E, n, !t || ee.test(e) && ye(t.parentNode) || t), n
        }, d.sortStable = k.split("").sort(D).join("") === k, d.detectDuplicates = !!l, T(), d.sortDetached = ce(function(e) {
          return 1 & e.compareDocumentPosition(C.createElement("fieldset"))
        }), ce(function(e) {
          return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href")
        }) || fe("type|href|height|width", function(e, t, n) {
          if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2)
        }), d.attributes && ce(function(e) {
          return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value")
        }) || fe("value", function(e, t, n) {
          if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue
        }), ce(function(e) {
          return null == e.getAttribute("disabled")
        }) || fe(R, function(e, t, n) {
          var r;
          if (!n) return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null
        }), se
      }(C);
      k.find = h, k.expr = h.selectors, k.expr[":"] = k.expr.pseudos, k.uniqueSort = k.unique = h.uniqueSort, k.text = h.getText, k.isXMLDoc = h.isXML, k.contains = h.contains, k.escapeSelector = h.escape;
      var T = function(e, t, n) {
          var r = [],
            i = void 0 !== n;
          while ((e = e[t]) && 9 !== e.nodeType)
            if (1 === e.nodeType) {
              if (i && k(e).is(n)) break;
              r.push(e)
            } return r
        },
        S = function(e, t) {
          for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && n.push(e);
          return n
        },
        N = k.expr.match.needsContext;

      function A(e, t) {
        return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()
      }
      var D = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

      function j(e, n, r) {
        return m(n) ? k.grep(e, function(e, t) {
          return !!n.call(e, t, e) !== r
        }) : n.nodeType ? k.grep(e, function(e) {
          return e === n !== r
        }) : "string" != typeof n ? k.grep(e, function(e) {
          return -1 < i.call(n, e) !== r
        }) : k.filter(n, e, r)
      }
      k.filter = function(e, t, n) {
        var r = t[0];
        return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? k.find.matchesSelector(r, e) ? [r] : [] : k.find.matches(e, k.grep(t, function(e) {
          return 1 === e.nodeType
        }))
      }, k.fn.extend({
        find: function(e) {
          var t, n, r = this.length,
            i = this;
          if ("string" != typeof e) return this.pushStack(k(e).filter(function() {
            for (t = 0; t < r; t++)
              if (k.contains(i[t], this)) return !0
          }));
          for (n = this.pushStack([]), t = 0; t < r; t++) k.find(e, i[t], n);
          return 1 < r ? k.uniqueSort(n) : n
        },
        filter: function(e) {
          return this.pushStack(j(this, e || [], !1))
        },
        not: function(e) {
          return this.pushStack(j(this, e || [], !0))
        },
        is: function(e) {
          return !!j(this, "string" == typeof e && N.test(e) ? k(e) : e || [], !1).length
        }
      });
      var q, L = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
      (k.fn.init = function(e, t, n) {
        var r, i;
        if (!e) return this;
        if (n = n || q, "string" == typeof e) {
          if (!(r = "<" === e[0] && ">" === e[e.length - 1] && 3 <= e.length ? [null, e, null] : L.exec(e)) || !r[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e);
          if (r[1]) {
            if (t = t instanceof k ? t[0] : t, k.merge(this, k.parseHTML(r[1], t && t.nodeType ? t.ownerDocument || t : E, !0)), D.test(r[1]) && k.isPlainObject(t))
              for (r in t) m(this[r]) ? this[r](t[r]) : this.attr(r, t[r]);
            return this
          }
          return (i = E.getElementById(r[2])) && (this[0] = i, this.length = 1), this
        }
        return e.nodeType ? (this[0] = e, this.length = 1, this) : m(e) ? void 0 !== n.ready ? n.ready(e) : e(k) : k.makeArray(e, this)
      }).prototype = k.fn, q = k(E);
      var H = /^(?:parents|prev(?:Until|All))/,
        O = {
          children: !0,
          contents: !0,
          next: !0,
          prev: !0
        };

      function P(e, t) {
        while ((e = e[t]) && 1 !== e.nodeType);
        return e
      }
      k.fn.extend({
        has: function(e) {
          var t = k(e, this),
            n = t.length;
          return this.filter(function() {
            for (var e = 0; e < n; e++)
              if (k.contains(this, t[e])) return !0
          })
        },
        closest: function(e, t) {
          var n, r = 0,
            i = this.length,
            o = [],
            a = "string" != typeof e && k(e);
          if (!N.test(e))
            for (; r < i; r++)
              for (n = this[r]; n && n !== t; n = n.parentNode)
                if (n.nodeType < 11 && (a ? -1 < a.index(n) : 1 === n.nodeType && k.find.matchesSelector(n, e))) {
                  o.push(n);
                  break
                } return this.pushStack(1 < o.length ? k.uniqueSort(o) : o)
        },
        index: function(e) {
          return e ? "string" == typeof e ? i.call(k(e), this[0]) : i.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
        },
        add: function(e, t) {
          return this.pushStack(k.uniqueSort(k.merge(this.get(), k(e, t))))
        },
        addBack: function(e) {
          return this.add(null == e ? this.prevObject : this.prevObject.filter(e))
        }
      }), k.each({
        parent: function(e) {
          var t = e.parentNode;
          return t && 11 !== t.nodeType ? t : null
        },
        parents: function(e) {
          return T(e, "parentNode")
        },
        parentsUntil: function(e, t, n) {
          return T(e, "parentNode", n)
        },
        next: function(e) {
          return P(e, "nextSibling")
        },
        prev: function(e) {
          return P(e, "previousSibling")
        },
        nextAll: function(e) {
          return T(e, "nextSibling")
        },
        prevAll: function(e) {
          return T(e, "previousSibling")
        },
        nextUntil: function(e, t, n) {
          return T(e, "nextSibling", n)
        },
        prevUntil: function(e, t, n) {
          return T(e, "previousSibling", n)
        },
        siblings: function(e) {
          return S((e.parentNode || {}).firstChild, e)
        },
        children: function(e) {
          return S(e.firstChild)
        },
        contents: function(e) {
          return "undefined" != typeof e.contentDocument ? e.contentDocument : (A(e, "template") && (e = e.content || e), k.merge([], e.childNodes))
        }
      }, function(r, i) {
        k.fn[r] = function(e, t) {
          var n = k.map(this, i, e);
          return "Until" !== r.slice(-5) && (t = e), t && "string" == typeof t && (n = k.filter(t, n)), 1 < this.length && (O[r] || k.uniqueSort(n), H.test(r) && n.reverse()), this.pushStack(n)
        }
      });
      var R = /[^\x20\t\r\n\f]+/g;

      function M(e) {
        return e
      }

      function I(e) {
        throw e
      }

      function W(e, t, n, r) {
        var i;
        try {
          e && m(i = e.promise) ? i.call(e).done(t).fail(n) : e && m(i = e.then) ? i.call(e, t, n) : t.apply(void 0, [e].slice(r))
        } catch (e) {
          n.apply(void 0, [e])
        }
      }
      k.Callbacks = function(r) {
        var e, n;
        r = "string" == typeof r ? (e = r, n = {}, k.each(e.match(R) || [], function(e, t) {
          n[t] = !0
        }), n) : k.extend({}, r);
        var i, t, o, a, s = [],
          u = [],
          l = -1,
          c = function() {
            for (a = a || r.once, o = i = !0; u.length; l = -1) {
              t = u.shift();
              while (++l < s.length) !1 === s[l].apply(t[0], t[1]) && r.stopOnFalse && (l = s.length, t = !1)
            }
            r.memory || (t = !1), i = !1, a && (s = t ? [] : "")
          },
          f = {
            add: function() {
              return s && (t && !i && (l = s.length - 1, u.push(t)), function n(e) {
                k.each(e, function(e, t) {
                  m(t) ? r.unique && f.has(t) || s.push(t) : t && t.length && "string" !== w(t) && n(t)
                })
              }(arguments), t && !i && c()), this
            },
            remove: function() {
              return k.each(arguments, function(e, t) {
                var n;
                while (-1 < (n = k.inArray(t, s, n))) s.splice(n, 1), n <= l && l--
              }), this
            },
            has: function(e) {
              return e ? -1 < k.inArray(e, s) : 0 < s.length
            },
            empty: function() {
              return s && (s = []), this
            },
            disable: function() {
              return a = u = [], s = t = "", this
            },
            disabled: function() {
              return !s
            },
            lock: function() {
              return a = u = [], t || i || (s = t = ""), this
            },
            locked: function() {
              return !!a
            },
            fireWith: function(e, t) {
              return a || (t = [e, (t = t || []).slice ? t.slice() : t], u.push(t), i || c()), this
            },
            fire: function() {
              return f.fireWith(this, arguments), this
            },
            fired: function() {
              return !!o
            }
          };
        return f
      }, k.extend({
        Deferred: function(e) {
          var o = [
              ["notify", "progress", k.Callbacks("memory"), k.Callbacks("memory"), 2],
              ["resolve", "done", k.Callbacks("once memory"), k.Callbacks("once memory"), 0, "resolved"],
              ["reject", "fail", k.Callbacks("once memory"), k.Callbacks("once memory"), 1, "rejected"]
            ],
            i = "pending",
            a = {
              state: function() {
                return i
              },
              always: function() {
                return s.done(arguments).fail(arguments), this
              },
              "catch": function(e) {
                return a.then(null, e)
              },
              pipe: function() {
                var i = arguments;
                return k.Deferred(function(r) {
                  k.each(o, function(e, t) {
                    var n = m(i[t[4]]) && i[t[4]];
                    s[t[1]](function() {
                      var e = n && n.apply(this, arguments);
                      e && m(e.promise) ? e.promise().progress(r.notify).done(r.resolve).fail(r.reject) : r[t[0] + "With"](this, n ? [e] : arguments)
                    })
                  }), i = null
                }).promise()
              },
              then: function(t, n, r) {
                var u = 0;

                function l(i, o, a, s) {
                  return function() {
                    var n = this,
                      r = arguments,
                      e = function() {
                        var e, t;
                        if (!(i < u)) {
                          if ((e = a.apply(n, r)) === o.promise()) throw new TypeError("Thenable self-resolution");
                          t = e && ("object" == typeof e || "function" == typeof e) && e.then, m(t) ? s ? t.call(e, l(u, o, M, s), l(u, o, I, s)) : (u++, t.call(e, l(u, o, M, s), l(u, o, I, s), l(u, o, M, o.notifyWith))) : (a !== M && (n = void 0, r = [e]), (s || o.resolveWith)(n, r))
                        }
                      },
                      t = s ? e : function() {
                        try {
                          e()
                        } catch (e) {
                          k.Deferred.exceptionHook && k.Deferred.exceptionHook(e, t.stackTrace), u <= i + 1 && (a !== I && (n = void 0, r = [e]), o.rejectWith(n, r))
                        }
                      };
                    i ? t() : (k.Deferred.getStackHook && (t.stackTrace = k.Deferred.getStackHook()), C.setTimeout(t))
                  }
                }
                return k.Deferred(function(e) {
                  o[0][3].add(l(0, e, m(r) ? r : M, e.notifyWith)), o[1][3].add(l(0, e, m(t) ? t : M)), o[2][3].add(l(0, e, m(n) ? n : I))
                }).promise()
              },
              promise: function(e) {
                return null != e ? k.extend(e, a) : a
              }
            },
            s = {};
          return k.each(o, function(e, t) {
            var n = t[2],
              r = t[5];
            a[t[1]] = n.add, r && n.add(function() {
              i = r
            }, o[3 - e][2].disable, o[3 - e][3].disable, o[0][2].lock, o[0][3].lock), n.add(t[3].fire), s[t[0]] = function() {
              return s[t[0] + "With"](this === s ? void 0 : this, arguments), this
            }, s[t[0] + "With"] = n.fireWith
          }), a.promise(s), e && e.call(s, s), s
        },
        when: function(e) {
          var n = arguments.length,
            t = n,
            r = Array(t),
            i = s.call(arguments),
            o = k.Deferred(),
            a = function(t) {
              return function(e) {
                r[t] = this, i[t] = 1 < arguments.length ? s.call(arguments) : e, --n || o.resolveWith(r, i)
              }
            };
          if (n <= 1 && (W(e, o.done(a(t)).resolve, o.reject, !n), "pending" === o.state() || m(i[t] && i[t].then))) return o.then();
          while (t--) W(i[t], a(t), o.reject);
          return o.promise()
        }
      });
      var $ = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
      k.Deferred.exceptionHook = function(e, t) {
        C.console && C.console.warn && e && $.test(e.name) && C.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t)
      }, k.readyException = function(e) {
        C.setTimeout(function() {
          throw e
        })
      };
      var F = k.Deferred();

      function B() {
        E.removeEventListener("DOMContentLoaded", B), C.removeEventListener("load", B), k.ready()
      }
      k.fn.ready = function(e) {
        return F.then(e)["catch"](function(e) {
          k.readyException(e)
        }), this
      }, k.extend({
        isReady: !1,
        readyWait: 1,
        ready: function(e) {
          (!0 === e ? --k.readyWait : k.isReady) || (k.isReady = !0) !== e && 0 < --k.readyWait || F.resolveWith(E, [k])
        }
      }), k.ready.then = F.then, "complete" === E.readyState || "loading" !== E.readyState && !E.documentElement.doScroll ? C.setTimeout(k.ready) : (E.addEventListener("DOMContentLoaded", B), C.addEventListener("load", B));
      var _ = function(e, t, n, r, i, o, a) {
          var s = 0,
            u = e.length,
            l = null == n;
          if ("object" === w(n))
            for (s in i = !0, n) _(e, t, s, n[s], !0, o, a);
          else if (void 0 !== r && (i = !0, m(r) || (a = !0), l && (a ? (t.call(e, r), t = null) : (l = t, t = function(e, t, n) {
              return l.call(k(e), n)
            })), t))
            for (; s < u; s++) t(e[s], n, a ? r : r.call(e[s], s, t(e[s], n)));
          return i ? e : l ? t.call(e) : u ? t(e[0], n) : o
        },
        z = /^-ms-/,
        U = /-([a-z])/g;

      function X(e, t) {
        return t.toUpperCase()
      }

      function V(e) {
        return e.replace(z, "ms-").replace(U, X)
      }
      var G = function(e) {
        return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType
      };

      function Y() {
        this.expando = k.expando + Y.uid++
      }
      Y.uid = 1, Y.prototype = {
        cache: function(e) {
          var t = e[this.expando];
          return t || (t = {}, G(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, {
            value: t,
            configurable: !0
          }))), t
        },
        set: function(e, t, n) {
          var r, i = this.cache(e);
          if ("string" == typeof t) i[V(t)] = n;
          else
            for (r in t) i[V(r)] = t[r];
          return i
        },
        get: function(e, t) {
          return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][V(t)]
        },
        access: function(e, t, n) {
          return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t)
        },
        remove: function(e, t) {
          var n, r = e[this.expando];
          if (void 0 !== r) {
            if (void 0 !== t) {
              n = (t = Array.isArray(t) ? t.map(V) : (t = V(t)) in r ? [t] : t.match(R) || []).length;
              while (n--) delete r[t[n]]
            }(void 0 === t || k.isEmptyObject(r)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando])
          }
        },
        hasData: function(e) {
          var t = e[this.expando];
          return void 0 !== t && !k.isEmptyObject(t)
        }
      };
      var Q = new Y,
        J = new Y,
        K = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        Z = /[A-Z]/g;

      function ee(e, t, n) {
        var r, i;
        if (void 0 === n && 1 === e.nodeType)
          if (r = "data-" + t.replace(Z, "-$&").toLowerCase(), "string" == typeof(n = e.getAttribute(r))) {
            try {
              n = "true" === (i = n) || "false" !== i && ("null" === i ? null : i === +i + "" ? +i : K.test(i) ? JSON.parse(i) : i)
            } catch (e) {}
            J.set(e, t, n)
          } else n = void 0;
        return n
      }
      k.extend({
        hasData: function(e) {
          return J.hasData(e) || Q.hasData(e)
        },
        data: function(e, t, n) {
          return J.access(e, t, n)
        },
        removeData: function(e, t) {
          J.remove(e, t)
        },
        _data: function(e, t, n) {
          return Q.access(e, t, n)
        },
        _removeData: function(e, t) {
          Q.remove(e, t)
        }
      }), k.fn.extend({
        data: function(n, e) {
          var t, r, i, o = this[0],
            a = o && o.attributes;
          if (void 0 === n) {
            if (this.length && (i = J.get(o), 1 === o.nodeType && !Q.get(o, "hasDataAttrs"))) {
              t = a.length;
              while (t--) a[t] && 0 === (r = a[t].name).indexOf("data-") && (r = V(r.slice(5)), ee(o, r, i[r]));
              Q.set(o, "hasDataAttrs", !0)
            }
            return i
          }
          return "object" == typeof n ? this.each(function() {
            J.set(this, n)
          }) : _(this, function(e) {
            var t;
            if (o && void 0 === e) return void 0 !== (t = J.get(o, n)) ? t : void 0 !== (t = ee(o, n)) ? t : void 0;
            this.each(function() {
              J.set(this, n, e)
            })
          }, null, e, 1 < arguments.length, null, !0)
        },
        removeData: function(e) {
          return this.each(function() {
            J.remove(this, e)
          })
        }
      }), k.extend({
        queue: function(e, t, n) {
          var r;
          if (e) return t = (t || "fx") + "queue", r = Q.get(e, t), n && (!r || Array.isArray(n) ? r = Q.access(e, t, k.makeArray(n)) : r.push(n)), r || []
        },
        dequeue: function(e, t) {
          t = t || "fx";
          var n = k.queue(e, t),
            r = n.length,
            i = n.shift(),
            o = k._queueHooks(e, t);
          "inprogress" === i && (i = n.shift(), r--), i && ("fx" === t && n.unshift("inprogress"), delete o.stop, i.call(e, function() {
            k.dequeue(e, t)
          }, o)), !r && o && o.empty.fire()
        },
        _queueHooks: function(e, t) {
          var n = t + "queueHooks";
          return Q.get(e, n) || Q.access(e, n, {
            empty: k.Callbacks("once memory").add(function() {
              Q.remove(e, [t + "queue", n])
            })
          })
        }
      }), k.fn.extend({
        queue: function(t, n) {
          var e = 2;
          return "string" != typeof t && (n = t, t = "fx", e--), arguments.length < e ? k.queue(this[0], t) : void 0 === n ? this : this.each(function() {
            var e = k.queue(this, t, n);
            k._queueHooks(this, t), "fx" === t && "inprogress" !== e[0] && k.dequeue(this, t)
          })
        },
        dequeue: function(e) {
          return this.each(function() {
            k.dequeue(this, e)
          })
        },
        clearQueue: function(e) {
          return this.queue(e || "fx", [])
        },
        promise: function(e, t) {
          var n, r = 1,
            i = k.Deferred(),
            o = this,
            a = this.length,
            s = function() {
              --r || i.resolveWith(o, [o])
            };
          "string" != typeof e && (t = e, e = void 0), e = e || "fx";
          while (a--)(n = Q.get(o[a], e + "queueHooks")) && n.empty && (r++, n.empty.add(s));
          return s(), i.promise(t)
        }
      });
      var te = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
        ne = new RegExp("^(?:([+-])=|)(" + te + ")([a-z%]*)$", "i"),
        re = ["Top", "Right", "Bottom", "Left"],
        ie = E.documentElement,
        oe = function(e) {
          return k.contains(e.ownerDocument, e)
        },
        ae = {
          composed: !0
        };
      ie.getRootNode && (oe = function(e) {
        return k.contains(e.ownerDocument, e) || e.getRootNode(ae) === e.ownerDocument
      });
      var se = function(e, t) {
          return "none" === (e = t || e).style.display || "" === e.style.display && oe(e) && "none" === k.css(e, "display")
        },
        ue = function(e, t, n, r) {
          var i, o, a = {};
          for (o in t) a[o] = e.style[o], e.style[o] = t[o];
          for (o in i = n.apply(e, r || []), t) e.style[o] = a[o];
          return i
        };

      function le(e, t, n, r) {
        var i, o, a = 20,
          s = r ? function() {
            return r.cur()
          } : function() {
            return k.css(e, t, "")
          },
          u = s(),
          l = n && n[3] || (k.cssNumber[t] ? "" : "px"),
          c = e.nodeType && (k.cssNumber[t] || "px" !== l && +u) && ne.exec(k.css(e, t));
        if (c && c[3] !== l) {
          u /= 2, l = l || c[3], c = +u || 1;
          while (a--) k.style(e, t, c + l), (1 - o) * (1 - (o = s() / u || .5)) <= 0 && (a = 0), c /= o;
          c *= 2, k.style(e, t, c + l), n = n || []
        }
        return n && (c = +c || +u || 0, i = n[1] ? c + (n[1] + 1) * n[2] : +n[2], r && (r.unit = l, r.start = c, r.end = i)), i
      }
      var ce = {};

      function fe(e, t) {
        for (var n, r, i, o, a, s, u, l = [], c = 0, f = e.length; c < f; c++)(r = e[c]).style && (n = r.style.display, t ? ("none" === n && (l[c] = Q.get(r, "display") || null, l[c] || (r.style.display = "")), "" === r.style.display && se(r) && (l[c] = (u = a = o = void 0, a = (i = r).ownerDocument, s = i.nodeName, (u = ce[s]) || (o = a.body.appendChild(a.createElement(s)), u = k.css(o, "display"), o.parentNode.removeChild(o), "none" === u && (u = "block"), ce[s] = u)))) : "none" !== n && (l[c] = "none", Q.set(r, "display", n)));
        for (c = 0; c < f; c++) null != l[c] && (e[c].style.display = l[c]);
        return e
      }
      k.fn.extend({
        show: function() {
          return fe(this, !0)
        },
        hide: function() {
          return fe(this)
        },
        toggle: function(e) {
          return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function() {
            se(this) ? k(this).show() : k(this).hide()
          })
        }
      });
      var pe = /^(?:checkbox|radio)$/i,
        de = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i,
        he = /^$|^module$|\/(?:java|ecma)script/i,
        ge = {
          option: [1, "<select multiple='multiple'>", "</select>"],
          thead: [1, "<table>", "</table>"],
          col: [2, "<table><colgroup>", "</colgroup></table>"],
          tr: [2, "<table><tbody>", "</tbody></table>"],
          td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
          _default: [0, "", ""]
        };

      function ve(e, t) {
        var n;
        return n = "undefined" != typeof e.getElementsByTagName ? e.getElementsByTagName(t || "*") : "undefined" != typeof e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && A(e, t) ? k.merge([e], n) : n
      }

      function ye(e, t) {
        for (var n = 0, r = e.length; n < r; n++) Q.set(e[n], "globalEval", !t || Q.get(t[n], "globalEval"))
      }
      ge.optgroup = ge.option, ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td;
      var me, xe, be = /<|&#?\w+;/;

      function we(e, t, n, r, i) {
        for (var o, a, s, u, l, c, f = t.createDocumentFragment(), p = [], d = 0, h = e.length; d < h; d++)
          if ((o = e[d]) || 0 === o)
            if ("object" === w(o)) k.merge(p, o.nodeType ? [o] : o);
            else if (be.test(o)) {
          a = a || f.appendChild(t.createElement("div")), s = (de.exec(o) || ["", ""])[1].toLowerCase(), u = ge[s] || ge._default, a.innerHTML = u[1] + k.htmlPrefilter(o) + u[2], c = u[0];
          while (c--) a = a.lastChild;
          k.merge(p, a.childNodes), (a = f.firstChild).textContent = ""
        } else p.push(t.createTextNode(o));
        f.textContent = "", d = 0;
        while (o = p[d++])
          if (r && -1 < k.inArray(o, r)) i && i.push(o);
          else if (l = oe(o), a = ve(f.appendChild(o), "script"), l && ye(a), n) {
          c = 0;
          while (o = a[c++]) he.test(o.type || "") && n.push(o)
        }
        return f
      }
      me = E.createDocumentFragment().appendChild(E.createElement("div")), (xe = E.createElement("input")).setAttribute("type", "radio"), xe.setAttribute("checked", "checked"), xe.setAttribute("name", "t"), me.appendChild(xe), y.checkClone = me.cloneNode(!0).cloneNode(!0).lastChild.checked, me.innerHTML = "<textarea>x</textarea>", y.noCloneChecked = !!me.cloneNode(!0).lastChild.defaultValue;
      var Te = /^key/,
        Ce = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
        Ee = /^([^.]*)(?:\.(.+)|)/;

      function ke() {
        return !0
      }

      function Se() {
        return !1
      }

      function Ne(e, t) {
        return e === function() {
          try {
            return E.activeElement
          } catch (e) {}
        }() == ("focus" === t)
      }

      function Ae(e, t, n, r, i, o) {
        var a, s;
        if ("object" == typeof t) {
          for (s in "string" != typeof n && (r = r || n, n = void 0), t) Ae(e, s, n, r, t[s], o);
          return e
        }
        if (null == r && null == i ? (i = n, r = n = void 0) : null == i && ("string" == typeof n ? (i = r, r = void 0) : (i = r, r = n, n = void 0)), !1 === i) i = Se;
        else if (!i) return e;
        return 1 === o && (a = i, (i = function(e) {
          return k().off(e), a.apply(this, arguments)
        }).guid = a.guid || (a.guid = k.guid++)), e.each(function() {
          k.event.add(this, t, i, r, n)
        })
      }

      function De(e, i, o) {
        o ? (Q.set(e, i, !1), k.event.add(e, i, {
          namespace: !1,
          handler: function(e) {
            var t, n, r = Q.get(this, i);
            if (1 & e.isTrigger && this[i]) {
              if (r.length)(k.event.special[i] || {}).delegateType && e.stopPropagation();
              else if (r = s.call(arguments), Q.set(this, i, r), t = o(this, i), this[i](), r !== (n = Q.get(this, i)) || t ? Q.set(this, i, !1) : n = {}, r !== n) return e.stopImmediatePropagation(), e.preventDefault(), n.value
            } else r.length && (Q.set(this, i, {
              value: k.event.trigger(k.extend(r[0], k.Event.prototype), r.slice(1), this)
            }), e.stopImmediatePropagation())
          }
        })) : void 0 === Q.get(e, i) && k.event.add(e, i, ke)
      }
      k.event = {
        global: {},
        add: function(t, e, n, r, i) {
          var o, a, s, u, l, c, f, p, d, h, g, v = Q.get(t);
          if (v) {
            n.handler && (n = (o = n).handler, i = o.selector), i && k.find.matchesSelector(ie, i), n.guid || (n.guid = k.guid++), (u = v.events) || (u = v.events = {}), (a = v.handle) || (a = v.handle = function(e) {
              return "undefined" != typeof k && k.event.triggered !== e.type ? k.event.dispatch.apply(t, arguments) : void 0
            }), l = (e = (e || "").match(R) || [""]).length;
            while (l--) d = g = (s = Ee.exec(e[l]) || [])[1], h = (s[2] || "").split(".").sort(), d && (f = k.event.special[d] || {}, d = (i ? f.delegateType : f.bindType) || d, f = k.event.special[d] || {}, c = k.extend({
              type: d,
              origType: g,
              data: r,
              handler: n,
              guid: n.guid,
              selector: i,
              needsContext: i && k.expr.match.needsContext.test(i),
              namespace: h.join(".")
            }, o), (p = u[d]) || ((p = u[d] = []).delegateCount = 0, f.setup && !1 !== f.setup.call(t, r, h, a) || t.addEventListener && t.addEventListener(d, a)), f.add && (f.add.call(t, c), c.handler.guid || (c.handler.guid = n.guid)), i ? p.splice(p.delegateCount++, 0, c) : p.push(c), k.event.global[d] = !0)
          }
        },
        remove: function(e, t, n, r, i) {
          var o, a, s, u, l, c, f, p, d, h, g, v = Q.hasData(e) && Q.get(e);
          if (v && (u = v.events)) {
            l = (t = (t || "").match(R) || [""]).length;
            while (l--)
              if (d = g = (s = Ee.exec(t[l]) || [])[1], h = (s[2] || "").split(".").sort(), d) {
                f = k.event.special[d] || {}, p = u[d = (r ? f.delegateType : f.bindType) || d] || [], s = s[2] && new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = p.length;
                while (o--) c = p[o], !i && g !== c.origType || n && n.guid !== c.guid || s && !s.test(c.namespace) || r && r !== c.selector && ("**" !== r || !c.selector) || (p.splice(o, 1), c.selector && p.delegateCount--, f.remove && f.remove.call(e, c));
                a && !p.length && (f.teardown && !1 !== f.teardown.call(e, h, v.handle) || k.removeEvent(e, d, v.handle), delete u[d])
              } else
                for (d in u) k.event.remove(e, d + t[l], n, r, !0);
            k.isEmptyObject(u) && Q.remove(e, "handle events")
          }
        },
        dispatch: function(e) {
          var t, n, r, i, o, a, s = k.event.fix(e),
            u = new Array(arguments.length),
            l = (Q.get(this, "events") || {})[s.type] || [],
            c = k.event.special[s.type] || {};
          for (u[0] = s, t = 1; t < arguments.length; t++) u[t] = arguments[t];
          if (s.delegateTarget = this, !c.preDispatch || !1 !== c.preDispatch.call(this, s)) {
            a = k.event.handlers.call(this, s, l), t = 0;
            while ((i = a[t++]) && !s.isPropagationStopped()) {
              s.currentTarget = i.elem, n = 0;
              while ((o = i.handlers[n++]) && !s.isImmediatePropagationStopped()) s.rnamespace && !1 !== o.namespace && !s.rnamespace.test(o.namespace) || (s.handleObj = o, s.data = o.data, void 0 !== (r = ((k.event.special[o.origType] || {}).handle || o.handler).apply(i.elem, u)) && !1 === (s.result = r) && (s.preventDefault(), s.stopPropagation()))
            }
            return c.postDispatch && c.postDispatch.call(this, s), s.result
          }
        },
        handlers: function(e, t) {
          var n, r, i, o, a, s = [],
            u = t.delegateCount,
            l = e.target;
          if (u && l.nodeType && !("click" === e.type && 1 <= e.button))
            for (; l !== this; l = l.parentNode || this)
              if (1 === l.nodeType && ("click" !== e.type || !0 !== l.disabled)) {
                for (o = [], a = {}, n = 0; n < u; n++) void 0 === a[i = (r = t[n]).selector + " "] && (a[i] = r.needsContext ? -1 < k(i, this).index(l) : k.find(i, this, null, [l]).length), a[i] && o.push(r);
                o.length && s.push({
                  elem: l,
                  handlers: o
                })
              } return l = this, u < t.length && s.push({
            elem: l,
            handlers: t.slice(u)
          }), s
        },
        addProp: function(t, e) {
          Object.defineProperty(k.Event.prototype, t, {
            enumerable: !0,
            configurable: !0,
            get: m(e) ? function() {
              if (this.originalEvent) return e(this.originalEvent)
            } : function() {
              if (this.originalEvent) return this.originalEvent[t]
            },
            set: function(e) {
              Object.defineProperty(this, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: e
              })
            }
          })
        },
        fix: function(e) {
          return e[k.expando] ? e : new k.Event(e)
        },
        special: {
          load: {
            noBubble: !0
          },
          click: {
            setup: function(e) {
              var t = this || e;
              return pe.test(t.type) && t.click && A(t, "input") && De(t, "click", ke), !1
            },
            trigger: function(e) {
              var t = this || e;
              return pe.test(t.type) && t.click && A(t, "input") && De(t, "click"), !0
            },
            _default: function(e) {
              var t = e.target;
              return pe.test(t.type) && t.click && A(t, "input") && Q.get(t, "click") || A(t, "a")
            }
          },
          beforeunload: {
            postDispatch: function(e) {
              void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)
            }
          }
        }
      }, k.removeEvent = function(e, t, n) {
        e.removeEventListener && e.removeEventListener(t, n)
      }, k.Event = function(e, t) {
        if (!(this instanceof k.Event)) return new k.Event(e, t);
        e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? ke : Se, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && k.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[k.expando] = !0
      }, k.Event.prototype = {
        constructor: k.Event,
        isDefaultPrevented: Se,
        isPropagationStopped: Se,
        isImmediatePropagationStopped: Se,
        isSimulated: !1,
        preventDefault: function() {
          var e = this.originalEvent;
          this.isDefaultPrevented = ke, e && !this.isSimulated && e.preventDefault()
        },
        stopPropagation: function() {
          var e = this.originalEvent;
          this.isPropagationStopped = ke, e && !this.isSimulated && e.stopPropagation()
        },
        stopImmediatePropagation: function() {
          var e = this.originalEvent;
          this.isImmediatePropagationStopped = ke, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation()
        }
      }, k.each({
        altKey: !0,
        bubbles: !0,
        cancelable: !0,
        changedTouches: !0,
        ctrlKey: !0,
        detail: !0,
        eventPhase: !0,
        metaKey: !0,
        pageX: !0,
        pageY: !0,
        shiftKey: !0,
        view: !0,
        "char": !0,
        code: !0,
        charCode: !0,
        key: !0,
        keyCode: !0,
        button: !0,
        buttons: !0,
        clientX: !0,
        clientY: !0,
        offsetX: !0,
        offsetY: !0,
        pointerId: !0,
        pointerType: !0,
        screenX: !0,
        screenY: !0,
        targetTouches: !0,
        toElement: !0,
        touches: !0,
        which: function(e) {
          var t = e.button;
          return null == e.which && Te.test(e.type) ? null != e.charCode ? e.charCode : e.keyCode : !e.which && void 0 !== t && Ce.test(e.type) ? 1 & t ? 1 : 2 & t ? 3 : 4 & t ? 2 : 0 : e.which
        }
      }, k.event.addProp), k.each({
        focus: "focusin",
        blur: "focusout"
      }, function(e, t) {
        k.event.special[e] = {
          setup: function() {
            return De(this, e, Ne), !1
          },
          trigger: function() {
            return De(this, e), !0
          },
          delegateType: t
        }
      }), k.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
      }, function(e, i) {
        k.event.special[e] = {
          delegateType: i,
          bindType: i,
          handle: function(e) {
            var t, n = e.relatedTarget,
              r = e.handleObj;
            return n && (n === this || k.contains(this, n)) || (e.type = r.origType, t = r.handler.apply(this, arguments), e.type = i), t
          }
        }
      }), k.fn.extend({
        on: function(e, t, n, r) {
          return Ae(this, e, t, n, r)
        },
        one: function(e, t, n, r) {
          return Ae(this, e, t, n, r, 1)
        },
        off: function(e, t, n) {
          var r, i;
          if (e && e.preventDefault && e.handleObj) return r = e.handleObj, k(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this;
          if ("object" == typeof e) {
            for (i in e) this.off(i, t, e[i]);
            return this
          }
          return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = Se), this.each(function() {
            k.event.remove(this, e, n, t)
          })
        }
      });
      var je = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
        qe = /<script|<style|<link/i,
        Le = /checked\s*(?:[^=]|=\s*.checked.)/i,
        He = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

      function Oe(e, t) {
        return A(e, "table") && A(11 !== t.nodeType ? t : t.firstChild, "tr") && k(e).children("tbody")[0] || e
      }

      function Pe(e) {
        return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e
      }

      function Re(e) {
        return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e
      }

      function Me(e, t) {
        var n, r, i, o, a, s, u, l;
        if (1 === t.nodeType) {
          if (Q.hasData(e) && (o = Q.access(e), a = Q.set(t, o), l = o.events))
            for (i in delete a.handle, a.events = {}, l)
              for (n = 0, r = l[i].length; n < r; n++) k.event.add(t, i, l[i][n]);
          J.hasData(e) && (s = J.access(e), u = k.extend({}, s), J.set(t, u))
        }
      }

      function Ie(n, r, i, o) {
        r = g.apply([], r);
        var e, t, a, s, u, l, c = 0,
          f = n.length,
          p = f - 1,
          d = r[0],
          h = m(d);
        if (h || 1 < f && "string" == typeof d && !y.checkClone && Le.test(d)) return n.each(function(e) {
          var t = n.eq(e);
          h && (r[0] = d.call(this, e, t.html())), Ie(t, r, i, o)
        });
        if (f && (t = (e = we(r, n[0].ownerDocument, !1, n, o)).firstChild, 1 === e.childNodes.length && (e = t), t || o)) {
          for (s = (a = k.map(ve(e, "script"), Pe)).length; c < f; c++) u = e, c !== p && (u = k.clone(u, !0, !0), s && k.merge(a, ve(u, "script"))), i.call(n[c], u, c);
          if (s)
            for (l = a[a.length - 1].ownerDocument, k.map(a, Re), c = 0; c < s; c++) u = a[c], he.test(u.type || "") && !Q.access(u, "globalEval") && k.contains(l, u) && (u.src && "module" !== (u.type || "").toLowerCase() ? k._evalUrl && !u.noModule && k._evalUrl(u.src, {
              nonce: u.nonce || u.getAttribute("nonce")
            }) : b(u.textContent.replace(He, ""), u, l))
        }
        return n
      }

      function We(e, t, n) {
        for (var r, i = t ? k.filter(t, e) : e, o = 0; null != (r = i[o]); o++) n || 1 !== r.nodeType || k.cleanData(ve(r)), r.parentNode && (n && oe(r) && ye(ve(r, "script")), r.parentNode.removeChild(r));
        return e
      }
      k.extend({
        htmlPrefilter: function(e) {
          return e.replace(je, "<$1></$2>")
        },
        clone: function(e, t, n) {
          var r, i, o, a, s, u, l, c = e.cloneNode(!0),
            f = oe(e);
          if (!(y.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || k.isXMLDoc(e)))
            for (a = ve(c), r = 0, i = (o = ve(e)).length; r < i; r++) s = o[r], u = a[r], void 0, "input" === (l = u.nodeName.toLowerCase()) && pe.test(s.type) ? u.checked = s.checked : "input" !== l && "textarea" !== l || (u.defaultValue = s.defaultValue);
          if (t)
            if (n)
              for (o = o || ve(e), a = a || ve(c), r = 0, i = o.length; r < i; r++) Me(o[r], a[r]);
            else Me(e, c);
          return 0 < (a = ve(c, "script")).length && ye(a, !f && ve(e, "script")), c
        },
        cleanData: function(e) {
          for (var t, n, r, i = k.event.special, o = 0; void 0 !== (n = e[o]); o++)
            if (G(n)) {
              if (t = n[Q.expando]) {
                if (t.events)
                  for (r in t.events) i[r] ? k.event.remove(n, r) : k.removeEvent(n, r, t.handle);
                n[Q.expando] = void 0
              }
              n[J.expando] && (n[J.expando] = void 0)
            }
        }
      }), k.fn.extend({
        detach: function(e) {
          return We(this, e, !0)
        },
        remove: function(e) {
          return We(this, e)
        },
        text: function(e) {
          return _(this, function(e) {
            return void 0 === e ? k.text(this) : this.empty().each(function() {
              1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e)
            })
          }, null, e, arguments.length)
        },
        append: function() {
          return Ie(this, arguments, function(e) {
            1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || Oe(this, e).appendChild(e)
          })
        },
        prepend: function() {
          return Ie(this, arguments, function(e) {
            if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
              var t = Oe(this, e);
              t.insertBefore(e, t.firstChild)
            }
          })
        },
        before: function() {
          return Ie(this, arguments, function(e) {
            this.parentNode && this.parentNode.insertBefore(e, this)
          })
        },
        after: function() {
          return Ie(this, arguments, function(e) {
            this.parentNode && this.parentNode.insertBefore(e, this.nextSibling)
          })
        },
        empty: function() {
          for (var e, t = 0; null != (e = this[t]); t++) 1 === e.nodeType && (k.cleanData(ve(e, !1)), e.textContent = "");
          return this
        },
        clone: function(e, t) {
          return e = null != e && e, t = null == t ? e : t, this.map(function() {
            return k.clone(this, e, t)
          })
        },
        html: function(e) {
          return _(this, function(e) {
            var t = this[0] || {},
              n = 0,
              r = this.length;
            if (void 0 === e && 1 === t.nodeType) return t.innerHTML;
            if ("string" == typeof e && !qe.test(e) && !ge[(de.exec(e) || ["", ""])[1].toLowerCase()]) {
              e = k.htmlPrefilter(e);
              try {
                for (; n < r; n++) 1 === (t = this[n] || {}).nodeType && (k.cleanData(ve(t, !1)), t.innerHTML = e);
                t = 0
              } catch (e) {}
            }
            t && this.empty().append(e)
          }, null, e, arguments.length)
        },
        replaceWith: function() {
          var n = [];
          return Ie(this, arguments, function(e) {
            var t = this.parentNode;
            k.inArray(this, n) < 0 && (k.cleanData(ve(this)), t && t.replaceChild(e, this))
          }, n)
        }
      }), k.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
      }, function(e, a) {
        k.fn[e] = function(e) {
          for (var t, n = [], r = k(e), i = r.length - 1, o = 0; o <= i; o++) t = o === i ? this : this.clone(!0), k(r[o])[a](t), u.apply(n, t.get());
          return this.pushStack(n)
        }
      });
      var $e = new RegExp("^(" + te + ")(?!px)[a-z%]+$", "i"),
        Fe = function(e) {
          var t = e.ownerDocument.defaultView;
          return t && t.opener || (t = C), t.getComputedStyle(e)
        },
        Be = new RegExp(re.join("|"), "i");

      function _e(e, t, n) {
        var r, i, o, a, s = e.style;
        return (n = n || Fe(e)) && ("" !== (a = n.getPropertyValue(t) || n[t]) || oe(e) || (a = k.style(e, t)), !y.pixelBoxStyles() && $e.test(a) && Be.test(t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0 !== a ? a + "" : a
      }

      function ze(e, t) {
        return {
          get: function() {
            if (!e()) return (this.get = t).apply(this, arguments);
            delete this.get
          }
        }
      }! function() {
        function e() {
          if (u) {
            s.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", u.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", ie.appendChild(s).appendChild(u);
            var e = C.getComputedStyle(u);
            n = "1%" !== e.top, a = 12 === t(e.marginLeft), u.style.right = "60%", o = 36 === t(e.right), r = 36 === t(e.width), u.style.position = "absolute", i = 12 === t(u.offsetWidth / 3), ie.removeChild(s), u = null
          }
        }

        function t(e) {
          return Math.round(parseFloat(e))
        }
        var n, r, i, o, a, s = E.createElement("div"),
          u = E.createElement("div");
        u.style && (u.style.backgroundClip = "content-box", u.cloneNode(!0).style.backgroundClip = "", y.clearCloneStyle = "content-box" === u.style.backgroundClip, k.extend(y, {
          boxSizingReliable: function() {
            return e(), r
          },
          pixelBoxStyles: function() {
            return e(), o
          },
          pixelPosition: function() {
            return e(), n
          },
          reliableMarginLeft: function() {
            return e(), a
          },
          scrollboxSize: function() {
            return e(), i
          }
        }))
      }();
      var Ue = ["Webkit", "Moz", "ms"],
        Xe = E.createElement("div").style,
        Ve = {};

      function Ge(e) {
        var t = k.cssProps[e] || Ve[e];
        return t || (e in Xe ? e : Ve[e] = function(e) {
          var t = e[0].toUpperCase() + e.slice(1),
            n = Ue.length;
          while (n--)
            if ((e = Ue[n] + t) in Xe) return e
        }(e) || e)
      }
      var Ye = /^(none|table(?!-c[ea]).+)/,
        Qe = /^--/,
        Je = {
          position: "absolute",
          visibility: "hidden",
          display: "block"
        },
        Ke = {
          letterSpacing: "0",
          fontWeight: "400"
        };

      function Ze(e, t, n) {
        var r = ne.exec(t);
        return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || "px") : t
      }

      function et(e, t, n, r, i, o) {
        var a = "width" === t ? 1 : 0,
          s = 0,
          u = 0;
        if (n === (r ? "border" : "content")) return 0;
        for (; a < 4; a += 2) "margin" === n && (u += k.css(e, n + re[a], !0, i)), r ? ("content" === n && (u -= k.css(e, "padding" + re[a], !0, i)), "margin" !== n && (u -= k.css(e, "border" + re[a] + "Width", !0, i))) : (u += k.css(e, "padding" + re[a], !0, i), "padding" !== n ? u += k.css(e, "border" + re[a] + "Width", !0, i) : s += k.css(e, "border" + re[a] + "Width", !0, i));
        return !r && 0 <= o && (u += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - o - u - s - .5)) || 0), u
      }

      function tt(e, t, n) {
        var r = Fe(e),
          i = (!y.boxSizingReliable() || n) && "border-box" === k.css(e, "boxSizing", !1, r),
          o = i,
          a = _e(e, t, r),
          s = "offset" + t[0].toUpperCase() + t.slice(1);
        if ($e.test(a)) {
          if (!n) return a;
          a = "auto"
        }
        return (!y.boxSizingReliable() && i || "auto" === a || !parseFloat(a) && "inline" === k.css(e, "display", !1, r)) && e.getClientRects().length && (i = "border-box" === k.css(e, "boxSizing", !1, r), (o = s in e) && (a = e[s])), (a = parseFloat(a) || 0) + et(e, t, n || (i ? "border" : "content"), o, r, a) + "px"
      }

      function nt(e, t, n, r, i) {
        return new nt.prototype.init(e, t, n, r, i)
      }
      k.extend({
        cssHooks: {
          opacity: {
            get: function(e, t) {
              if (t) {
                var n = _e(e, "opacity");
                return "" === n ? "1" : n
              }
            }
          }
        },
        cssNumber: {
          animationIterationCount: !0,
          columnCount: !0,
          fillOpacity: !0,
          flexGrow: !0,
          flexShrink: !0,
          fontWeight: !0,
          gridArea: !0,
          gridColumn: !0,
          gridColumnEnd: !0,
          gridColumnStart: !0,
          gridRow: !0,
          gridRowEnd: !0,
          gridRowStart: !0,
          lineHeight: !0,
          opacity: !0,
          order: !0,
          orphans: !0,
          widows: !0,
          zIndex: !0,
          zoom: !0
        },
        cssProps: {},
        style: function(e, t, n, r) {
          if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
            var i, o, a, s = V(t),
              u = Qe.test(t),
              l = e.style;
            if (u || (t = Ge(s)), a = k.cssHooks[t] || k.cssHooks[s], void 0 === n) return a && "get" in a && void 0 !== (i = a.get(e, !1, r)) ? i : l[t];
            "string" === (o = typeof n) && (i = ne.exec(n)) && i[1] && (n = le(e, t, i), o = "number"), null != n && n == n && ("number" !== o || u || (n += i && i[3] || (k.cssNumber[s] ? "" : "px")), y.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (l[t] = "inherit"), a && "set" in a && void 0 === (n = a.set(e, n, r)) || (u ? l.setProperty(t, n) : l[t] = n))
          }
        },
        css: function(e, t, n, r) {
          var i, o, a, s = V(t);
          return Qe.test(t) || (t = Ge(s)), (a = k.cssHooks[t] || k.cssHooks[s]) && "get" in a && (i = a.get(e, !0, n)), void 0 === i && (i = _e(e, t, r)), "normal" === i && t in Ke && (i = Ke[t]), "" === n || n ? (o = parseFloat(i), !0 === n || isFinite(o) ? o || 0 : i) : i
        }
      }), k.each(["height", "width"], function(e, u) {
        k.cssHooks[u] = {
          get: function(e, t, n) {
            if (t) return !Ye.test(k.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? tt(e, u, n) : ue(e, Je, function() {
              return tt(e, u, n)
            })
          },
          set: function(e, t, n) {
            var r, i = Fe(e),
              o = !y.scrollboxSize() && "absolute" === i.position,
              a = (o || n) && "border-box" === k.css(e, "boxSizing", !1, i),
              s = n ? et(e, u, n, a, i) : 0;
            return a && o && (s -= Math.ceil(e["offset" + u[0].toUpperCase() + u.slice(1)] - parseFloat(i[u]) - et(e, u, "border", !1, i) - .5)), s && (r = ne.exec(t)) && "px" !== (r[3] || "px") && (e.style[u] = t, t = k.css(e, u)), Ze(0, t, s)
          }
        }
      }), k.cssHooks.marginLeft = ze(y.reliableMarginLeft, function(e, t) {
        if (t) return (parseFloat(_e(e, "marginLeft")) || e.getBoundingClientRect().left - ue(e, {
          marginLeft: 0
        }, function() {
          return e.getBoundingClientRect().left
        })) + "px"
      }), k.each({
        margin: "",
        padding: "",
        border: "Width"
      }, function(i, o) {
        k.cssHooks[i + o] = {
          expand: function(e) {
            for (var t = 0, n = {}, r = "string" == typeof e ? e.split(" ") : [e]; t < 4; t++) n[i + re[t] + o] = r[t] || r[t - 2] || r[0];
            return n
          }
        }, "margin" !== i && (k.cssHooks[i + o].set = Ze)
      }), k.fn.extend({
        css: function(e, t) {
          return _(this, function(e, t, n) {
            var r, i, o = {},
              a = 0;
            if (Array.isArray(t)) {
              for (r = Fe(e), i = t.length; a < i; a++) o[t[a]] = k.css(e, t[a], !1, r);
              return o
            }
            return void 0 !== n ? k.style(e, t, n) : k.css(e, t)
          }, e, t, 1 < arguments.length)
        }
      }), ((k.Tween = nt).prototype = {
        constructor: nt,
        init: function(e, t, n, r, i, o) {
          this.elem = e, this.prop = n, this.easing = i || k.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (k.cssNumber[n] ? "" : "px")
        },
        cur: function() {
          var e = nt.propHooks[this.prop];
          return e && e.get ? e.get(this) : nt.propHooks._default.get(this)
        },
        run: function(e) {
          var t, n = nt.propHooks[this.prop];
          return this.options.duration ? this.pos = t = k.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : nt.propHooks._default.set(this), this
        }
      }).init.prototype = nt.prototype, (nt.propHooks = {
        _default: {
          get: function(e) {
            var t;
            return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = k.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0
          },
          set: function(e) {
            k.fx.step[e.prop] ? k.fx.step[e.prop](e) : 1 !== e.elem.nodeType || !k.cssHooks[e.prop] && null == e.elem.style[Ge(e.prop)] ? e.elem[e.prop] = e.now : k.style(e.elem, e.prop, e.now + e.unit)
          }
        }
      }).scrollTop = nt.propHooks.scrollLeft = {
        set: function(e) {
          e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now)
        }
      }, k.easing = {
        linear: function(e) {
          return e
        },
        swing: function(e) {
          return .5 - Math.cos(e * Math.PI) / 2
        },
        _default: "swing"
      }, k.fx = nt.prototype.init, k.fx.step = {};
      var rt, it, ot, at, st = /^(?:toggle|show|hide)$/,
        ut = /queueHooks$/;

      function lt() {
        it && (!1 === E.hidden && C.requestAnimationFrame ? C.requestAnimationFrame(lt) : C.setTimeout(lt, k.fx.interval), k.fx.tick())
      }

      function ct() {
        return C.setTimeout(function() {
          rt = void 0
        }), rt = Date.now()
      }

      function ft(e, t) {
        var n, r = 0,
          i = {
            height: e
          };
        for (t = t ? 1 : 0; r < 4; r += 2 - t) i["margin" + (n = re[r])] = i["padding" + n] = e;
        return t && (i.opacity = i.width = e), i
      }

      function pt(e, t, n) {
        for (var r, i = (dt.tweeners[t] || []).concat(dt.tweeners["*"]), o = 0, a = i.length; o < a; o++)
          if (r = i[o].call(n, t, e)) return r
      }

      function dt(o, e, t) {
        var n, a, r = 0,
          i = dt.prefilters.length,
          s = k.Deferred().always(function() {
            delete u.elem
          }),
          u = function() {
            if (a) return !1;
            for (var e = rt || ct(), t = Math.max(0, l.startTime + l.duration - e), n = 1 - (t / l.duration || 0), r = 0, i = l.tweens.length; r < i; r++) l.tweens[r].run(n);
            return s.notifyWith(o, [l, n, t]), n < 1 && i ? t : (i || s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l]), !1)
          },
          l = s.promise({
            elem: o,
            props: k.extend({}, e),
            opts: k.extend(!0, {
              specialEasing: {},
              easing: k.easing._default
            }, t),
            originalProperties: e,
            originalOptions: t,
            startTime: rt || ct(),
            duration: t.duration,
            tweens: [],
            createTween: function(e, t) {
              var n = k.Tween(o, l.opts, e, t, l.opts.specialEasing[e] || l.opts.easing);
              return l.tweens.push(n), n
            },
            stop: function(e) {
              var t = 0,
                n = e ? l.tweens.length : 0;
              if (a) return this;
              for (a = !0; t < n; t++) l.tweens[t].run(1);
              return e ? (s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l, e])) : s.rejectWith(o, [l, e]), this
            }
          }),
          c = l.props;
        for (! function(e, t) {
            var n, r, i, o, a;
            for (n in e)
              if (i = t[r = V(n)], o = e[n], Array.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), (a = k.cssHooks[r]) && "expand" in a)
                for (n in o = a.expand(o), delete e[r], o) n in e || (e[n] = o[n], t[n] = i);
              else t[r] = i
          }(c, l.opts.specialEasing); r < i; r++)
          if (n = dt.prefilters[r].call(l, o, c, l.opts)) return m(n.stop) && (k._queueHooks(l.elem, l.opts.queue).stop = n.stop.bind(n)), n;
        return k.map(c, pt, l), m(l.opts.start) && l.opts.start.call(o, l), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always), k.fx.timer(k.extend(u, {
          elem: o,
          anim: l,
          queue: l.opts.queue
        })), l
      }
      k.Animation = k.extend(dt, {
        tweeners: {
          "*": [function(e, t) {
            var n = this.createTween(e, t);
            return le(n.elem, e, ne.exec(t), n), n
          }]
        },
        tweener: function(e, t) {
          m(e) ? (t = e, e = ["*"]) : e = e.match(R);
          for (var n, r = 0, i = e.length; r < i; r++) n = e[r], dt.tweeners[n] = dt.tweeners[n] || [], dt.tweeners[n].unshift(t)
        },
        prefilters: [function(e, t, n) {
          var r, i, o, a, s, u, l, c, f = "width" in t || "height" in t,
            p = this,
            d = {},
            h = e.style,
            g = e.nodeType && se(e),
            v = Q.get(e, "fxshow");
          for (r in n.queue || (null == (a = k._queueHooks(e, "fx")).unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function() {
              a.unqueued || s()
            }), a.unqueued++, p.always(function() {
              p.always(function() {
                a.unqueued--, k.queue(e, "fx").length || a.empty.fire()
              })
            })), t)
            if (i = t[r], st.test(i)) {
              if (delete t[r], o = o || "toggle" === i, i === (g ? "hide" : "show")) {
                if ("show" !== i || !v || void 0 === v[r]) continue;
                g = !0
              }
              d[r] = v && v[r] || k.style(e, r)
            } if ((u = !k.isEmptyObject(t)) || !k.isEmptyObject(d))
            for (r in f && 1 === e.nodeType && (n.overflow = [h.overflow, h.overflowX, h.overflowY], null == (l = v && v.display) && (l = Q.get(e, "display")), "none" === (c = k.css(e, "display")) && (l ? c = l : (fe([e], !0), l = e.style.display || l, c = k.css(e, "display"), fe([e]))), ("inline" === c || "inline-block" === c && null != l) && "none" === k.css(e, "float") && (u || (p.done(function() {
                h.display = l
              }), null == l && (c = h.display, l = "none" === c ? "" : c)), h.display = "inline-block")), n.overflow && (h.overflow = "hidden", p.always(function() {
                h.overflow = n.overflow[0], h.overflowX = n.overflow[1], h.overflowY = n.overflow[2]
              })), u = !1, d) u || (v ? "hidden" in v && (g = v.hidden) : v = Q.access(e, "fxshow", {
              display: l
            }), o && (v.hidden = !g), g && fe([e], !0), p.done(function() {
              for (r in g || fe([e]), Q.remove(e, "fxshow"), d) k.style(e, r, d[r])
            })), u = pt(g ? v[r] : 0, r, p), r in v || (v[r] = u.start, g && (u.end = u.start, u.start = 0))
        }],
        prefilter: function(e, t) {
          t ? dt.prefilters.unshift(e) : dt.prefilters.push(e)
        }
      }), k.speed = function(e, t, n) {
        var r = e && "object" == typeof e ? k.extend({}, e) : {
          complete: n || !n && t || m(e) && e,
          duration: e,
          easing: n && t || t && !m(t) && t
        };
        return k.fx.off ? r.duration = 0 : "number" != typeof r.duration && (r.duration in k.fx.speeds ? r.duration = k.fx.speeds[r.duration] : r.duration = k.fx.speeds._default), null != r.queue && !0 !== r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = function() {
          m(r.old) && r.old.call(this), r.queue && k.dequeue(this, r.queue)
        }, r
      }, k.fn.extend({
        fadeTo: function(e, t, n, r) {
          return this.filter(se).css("opacity", 0).show().end().animate({
            opacity: t
          }, e, n, r)
        },
        animate: function(t, e, n, r) {
          var i = k.isEmptyObject(t),
            o = k.speed(e, n, r),
            a = function() {
              var e = dt(this, k.extend({}, t), o);
              (i || Q.get(this, "finish")) && e.stop(!0)
            };
          return a.finish = a, i || !1 === o.queue ? this.each(a) : this.queue(o.queue, a)
        },
        stop: function(i, e, o) {
          var a = function(e) {
            var t = e.stop;
            delete e.stop, t(o)
          };
          return "string" != typeof i && (o = e, e = i, i = void 0), e && !1 !== i && this.queue(i || "fx", []), this.each(function() {
            var e = !0,
              t = null != i && i + "queueHooks",
              n = k.timers,
              r = Q.get(this);
            if (t) r[t] && r[t].stop && a(r[t]);
            else
              for (t in r) r[t] && r[t].stop && ut.test(t) && a(r[t]);
            for (t = n.length; t--;) n[t].elem !== this || null != i && n[t].queue !== i || (n[t].anim.stop(o), e = !1, n.splice(t, 1));
            !e && o || k.dequeue(this, i)
          })
        },
        finish: function(a) {
          return !1 !== a && (a = a || "fx"), this.each(function() {
            var e, t = Q.get(this),
              n = t[a + "queue"],
              r = t[a + "queueHooks"],
              i = k.timers,
              o = n ? n.length : 0;
            for (t.finish = !0, k.queue(this, a, []), r && r.stop && r.stop.call(this, !0), e = i.length; e--;) i[e].elem === this && i[e].queue === a && (i[e].anim.stop(!0), i.splice(e, 1));
            for (e = 0; e < o; e++) n[e] && n[e].finish && n[e].finish.call(this);
            delete t.finish
          })
        }
      }), k.each(["toggle", "show", "hide"], function(e, r) {
        var i = k.fn[r];
        k.fn[r] = function(e, t, n) {
          return null == e || "boolean" == typeof e ? i.apply(this, arguments) : this.animate(ft(r, !0), e, t, n)
        }
      }), k.each({
        slideDown: ft("show"),
        slideUp: ft("hide"),
        slideToggle: ft("toggle"),
        fadeIn: {
          opacity: "show"
        },
        fadeOut: {
          opacity: "hide"
        },
        fadeToggle: {
          opacity: "toggle"
        }
      }, function(e, r) {
        k.fn[e] = function(e, t, n) {
          return this.animate(r, e, t, n)
        }
      }), k.timers = [], k.fx.tick = function() {
        var e, t = 0,
          n = k.timers;
        for (rt = Date.now(); t < n.length; t++)(e = n[t])() || n[t] !== e || n.splice(t--, 1);
        n.length || k.fx.stop(), rt = void 0
      }, k.fx.timer = function(e) {
        k.timers.push(e), k.fx.start()
      }, k.fx.interval = 13, k.fx.start = function() {
        it || (it = !0, lt())
      }, k.fx.stop = function() {
        it = null
      }, k.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
      }, k.fn.delay = function(r, e) {
        return r = k.fx && k.fx.speeds[r] || r, e = e || "fx", this.queue(e, function(e, t) {
          var n = C.setTimeout(e, r);
          t.stop = function() {
            C.clearTimeout(n)
          }
        })
      }, ot = E.createElement("input"), at = E.createElement("select").appendChild(E.createElement("option")), ot.type = "checkbox", y.checkOn = "" !== ot.value, y.optSelected = at.selected, (ot = E.createElement("input")).value = "t", ot.type = "radio", y.radioValue = "t" === ot.value;
      var ht, gt = k.expr.attrHandle;
      k.fn.extend({
        attr: function(e, t) {
          return _(this, k.attr, e, t, 1 < arguments.length)
        },
        removeAttr: function(e) {
          return this.each(function() {
            k.removeAttr(this, e)
          })
        }
      }), k.extend({
        attr: function(e, t, n) {
          var r, i, o = e.nodeType;
          if (3 !== o && 8 !== o && 2 !== o) return "undefined" == typeof e.getAttribute ? k.prop(e, t, n) : (1 === o && k.isXMLDoc(e) || (i = k.attrHooks[t.toLowerCase()] || (k.expr.match.bool.test(t) ? ht : void 0)), void 0 !== n ? null === n ? void k.removeAttr(e, t) : i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : (e.setAttribute(t, n + ""), n) : i && "get" in i && null !== (r = i.get(e, t)) ? r : null == (r = k.find.attr(e, t)) ? void 0 : r)
        },
        attrHooks: {
          type: {
            set: function(e, t) {
              if (!y.radioValue && "radio" === t && A(e, "input")) {
                var n = e.value;
                return e.setAttribute("type", t), n && (e.value = n), t
              }
            }
          }
        },
        removeAttr: function(e, t) {
          var n, r = 0,
            i = t && t.match(R);
          if (i && 1 === e.nodeType)
            while (n = i[r++]) e.removeAttribute(n)
        }
      }), ht = {
        set: function(e, t, n) {
          return !1 === t ? k.removeAttr(e, n) : e.setAttribute(n, n), n
        }
      }, k.each(k.expr.match.bool.source.match(/\w+/g), function(e, t) {
        var a = gt[t] || k.find.attr;
        gt[t] = function(e, t, n) {
          var r, i, o = t.toLowerCase();
          return n || (i = gt[o], gt[o] = r, r = null != a(e, t, n) ? o : null, gt[o] = i), r
        }
      });
      var vt = /^(?:input|select|textarea|button)$/i,
        yt = /^(?:a|area)$/i;

      function mt(e) {
        return (e.match(R) || []).join(" ")
      }

      function xt(e) {
        return e.getAttribute && e.getAttribute("class") || ""
      }

      function bt(e) {
        return Array.isArray(e) ? e : "string" == typeof e && e.match(R) || []
      }
      k.fn.extend({
        prop: function(e, t) {
          return _(this, k.prop, e, t, 1 < arguments.length)
        },
        removeProp: function(e) {
          return this.each(function() {
            delete this[k.propFix[e] || e]
          })
        }
      }), k.extend({
        prop: function(e, t, n) {
          var r, i, o = e.nodeType;
          if (3 !== o && 8 !== o && 2 !== o) return 1 === o && k.isXMLDoc(e) || (t = k.propFix[t] || t, i = k.propHooks[t]), void 0 !== n ? i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && "get" in i && null !== (r = i.get(e, t)) ? r : e[t]
        },
        propHooks: {
          tabIndex: {
            get: function(e) {
              var t = k.find.attr(e, "tabindex");
              return t ? parseInt(t, 10) : vt.test(e.nodeName) || yt.test(e.nodeName) && e.href ? 0 : -1
            }
          }
        },
        propFix: {
          "for": "htmlFor",
          "class": "className"
        }
      }), y.optSelected || (k.propHooks.selected = {
        get: function(e) {
          var t = e.parentNode;
          return t && t.parentNode && t.parentNode.selectedIndex, null
        },
        set: function(e) {
          var t = e.parentNode;
          t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex)
        }
      }), k.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
        k.propFix[this.toLowerCase()] = this
      }), k.fn.extend({
        addClass: function(t) {
          var e, n, r, i, o, a, s, u = 0;
          if (m(t)) return this.each(function(e) {
            k(this).addClass(t.call(this, e, xt(this)))
          });
          if ((e = bt(t)).length)
            while (n = this[u++])
              if (i = xt(n), r = 1 === n.nodeType && " " + mt(i) + " ") {
                a = 0;
                while (o = e[a++]) r.indexOf(" " + o + " ") < 0 && (r += o + " ");
                i !== (s = mt(r)) && n.setAttribute("class", s)
              } return this
        },
        removeClass: function(t) {
          var e, n, r, i, o, a, s, u = 0;
          if (m(t)) return this.each(function(e) {
            k(this).removeClass(t.call(this, e, xt(this)))
          });
          if (!arguments.length) return this.attr("class", "");
          if ((e = bt(t)).length)
            while (n = this[u++])
              if (i = xt(n), r = 1 === n.nodeType && " " + mt(i) + " ") {
                a = 0;
                while (o = e[a++])
                  while (-1 < r.indexOf(" " + o + " ")) r = r.replace(" " + o + " ", " ");
                i !== (s = mt(r)) && n.setAttribute("class", s)
              } return this
        },
        toggleClass: function(i, t) {
          var o = typeof i,
            a = "string" === o || Array.isArray(i);
          return "boolean" == typeof t && a ? t ? this.addClass(i) : this.removeClass(i) : m(i) ? this.each(function(e) {
            k(this).toggleClass(i.call(this, e, xt(this), t), t)
          }) : this.each(function() {
            var e, t, n, r;
            if (a) {
              t = 0, n = k(this), r = bt(i);
              while (e = r[t++]) n.hasClass(e) ? n.removeClass(e) : n.addClass(e)
            } else void 0 !== i && "boolean" !== o || ((e = xt(this)) && Q.set(this, "__className__", e), this.setAttribute && this.setAttribute("class", e || !1 === i ? "" : Q.get(this, "__className__") || ""))
          })
        },
        hasClass: function(e) {
          var t, n, r = 0;
          t = " " + e + " ";
          while (n = this[r++])
            if (1 === n.nodeType && -1 < (" " + mt(xt(n)) + " ").indexOf(t)) return !0;
          return !1
        }
      });
      var wt = /\r/g;
      k.fn.extend({
        val: function(n) {
          var r, e, i, t = this[0];
          return arguments.length ? (i = m(n), this.each(function(e) {
            var t;
            1 === this.nodeType && (null == (t = i ? n.call(this, e, k(this).val()) : n) ? t = "" : "number" == typeof t ? t += "" : Array.isArray(t) && (t = k.map(t, function(e) {
              return null == e ? "" : e + ""
            })), (r = k.valHooks[this.type] || k.valHooks[this.nodeName.toLowerCase()]) && "set" in r && void 0 !== r.set(this, t, "value") || (this.value = t))
          })) : t ? (r = k.valHooks[t.type] || k.valHooks[t.nodeName.toLowerCase()]) && "get" in r && void 0 !== (e = r.get(t, "value")) ? e : "string" == typeof(e = t.value) ? e.replace(wt, "") : null == e ? "" : e : void 0
        }
      }), k.extend({
        valHooks: {
          option: {
            get: function(e) {
              var t = k.find.attr(e, "value");
              return null != t ? t : mt(k.text(e))
            }
          },
          select: {
            get: function(e) {
              var t, n, r, i = e.options,
                o = e.selectedIndex,
                a = "select-one" === e.type,
                s = a ? null : [],
                u = a ? o + 1 : i.length;
              for (r = o < 0 ? u : a ? o : 0; r < u; r++)
                if (((n = i[r]).selected || r === o) && !n.disabled && (!n.parentNode.disabled || !A(n.parentNode, "optgroup"))) {
                  if (t = k(n).val(), a) return t;
                  s.push(t)
                } return s
            },
            set: function(e, t) {
              var n, r, i = e.options,
                o = k.makeArray(t),
                a = i.length;
              while (a--)((r = i[a]).selected = -1 < k.inArray(k.valHooks.option.get(r), o)) && (n = !0);
              return n || (e.selectedIndex = -1), o
            }
          }
        }
      }), k.each(["radio", "checkbox"], function() {
        k.valHooks[this] = {
          set: function(e, t) {
            if (Array.isArray(t)) return e.checked = -1 < k.inArray(k(e).val(), t)
          }
        }, y.checkOn || (k.valHooks[this].get = function(e) {
          return null === e.getAttribute("value") ? "on" : e.value
        })
      }), y.focusin = "onfocusin" in C;
      var Tt = /^(?:focusinfocus|focusoutblur)$/,
        Ct = function(e) {
          e.stopPropagation()
        };
      k.extend(k.event, {
        trigger: function(e, t, n, r) {
          var i, o, a, s, u, l, c, f, p = [n || E],
            d = v.call(e, "type") ? e.type : e,
            h = v.call(e, "namespace") ? e.namespace.split(".") : [];
          if (o = f = a = n = n || E, 3 !== n.nodeType && 8 !== n.nodeType && !Tt.test(d + k.event.triggered) && (-1 < d.indexOf(".") && (d = (h = d.split(".")).shift(), h.sort()), u = d.indexOf(":") < 0 && "on" + d, (e = e[k.expando] ? e : new k.Event(d, "object" == typeof e && e)).isTrigger = r ? 2 : 3, e.namespace = h.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = n), t = null == t ? [e] : k.makeArray(t, [e]), c = k.event.special[d] || {}, r || !c.trigger || !1 !== c.trigger.apply(n, t))) {
            if (!r && !c.noBubble && !x(n)) {
              for (s = c.delegateType || d, Tt.test(s + d) || (o = o.parentNode); o; o = o.parentNode) p.push(o), a = o;
              a === (n.ownerDocument || E) && p.push(a.defaultView || a.parentWindow || C)
            }
            i = 0;
            while ((o = p[i++]) && !e.isPropagationStopped()) f = o, e.type = 1 < i ? s : c.bindType || d, (l = (Q.get(o, "events") || {})[e.type] && Q.get(o, "handle")) && l.apply(o, t), (l = u && o[u]) && l.apply && G(o) && (e.result = l.apply(o, t), !1 === e.result && e.preventDefault());
            return e.type = d, r || e.isDefaultPrevented() || c._default && !1 !== c._default.apply(p.pop(), t) || !G(n) || u && m(n[d]) && !x(n) && ((a = n[u]) && (n[u] = null), k.event.triggered = d, e.isPropagationStopped() && f.addEventListener(d, Ct), n[d](), e.isPropagationStopped() && f.removeEventListener(d, Ct), k.event.triggered = void 0, a && (n[u] = a)), e.result
          }
        },
        simulate: function(e, t, n) {
          var r = k.extend(new k.Event, n, {
            type: e,
            isSimulated: !0
          });
          k.event.trigger(r, null, t)
        }
      }), k.fn.extend({
        trigger: function(e, t) {
          return this.each(function() {
            k.event.trigger(e, t, this)
          })
        },
        triggerHandler: function(e, t) {
          var n = this[0];
          if (n) return k.event.trigger(e, t, n, !0)
        }
      }), y.focusin || k.each({
        focus: "focusin",
        blur: "focusout"
      }, function(n, r) {
        var i = function(e) {
          k.event.simulate(r, e.target, k.event.fix(e))
        };
        k.event.special[r] = {
          setup: function() {
            var e = this.ownerDocument || this,
              t = Q.access(e, r);
            t || e.addEventListener(n, i, !0), Q.access(e, r, (t || 0) + 1)
          },
          teardown: function() {
            var e = this.ownerDocument || this,
              t = Q.access(e, r) - 1;
            t ? Q.access(e, r, t) : (e.removeEventListener(n, i, !0), Q.remove(e, r))
          }
        }
      });
      var Et = C.location,
        kt = Date.now(),
        St = /\?/;
      k.parseXML = function(e) {
        var t;
        if (!e || "string" != typeof e) return null;
        try {
          t = (new C.DOMParser).parseFromString(e, "text/xml")
        } catch (e) {
          t = void 0
        }
        return t && !t.getElementsByTagName("parsererror").length || k.error("Invalid XML: " + e), t
      };
      var Nt = /\[\]$/,
        At = /\r?\n/g,
        Dt = /^(?:submit|button|image|reset|file)$/i,
        jt = /^(?:input|select|textarea|keygen)/i;

      function qt(n, e, r, i) {
        var t;
        if (Array.isArray(e)) k.each(e, function(e, t) {
          r || Nt.test(n) ? i(n, t) : qt(n + "[" + ("object" == typeof t && null != t ? e : "") + "]", t, r, i)
        });
        else if (r || "object" !== w(e)) i(n, e);
        else
          for (t in e) qt(n + "[" + t + "]", e[t], r, i)
      }
      k.param = function(e, t) {
        var n, r = [],
          i = function(e, t) {
            var n = m(t) ? t() : t;
            r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n)
          };
        if (null == e) return "";
        if (Array.isArray(e) || e.jquery && !k.isPlainObject(e)) k.each(e, function() {
          i(this.name, this.value)
        });
        else
          for (n in e) qt(n, e[n], t, i);
        return r.join("&")
      }, k.fn.extend({
        serialize: function() {
          return k.param(this.serializeArray())
        },
        serializeArray: function() {
          return this.map(function() {
            var e = k.prop(this, "elements");
            return e ? k.makeArray(e) : this
          }).filter(function() {
            var e = this.type;
            return this.name && !k(this).is(":disabled") && jt.test(this.nodeName) && !Dt.test(e) && (this.checked || !pe.test(e))
          }).map(function(e, t) {
            var n = k(this).val();
            return null == n ? null : Array.isArray(n) ? k.map(n, function(e) {
              return {
                name: t.name,
                value: e.replace(At, "\r\n")
              }
            }) : {
              name: t.name,
              value: n.replace(At, "\r\n")
            }
          }).get()
        }
      });
      var Lt = /%20/g,
        Ht = /#.*$/,
        Ot = /([?&])_=[^&]*/,
        Pt = /^(.*?):[ \t]*([^\r\n]*)$/gm,
        Rt = /^(?:GET|HEAD)$/,
        Mt = /^\/\//,
        It = {},
        Wt = {},
        $t = "*/".concat("*"),
        Ft = E.createElement("a");

      function Bt(o) {
        return function(e, t) {
          "string" != typeof e && (t = e, e = "*");
          var n, r = 0,
            i = e.toLowerCase().match(R) || [];
          if (m(t))
            while (n = i[r++]) "+" === n[0] ? (n = n.slice(1) || "*", (o[n] = o[n] || []).unshift(t)) : (o[n] = o[n] || []).push(t)
        }
      }

      function _t(t, i, o, a) {
        var s = {},
          u = t === Wt;

        function l(e) {
          var r;
          return s[e] = !0, k.each(t[e] || [], function(e, t) {
            var n = t(i, o, a);
            return "string" != typeof n || u || s[n] ? u ? !(r = n) : void 0 : (i.dataTypes.unshift(n), l(n), !1)
          }), r
        }
        return l(i.dataTypes[0]) || !s["*"] && l("*")
      }

      function zt(e, t) {
        var n, r, i = k.ajaxSettings.flatOptions || {};
        for (n in t) void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]);
        return r && k.extend(!0, e, r), e
      }
      Ft.href = Et.href, k.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
          url: Et.href,
          type: "GET",
          isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Et.protocol),
          global: !0,
          processData: !0,
          async: !0,
          contentType: "application/x-www-form-urlencoded; charset=UTF-8",
          accepts: {
            "*": $t,
            text: "text/plain",
            html: "text/html",
            xml: "application/xml, text/xml",
            json: "application/json, text/javascript"
          },
          contents: {
            xml: /\bxml\b/,
            html: /\bhtml/,
            json: /\bjson\b/
          },
          responseFields: {
            xml: "responseXML",
            text: "responseText",
            json: "responseJSON"
          },
          converters: {
            "* text": String,
            "text html": !0,
            "text json": JSON.parse,
            "text xml": k.parseXML
          },
          flatOptions: {
            url: !0,
            context: !0
          }
        },
        ajaxSetup: function(e, t) {
          return t ? zt(zt(e, k.ajaxSettings), t) : zt(k.ajaxSettings, e)
        },
        ajaxPrefilter: Bt(It),
        ajaxTransport: Bt(Wt),
        ajax: function(e, t) {
          "object" == typeof e && (t = e, e = void 0), t = t || {};
          var c, f, p, n, d, r, h, g, i, o, v = k.ajaxSetup({}, t),
            y = v.context || v,
            m = v.context && (y.nodeType || y.jquery) ? k(y) : k.event,
            x = k.Deferred(),
            b = k.Callbacks("once memory"),
            w = v.statusCode || {},
            a = {},
            s = {},
            u = "canceled",
            T = {
              readyState: 0,
              getResponseHeader: function(e) {
                var t;
                if (h) {
                  if (!n) {
                    n = {};
                    while (t = Pt.exec(p)) n[t[1].toLowerCase() + " "] = (n[t[1].toLowerCase() + " "] || []).concat(t[2])
                  }
                  t = n[e.toLowerCase() + " "]
                }
                return null == t ? null : t.join(", ")
              },
              getAllResponseHeaders: function() {
                return h ? p : null
              },
              setRequestHeader: function(e, t) {
                return null == h && (e = s[e.toLowerCase()] = s[e.toLowerCase()] || e, a[e] = t), this
              },
              overrideMimeType: function(e) {
                return null == h && (v.mimeType = e), this
              },
              statusCode: function(e) {
                var t;
                if (e)
                  if (h) T.always(e[T.status]);
                  else
                    for (t in e) w[t] = [w[t], e[t]];
                return this
              },
              abort: function(e) {
                var t = e || u;
                return c && c.abort(t), l(0, t), this
              }
            };
          if (x.promise(T), v.url = ((e || v.url || Et.href) + "").replace(Mt, Et.protocol + "//"), v.type = t.method || t.type || v.method || v.type, v.dataTypes = (v.dataType || "*").toLowerCase().match(R) || [""], null == v.crossDomain) {
            r = E.createElement("a");
            try {
              r.href = v.url, r.href = r.href, v.crossDomain = Ft.protocol + "//" + Ft.host != r.protocol + "//" + r.host
            } catch (e) {
              v.crossDomain = !0
            }
          }
          if (v.data && v.processData && "string" != typeof v.data && (v.data = k.param(v.data, v.traditional)), _t(It, v, t, T), h) return T;
          for (i in (g = k.event && v.global) && 0 == k.active++ && k.event.trigger("ajaxStart"), v.type = v.type.toUpperCase(), v.hasContent = !Rt.test(v.type), f = v.url.replace(Ht, ""), v.hasContent ? v.data && v.processData && 0 === (v.contentType || "").indexOf("application/x-www-form-urlencoded") && (v.data = v.data.replace(Lt, "+")) : (o = v.url.slice(f.length), v.data && (v.processData || "string" == typeof v.data) && (f += (St.test(f) ? "&" : "?") + v.data, delete v.data), !1 === v.cache && (f = f.replace(Ot, "$1"), o = (St.test(f) ? "&" : "?") + "_=" + kt++ + o), v.url = f + o), v.ifModified && (k.lastModified[f] && T.setRequestHeader("If-Modified-Since", k.lastModified[f]), k.etag[f] && T.setRequestHeader("If-None-Match", k.etag[f])), (v.data && v.hasContent && !1 !== v.contentType || t.contentType) && T.setRequestHeader("Content-Type", v.contentType), T.setRequestHeader("Accept", v.dataTypes[0] && v.accepts[v.dataTypes[0]] ? v.accepts[v.dataTypes[0]] + ("*" !== v.dataTypes[0] ? ", " + $t + "; q=0.01" : "") : v.accepts["*"]), v.headers) T.setRequestHeader(i, v.headers[i]);
          if (v.beforeSend && (!1 === v.beforeSend.call(y, T, v) || h)) return T.abort();
          if (u = "abort", b.add(v.complete), T.done(v.success), T.fail(v.error), c = _t(Wt, v, t, T)) {
            if (T.readyState = 1, g && m.trigger("ajaxSend", [T, v]), h) return T;
            v.async && 0 < v.timeout && (d = C.setTimeout(function() {
              T.abort("timeout")
            }, v.timeout));
            try {
              h = !1, c.send(a, l)
            } catch (e) {
              if (h) throw e;
              l(-1, e)
            }
          } else l(-1, "No Transport");

          function l(e, t, n, r) {
            var i, o, a, s, u, l = t;
            h || (h = !0, d && C.clearTimeout(d), c = void 0, p = r || "", T.readyState = 0 < e ? 4 : 0, i = 200 <= e && e < 300 || 304 === e, n && (s = function(e, t, n) {
              var r, i, o, a, s = e.contents,
                u = e.dataTypes;
              while ("*" === u[0]) u.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type"));
              if (r)
                for (i in s)
                  if (s[i] && s[i].test(r)) {
                    u.unshift(i);
                    break
                  } if (u[0] in n) o = u[0];
              else {
                for (i in n) {
                  if (!u[0] || e.converters[i + " " + u[0]]) {
                    o = i;
                    break
                  }
                  a || (a = i)
                }
                o = o || a
              }
              if (o) return o !== u[0] && u.unshift(o), n[o]
            }(v, T, n)), s = function(e, t, n, r) {
              var i, o, a, s, u, l = {},
                c = e.dataTypes.slice();
              if (c[1])
                for (a in e.converters) l[a.toLowerCase()] = e.converters[a];
              o = c.shift();
              while (o)
                if (e.responseFields[o] && (n[e.responseFields[o]] = t), !u && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), u = o, o = c.shift())
                  if ("*" === o) o = u;
                  else if ("*" !== u && u !== o) {
                if (!(a = l[u + " " + o] || l["* " + o]))
                  for (i in l)
                    if ((s = i.split(" "))[1] === o && (a = l[u + " " + s[0]] || l["* " + s[0]])) {
                      !0 === a ? a = l[i] : !0 !== l[i] && (o = s[0], c.unshift(s[1]));
                      break
                    } if (!0 !== a)
                  if (a && e["throws"]) t = a(t);
                  else try {
                    t = a(t)
                  } catch (e) {
                    return {
                      state: "parsererror",
                      error: a ? e : "No conversion from " + u + " to " + o
                    }
                  }
              }
              return {
                state: "success",
                data: t
              }
            }(v, s, T, i), i ? (v.ifModified && ((u = T.getResponseHeader("Last-Modified")) && (k.lastModified[f] = u), (u = T.getResponseHeader("etag")) && (k.etag[f] = u)), 204 === e || "HEAD" === v.type ? l = "nocontent" : 304 === e ? l = "notmodified" : (l = s.state, o = s.data, i = !(a = s.error))) : (a = l, !e && l || (l = "error", e < 0 && (e = 0))), T.status = e, T.statusText = (t || l) + "", i ? x.resolveWith(y, [o, l, T]) : x.rejectWith(y, [T, l, a]), T.statusCode(w), w = void 0, g && m.trigger(i ? "ajaxSuccess" : "ajaxError", [T, v, i ? o : a]), b.fireWith(y, [T, l]), g && (m.trigger("ajaxComplete", [T, v]), --k.active || k.event.trigger("ajaxStop")))
          }
          return T
        },
        getJSON: function(e, t, n) {
          return k.get(e, t, n, "json")
        },
        getScript: function(e, t) {
          return k.get(e, void 0, t, "script")
        }
      }), k.each(["get", "post"], function(e, i) {
        k[i] = function(e, t, n, r) {
          return m(t) && (r = r || n, n = t, t = void 0), k.ajax(k.extend({
            url: e,
            type: i,
            dataType: r,
            data: t,
            success: n
          }, k.isPlainObject(e) && e))
        }
      }), k._evalUrl = function(e, t) {
        return k.ajax({
          url: e,
          type: "GET",
          dataType: "script",
          cache: !0,
          async: !1,
          global: !1,
          converters: {
            "text script": function() {}
          },
          dataFilter: function(e) {
            k.globalEval(e, t)
          }
        })
      }, k.fn.extend({
        wrapAll: function(e) {
          var t;
          return this[0] && (m(e) && (e = e.call(this[0])), t = k(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function() {
            var e = this;
            while (e.firstElementChild) e = e.firstElementChild;
            return e
          }).append(this)), this
        },
        wrapInner: function(n) {
          return m(n) ? this.each(function(e) {
            k(this).wrapInner(n.call(this, e))
          }) : this.each(function() {
            var e = k(this),
              t = e.contents();
            t.length ? t.wrapAll(n) : e.append(n)
          })
        },
        wrap: function(t) {
          var n = m(t);
          return this.each(function(e) {
            k(this).wrapAll(n ? t.call(this, e) : t)
          })
        },
        unwrap: function(e) {
          return this.parent(e).not("body").each(function() {
            k(this).replaceWith(this.childNodes)
          }), this
        }
      }), k.expr.pseudos.hidden = function(e) {
        return !k.expr.pseudos.visible(e)
      }, k.expr.pseudos.visible = function(e) {
        return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length)
      }, k.ajaxSettings.xhr = function() {
        try {
          return new C.XMLHttpRequest
        } catch (e) {}
      };
      var Ut = {
          0: 200,
          1223: 204
        },
        Xt = k.ajaxSettings.xhr();
      y.cors = !!Xt && "withCredentials" in Xt, y.ajax = Xt = !!Xt, k.ajaxTransport(function(i) {
        var o, a;
        if (y.cors || Xt && !i.crossDomain) return {
          send: function(e, t) {
            var n, r = i.xhr();
            if (r.open(i.type, i.url, i.async, i.username, i.password), i.xhrFields)
              for (n in i.xhrFields) r[n] = i.xhrFields[n];
            for (n in i.mimeType && r.overrideMimeType && r.overrideMimeType(i.mimeType), i.crossDomain || e["X-Requested-With"] || (e["X-Requested-With"] = "XMLHttpRequest"), e) r.setRequestHeader(n, e[n]);
            o = function(e) {
              return function() {
                o && (o = a = r.onload = r.onerror = r.onabort = r.ontimeout = r.onreadystatechange = null, "abort" === e ? r.abort() : "error" === e ? "number" != typeof r.status ? t(0, "error") : t(r.status, r.statusText) : t(Ut[r.status] || r.status, r.statusText, "text" !== (r.responseType || "text") || "string" != typeof r.responseText ? {
                  binary: r.response
                } : {
                  text: r.responseText
                }, r.getAllResponseHeaders()))
              }
            }, r.onload = o(), a = r.onerror = r.ontimeout = o("error"), void 0 !== r.onabort ? r.onabort = a : r.onreadystatechange = function() {
              4 === r.readyState && C.setTimeout(function() {
                o && a()
              })
            }, o = o("abort");
            try {
              r.send(i.hasContent && i.data || null)
            } catch (e) {
              if (o) throw e
            }
          },
          abort: function() {
            o && o()
          }
        }
      }), k.ajaxPrefilter(function(e) {
        e.crossDomain && (e.contents.script = !1)
      }), k.ajaxSetup({
        accepts: {
          script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
          script: /\b(?:java|ecma)script\b/
        },
        converters: {
          "text script": function(e) {
            return k.globalEval(e), e
          }
        }
      }), k.ajaxPrefilter("script", function(e) {
        void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET")
      }), k.ajaxTransport("script", function(n) {
        var r, i;
        if (n.crossDomain || n.scriptAttrs) return {
          send: function(e, t) {
            r = k("<script>").attr(n.scriptAttrs || {}).prop({
              charset: n.scriptCharset,
              src: n.url
            }).on("load error", i = function(e) {
              r.remove(), i = null, e && t("error" === e.type ? 404 : 200, e.type)
            }), E.head.appendChild(r[0])
          },
          abort: function() {
            i && i()
          }
        }
      });
      var Vt, Gt = [],
        Yt = /(=)\?(?=&|$)|\?\?/;
      k.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
          var e = Gt.pop() || k.expando + "_" + kt++;
          return this[e] = !0, e
        }
      }), k.ajaxPrefilter("json jsonp", function(e, t, n) {
        var r, i, o, a = !1 !== e.jsonp && (Yt.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && Yt.test(e.data) && "data");
        if (a || "jsonp" === e.dataTypes[0]) return r = e.jsonpCallback = m(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, a ? e[a] = e[a].replace(Yt, "$1" + r) : !1 !== e.jsonp && (e.url += (St.test(e.url) ? "&" : "?") + e.jsonp + "=" + r), e.converters["script json"] = function() {
          return o || k.error(r + " was not called"), o[0]
        }, e.dataTypes[0] = "json", i = C[r], C[r] = function() {
          o = arguments
        }, n.always(function() {
          void 0 === i ? k(C).removeProp(r) : C[r] = i, e[r] && (e.jsonpCallback = t.jsonpCallback, Gt.push(r)), o && m(i) && i(o[0]), o = i = void 0
        }), "script"
      }), y.createHTMLDocument = ((Vt = E.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === Vt.childNodes.length), k.parseHTML = function(e, t, n) {
        return "string" != typeof e ? [] : ("boolean" == typeof t && (n = t, t = !1), t || (y.createHTMLDocument ? ((r = (t = E.implementation.createHTMLDocument("")).createElement("base")).href = E.location.href, t.head.appendChild(r)) : t = E), o = !n && [], (i = D.exec(e)) ? [t.createElement(i[1])] : (i = we([e], t, o), o && o.length && k(o).remove(), k.merge([], i.childNodes)));
        var r, i, o
      }, k.fn.load = function(e, t, n) {
        var r, i, o, a = this,
          s = e.indexOf(" ");
        return -1 < s && (r = mt(e.slice(s)), e = e.slice(0, s)), m(t) ? (n = t, t = void 0) : t && "object" == typeof t && (i = "POST"), 0 < a.length && k.ajax({
          url: e,
          type: i || "GET",
          dataType: "html",
          data: t
        }).done(function(e) {
          o = arguments, a.html(r ? k("<div>").append(k.parseHTML(e)).find(r) : e)
        }).always(n && function(e, t) {
          a.each(function() {
            n.apply(this, o || [e.responseText, t, e])
          })
        }), this
      }, k.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(e, t) {
        k.fn[t] = function(e) {
          return this.on(t, e)
        }
      }), k.expr.pseudos.animated = function(t) {
        return k.grep(k.timers, function(e) {
          return t === e.elem
        }).length
      }, k.offset = {
        setOffset: function(e, t, n) {
          var r, i, o, a, s, u, l = k.css(e, "position"),
            c = k(e),
            f = {};
          "static" === l && (e.style.position = "relative"), s = c.offset(), o = k.css(e, "top"), u = k.css(e, "left"), ("absolute" === l || "fixed" === l) && -1 < (o + u).indexOf("auto") ? (a = (r = c.position()).top, i = r.left) : (a = parseFloat(o) || 0, i = parseFloat(u) || 0), m(t) && (t = t.call(e, n, k.extend({}, s))), null != t.top && (f.top = t.top - s.top + a), null != t.left && (f.left = t.left - s.left + i), "using" in t ? t.using.call(e, f) : c.css(f)
        }
      }, k.fn.extend({
        offset: function(t) {
          if (arguments.length) return void 0 === t ? this : this.each(function(e) {
            k.offset.setOffset(this, t, e)
          });
          var e, n, r = this[0];
          return r ? r.getClientRects().length ? (e = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, {
            top: e.top + n.pageYOffset,
            left: e.left + n.pageXOffset
          }) : {
            top: 0,
            left: 0
          } : void 0
        },
        position: function() {
          if (this[0]) {
            var e, t, n, r = this[0],
              i = {
                top: 0,
                left: 0
              };
            if ("fixed" === k.css(r, "position")) t = r.getBoundingClientRect();
            else {
              t = this.offset(), n = r.ownerDocument, e = r.offsetParent || n.documentElement;
              while (e && (e === n.body || e === n.documentElement) && "static" === k.css(e, "position")) e = e.parentNode;
              e && e !== r && 1 === e.nodeType && ((i = k(e).offset()).top += k.css(e, "borderTopWidth", !0), i.left += k.css(e, "borderLeftWidth", !0))
            }
            return {
              top: t.top - i.top - k.css(r, "marginTop", !0),
              left: t.left - i.left - k.css(r, "marginLeft", !0)
            }
          }
        },
        offsetParent: function() {
          return this.map(function() {
            var e = this.offsetParent;
            while (e && "static" === k.css(e, "position")) e = e.offsetParent;
            return e || ie
          })
        }
      }), k.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
      }, function(t, i) {
        var o = "pageYOffset" === i;
        k.fn[t] = function(e) {
          return _(this, function(e, t, n) {
            var r;
            if (x(e) ? r = e : 9 === e.nodeType && (r = e.defaultView), void 0 === n) return r ? r[i] : e[t];
            r ? r.scrollTo(o ? r.pageXOffset : n, o ? n : r.pageYOffset) : e[t] = n
          }, t, e, arguments.length)
        }
      }), k.each(["top", "left"], function(e, n) {
        k.cssHooks[n] = ze(y.pixelPosition, function(e, t) {
          if (t) return t = _e(e, n), $e.test(t) ? k(e).position()[n] + "px" : t
        })
      }), k.each({
        Height: "height",
        Width: "width"
      }, function(a, s) {
        k.each({
          padding: "inner" + a,
          content: s,
          "": "outer" + a
        }, function(r, o) {
          k.fn[o] = function(e, t) {
            var n = arguments.length && (r || "boolean" != typeof e),
              i = r || (!0 === e || !0 === t ? "margin" : "border");
            return _(this, function(e, t, n) {
              var r;
              return x(e) ? 0 === o.indexOf("outer") ? e["inner" + a] : e.document.documentElement["client" + a] : 9 === e.nodeType ? (r = e.documentElement, Math.max(e.body["scroll" + a], r["scroll" + a], e.body["offset" + a], r["offset" + a], r["client" + a])) : void 0 === n ? k.css(e, t, i) : k.style(e, t, n, i)
            }, s, n ? e : void 0, n)
          }
        })
      }), k.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(e, n) {
        k.fn[n] = function(e, t) {
          return 0 < arguments.length ? this.on(n, null, e, t) : this.trigger(n)
        }
      }), k.fn.extend({
        hover: function(e, t) {
          return this.mouseenter(e).mouseleave(t || e)
        }
      }), k.fn.extend({
        bind: function(e, t, n) {
          return this.on(e, null, t, n)
        },
        unbind: function(e, t) {
          return this.off(e, null, t)
        },
        delegate: function(e, t, n, r) {
          return this.on(t, e, n, r)
        },
        undelegate: function(e, t, n) {
          return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n)
        }
      }), k.proxy = function(e, t) {
        var n, r, i;
        if ("string" == typeof t && (n = e[t], t = e, e = n), m(e)) return r = s.call(arguments, 2), (i = function() {
          return e.apply(t || this, r.concat(s.call(arguments)))
        }).guid = e.guid = e.guid || k.guid++, i
      }, k.holdReady = function(e) {
        e ? k.readyWait++ : k.ready(!0)
      }, k.isArray = Array.isArray, k.parseJSON = JSON.parse, k.nodeName = A, k.isFunction = m, k.isWindow = x, k.camelCase = V, k.type = w, k.now = Date.now, k.isNumeric = function(e) {
        var t = k.type(e);
        return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e))
      }, "function" == typeof define && define.amd && define("jquery", [], function() {
        return k
      });
      var Qt = C.jQuery,
        Jt = C.$;
      return k.noConflict = function(e) {
        return C.$ === k && (C.$ = Jt), e && C.jQuery === k && (C.jQuery = Qt), k
      }, e || (C.jQuery = C.$ = k), k
    });
  </script>
  <script>
    /*!
     * PEP v0.3.0 | https://github.com/jquery/PEP
     * Copyright jQuery Foundation and other contributors | http://jquery.org/license
     */
    (function(global, factory) {
      typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
        typeof define === 'function' && define.amd ? define(factory) :
        global.PointerEventsPolyfill = factory()
    }(this, function() {
      'use strict';

      /**
       * This module implements an map of pointer states
       */
      var USE_MAP = window.Map && window.Map.prototype.forEach;
      var POINTERS_FN = function() {
        return this.size;
      };

      function PointerMap() {
        if (USE_MAP) {
          var m = new Map();
          m.pointers = POINTERS_FN;
          return m;
        } else {
          this.keys = [];
          this.values = [];
        }
      }

      PointerMap.prototype = {
        set: function(inId, inEvent) {
          var i = this.keys.indexOf(inId);
          if (i > -1) {
            this.values[i] = inEvent;
          } else {
            this.keys.push(inId);
            this.values.push(inEvent);
          }
        },
        has: function(inId) {
          return this.keys.indexOf(inId) > -1;
        },
        'delete': function(inId) {
          var i = this.keys.indexOf(inId);
          if (i > -1) {
            this.keys.splice(i, 1);
            this.values.splice(i, 1);
          }
        },
        get: function(inId) {
          var i = this.keys.indexOf(inId);
          return this.values[i];
        },
        clear: function() {
          this.keys.length = 0;
          this.values.length = 0;
        },
        // return value, key, map
        forEach: function(callback, thisArg) {
          this.values.forEach(function(v, i) {
            callback.call(thisArg, v, this.keys[i], this);
          }, this);
        },
        pointers: function() {
          return this.keys.length;
        }
      };

      var _pointermap = PointerMap;

      var CLONE_PROPS = [
        // MouseEvent
        'bubbles',
        'cancelable',
        'view',
        'detail',
        'screenX',
        'screenY',
        'clientX',
        'clientY',
        'ctrlKey',
        'altKey',
        'shiftKey',
        'metaKey',
        'button',
        'relatedTarget',
        // DOM Level 3
        'buttons',
        // PointerEvent
        'pointerId',
        'width',
        'height',
        'pressure',
        'tiltX',
        'tiltY',
        'pointerType',
        'hwTimestamp',
        'isPrimary',
        // event instance
        'type',
        'target',
        'currentTarget',
        'which',
        'pageX',
        'pageY',
        'timeStamp'
      ];

      var CLONE_DEFAULTS = [
        // MouseEvent
        false,
        false,
        null,
        null,
        0,
        0,
        0,
        0,
        false,
        false,
        false,
        false,
        0,
        null,
        // DOM Level 3
        0,
        // PointerEvent
        0,
        0,
        0,
        0,
        0,
        0,
        '',
        0,
        false,
        // event instance
        '',
        null,
        null,
        0,
        0,
        0,
        0
      ];

      var HAS_SVG_INSTANCE = (typeof SVGElementInstance !== 'undefined');

      /**
       * This module is for normalizing events. Mouse and Touch events will be
       * collected here, and fire PointerEvents that have the same semantics, no
       * matter the source.
       * Events fired:
       *   - pointerdown: a pointing is added
       *   - pointerup: a pointer is removed
       *   - pointermove: a pointer is moved
       *   - pointerover: a pointer crosses into an element
       *   - pointerout: a pointer leaves an element
       *   - pointercancel: a pointer will no longer generate events
       */
      var dispatcher = {
        pointermap: new _pointermap(),
        eventMap: Object.create(null),
        captureInfo: Object.create(null),
        // Scope objects for native events.
        // This exists for ease of testing.
        eventSources: Object.create(null),
        eventSourceList: [],
        /**
         * Add a new event source that will generate pointer events.
         *
         * `inSource` must contain an array of event names named `events`, and
         * functions with the names specified in the `events` array.
         * @param {string} name A name for the event source
         * @param {Object} source A new source of platform events.
         */
        registerSource: function(name, source) {
          var s = source;
          var newEvents = s.events;
          if (newEvents) {
            newEvents.forEach(function(e) {
              if (s[e]) {
                this.eventMap[e] = s[e].bind(s);
              }
            }, this);
            this.eventSources[name] = s;
            this.eventSourceList.push(s);
          }
        },
        register: function(element) {
          var l = this.eventSourceList.length;
          for (var i = 0, es;
            (i < l) && (es = this.eventSourceList[i]); i++) {
            // call eventsource register
            es.register.call(es, element);
          }
        },
        unregister: function(element) {
          var l = this.eventSourceList.length;
          for (var i = 0, es;
            (i < l) && (es = this.eventSourceList[i]); i++) {
            // call eventsource register
            es.unregister.call(es, element);
          }
        },
        contains: /*scope.external.contains || */ function(container, contained) {
          return container.contains(contained);
        },
        // EVENTS
        down: function(inEvent) {
          inEvent.bubbles = true;
          this.fireEvent('pointerdown', inEvent);
        },
        move: function(inEvent) {
          inEvent.bubbles = true;
          this.fireEvent('pointermove', inEvent);
        },
        up: function(inEvent) {
          inEvent.bubbles = true;
          this.fireEvent('pointerup', inEvent);
        },
        enter: function(inEvent) {
          inEvent.bubbles = false;
          this.fireEvent('pointerenter', inEvent);
        },
        leave: function(inEvent) {
          inEvent.bubbles = false;
          this.fireEvent('pointerleave', inEvent);
        },
        over: function(inEvent) {
          inEvent.bubbles = true;
          this.fireEvent('pointerover', inEvent);
        },
        out: function(inEvent) {
          inEvent.bubbles = true;
          this.fireEvent('pointerout', inEvent);
        },
        cancel: function(inEvent) {
          inEvent.bubbles = true;
          this.fireEvent('pointercancel', inEvent);
        },
        leaveOut: function(event) {
          this.out(event);
          if (!this.contains(event.target, event.relatedTarget)) {
            this.leave(event);
          }
        },
        enterOver: function(event) {
          this.over(event);
          if (!this.contains(event.target, event.relatedTarget)) {
            this.enter(event);
          }
        },
        // LISTENER LOGIC
        eventHandler: function(inEvent) {
          // This is used to prevent multiple dispatch of pointerevents from
          // platform events. This can happen when two elements in different scopes
          // are set up to create pointer events, which is relevant to Shadow DOM.
          if (inEvent._handledByPE) {
            return;
          }
          var type = inEvent.type;
          var fn = this.eventMap && this.eventMap[type];
          if (fn) {
            fn(inEvent);
          }
          inEvent._handledByPE = true;
        },
        // set up event listeners
        listen: function(target, events) {
          events.forEach(function(e) {
            this.addEvent(target, e);
          }, this);
        },
        // remove event listeners
        unlisten: function(target, events) {
          events.forEach(function(e) {
            this.removeEvent(target, e);
          }, this);
        },
        addEvent: /*scope.external.addEvent || */ function(target, eventName) {
          target.addEventListener(eventName, this.boundHandler);
        },
        removeEvent: /*scope.external.removeEvent || */ function(target, eventName) {
          target.removeEventListener(eventName, this.boundHandler);
        },
        // EVENT CREATION AND TRACKING
        /**
         * Creates a new Event of type `inType`, based on the information in
         * `inEvent`.
         *
         * @param {string} inType A string representing the type of event to create
         * @param {Event} inEvent A platform event with a target
         * @return {Event} A PointerEvent of type `inType`
         */
        makeEvent: function(inType, inEvent) {
          // relatedTarget must be null if pointer is captured
          if (this.captureInfo[inEvent.pointerId]) {
            inEvent.relatedTarget = null;
          }
          var e = new PointerEvent(inType, inEvent);
          if (inEvent.preventDefault) {
            e.preventDefault = inEvent.preventDefault;
          }
          e._target = e._target || inEvent.target;
          return e;
        },
        // make and dispatch an event in one call
        fireEvent: function(inType, inEvent) {
          var e = this.makeEvent(inType, inEvent);
          return this.dispatchEvent(e);
        },
        /**
         * Returns a snapshot of inEvent, with writable properties.
         *
         * @param {Event} inEvent An event that contains properties to copy.
         * @return {Object} An object containing shallow copies of `inEvent`'s
         *    properties.
         */
        cloneEvent: function(inEvent) {
          var eventCopy = Object.create(null),
            p;
          for (var i = 0; i < CLONE_PROPS.length; i++) {
            p = CLONE_PROPS[i];
            eventCopy[p] = inEvent[p] || CLONE_DEFAULTS[i];
            // Work around SVGInstanceElement shadow tree
            // Return the <use> element that is represented by the instance for Safari, Chrome, IE.
            // This is the behavior implemented by Firefox.
            if (HAS_SVG_INSTANCE && (p === 'target' || p === 'relatedTarget')) {
              if (eventCopy[p] instanceof SVGElementInstance) {
                eventCopy[p] = eventCopy[p].correspondingUseElement;
              }
            }
          }
          // keep the semantics of preventDefault
          if (inEvent.preventDefault) {
            eventCopy.preventDefault = function() {
              inEvent.preventDefault();
            };
          }
          return eventCopy;
        },
        getTarget: function(inEvent) {
          // if pointer capture is set, route all events for the specified pointerId
          // to the capture target
          return this.captureInfo[inEvent.pointerId] || inEvent._target;
        },
        setCapture: function(inPointerId, inTarget) {
          if (this.captureInfo[inPointerId]) {
            this.releaseCapture(inPointerId);
          }
          this.captureInfo[inPointerId] = inTarget;
          var e = document.createEvent('Event');
          e.initEvent('gotpointercapture', true, false);
          e.pointerId = inPointerId;
          this.implicitRelease = this.releaseCapture.bind(this, inPointerId);
          document.addEventListener('pointerup', this.implicitRelease);
          document.addEventListener('pointercancel', this.implicitRelease);
          e._target = inTarget;
          this.asyncDispatchEvent(e);
        },
        releaseCapture: function(inPointerId) {
          var t = this.captureInfo[inPointerId];
          if (t) {
            var e = document.createEvent('Event');
            e.initEvent('lostpointercapture', true, false);
            e.pointerId = inPointerId;
            this.captureInfo[inPointerId] = undefined;
            document.removeEventListener('pointerup', this.implicitRelease);
            document.removeEventListener('pointercancel', this.implicitRelease);
            e._target = t;
            this.asyncDispatchEvent(e);
          }
        },
        /**
         * Dispatches the event to its target.
         *
         * @param {Event} inEvent The event to be dispatched.
         * @return {Boolean} True if an event handler returns true, false otherwise.
         */
        dispatchEvent: /*scope.external.dispatchEvent || */ function(inEvent) {
          var t = this.getTarget(inEvent);
          if (t) {
            return t.dispatchEvent(inEvent);
          }
        },
        asyncDispatchEvent: function(inEvent) {
          requestAnimationFrame(this.dispatchEvent.bind(this, inEvent));
        }
      };
      dispatcher.boundHandler = dispatcher.eventHandler.bind(dispatcher);

      var _dispatcher = dispatcher;

      var targeting = {
        shadow: function(inEl) {
          if (inEl) {
            return inEl.shadowRoot || inEl.webkitShadowRoot;
          }
        },
        canTarget: function(shadow) {
          return shadow && Boolean(shadow.elementFromPoint);
        },
        targetingShadow: function(inEl) {
          var s = this.shadow(inEl);
          if (this.canTarget(s)) {
            return s;
          }
        },
        olderShadow: function(shadow) {
          var os = shadow.olderShadowRoot;
          if (!os) {
            var se = shadow.querySelector('shadow');
            if (se) {
              os = se.olderShadowRoot;
            }
          }
          return os;
        },
        allShadows: function(element) {
          var shadows = [],
            s = this.shadow(element);
          while (s) {
            shadows.push(s);
            s = this.olderShadow(s);
          }
          return shadows;
        },
        searchRoot: function(inRoot, x, y) {
          if (inRoot) {
            var t = inRoot.elementFromPoint(x, y);
            var st, sr, os;
            // is element a shadow host?
            sr = this.targetingShadow(t);
            while (sr) {
              // find the the element inside the shadow root
              st = sr.elementFromPoint(x, y);
              if (!st) {
                // check for older shadows
                sr = this.olderShadow(sr);
              } else {
                // shadowed element may contain a shadow root
                var ssr = this.targetingShadow(st);
                return this.searchRoot(ssr, x, y) || st;
              }
            }
            // light dom element is the target
            return t;
          }
        },
        owner: function(element) {
          var s = element;
          // walk up until you hit the shadow root or document
          while (s.parentNode) {
            s = s.parentNode;
          }
          // the owner element is expected to be a Document or ShadowRoot
          if (s.nodeType != Node.DOCUMENT_NODE && s.nodeType != Node.DOCUMENT_FRAGMENT_NODE) {
            s = document;
          }
          return s;
        },
        findTarget: function(inEvent) {
          var x = inEvent.clientX,
            y = inEvent.clientY;
          // if the listener is in the shadow root, it is much faster to start there
          var s = this.owner(inEvent.target);
          // if x, y is not in this root, fall back to document search
          if (!s.elementFromPoint(x, y)) {
            s = document;
          }
          return this.searchRoot(s, x, y);
        }
      };

      /**
       * This module uses Mutation Observers to dynamically adjust which nodes will
       * generate Pointer Events.
       *
       * All nodes that wish to generate Pointer Events must have the attribute
       * `touch-action` set to `none`.
       */
      var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
      var map = Array.prototype.map.call.bind(Array.prototype.map);
      var toArray = Array.prototype.slice.call.bind(Array.prototype.slice);
      var filter = Array.prototype.filter.call.bind(Array.prototype.filter);
      var MO = window.MutationObserver || window.WebKitMutationObserver;
      var SELECTOR = '[touch-action]';
      var OBSERVER_INIT = {
        subtree: true,
        childList: true,
        attributes: true,
        attributeOldValue: true,
        attributeFilter: ['touch-action']
      };

      function Installer(add, remove, changed, binder) {
        this.addCallback = add.bind(binder);
        this.removeCallback = remove.bind(binder);
        this.changedCallback = changed.bind(binder);
        if (MO) {
          this.observer = new MO(this.mutationWatcher.bind(this));
        }
      }

      Installer.prototype = {
        watchSubtree: function(target) {
          // Only watch scopes that can target find, as these are top-level.
          // Otherwise we can see duplicate additions and removals that add noise.
          //
          // TODO(dfreedman): For some instances with ShadowDOMPolyfill, we can see
          // a removal without an insertion when a node is redistributed among
          // shadows. Since it all ends up correct in the document, watching only
          // the document will yield the correct mutations to watch.
          if (targeting.canTarget(target)) {
            this.observer.observe(target, OBSERVER_INIT);
          }
        },
        enableOnSubtree: function(target) {
          this.watchSubtree(target);
          if (target === document && document.readyState !== 'complete') {
            this.installOnLoad();
          } else {
            this.installNewSubtree(target);
          }
        },
        installNewSubtree: function(target) {
          forEach(this.findElements(target), this.addElement, this);
        },
        findElements: function(target) {
          if (target.querySelectorAll) {
            return target.querySelectorAll(SELECTOR);
          }
          return [];
        },
        removeElement: function(el) {
          this.removeCallback(el);
        },
        addElement: function(el) {
          this.addCallback(el);
        },
        elementChanged: function(el, oldValue) {
          this.changedCallback(el, oldValue);
        },
        concatLists: function(accum, list) {
          return accum.concat(toArray(list));
        },
        // register all touch-action = none nodes on document load
        installOnLoad: function() {
          document.addEventListener('readystatechange', function() {
            if (document.readyState === 'complete') {
              this.installNewSubtree(document);
            }
          }.bind(this));
        },
        isElement: function(n) {
          return n.nodeType === Node.ELEMENT_NODE;
        },
        flattenMutationTree: function(inNodes) {
          // find children with touch-action
          var tree = map(inNodes, this.findElements, this);
          // make sure the added nodes are accounted for
          tree.push(filter(inNodes, this.isElement));
          // flatten the list
          return tree.reduce(this.concatLists, []);
        },
        mutationWatcher: function(mutations) {
          mutations.forEach(this.mutationHandler, this);
        },
        mutationHandler: function(m) {
          if (m.type === 'childList') {
            var added = this.flattenMutationTree(m.addedNodes);
            added.forEach(this.addElement, this);
            var removed = this.flattenMutationTree(m.removedNodes);
            removed.forEach(this.removeElement, this);
          } else if (m.type === 'attributes') {
            this.elementChanged(m.target, m.oldValue);
          }
        }
      };

      if (!MO) {
        Installer.prototype.watchSubtree = function() {
          console.warn('PointerEventsPolyfill: MutationObservers not found, touch-action will not be dynamically detected');
        };
      }

      var installer = Installer;

      /**
       * This is the constructor for new PointerEvents.
       *
       * New Pointer Events must be given a type, and an optional dictionary of
       * initialization properties.
       *
       * Due to certain platform requirements, events returned from the constructor
       * identify as MouseEvents.
       *
       * @constructor
       * @param {String} inType The type of the event to create.
       * @param {Object} [inDict] An optional dictionary of initial event properties.
       * @return {Event} A new PointerEvent of type `inType` and initialized with properties from `inDict`.
       */
      var MOUSE_PROPS = [
        'bubbles',
        'cancelable',
        'view',
        'detail',
        'screenX',
        'screenY',
        'clientX',
        'clientY',
        'ctrlKey',
        'altKey',
        'shiftKey',
        'metaKey',
        'button',
        'relatedTarget',
        'pageX',
        'pageY'
      ];

      var MOUSE_DEFAULTS = [
        false,
        false,
        null,
        null,
        0,
        0,
        0,
        0,
        false,
        false,
        false,
        false,
        0,
        null,
        0,
        0
      ];

      function _PointerEvent__PointerEvent(inType, inDict) {
        inDict = inDict || Object.create(null);

        var e = document.createEvent('Event');
        e.initEvent(inType, inDict.bubbles || false, inDict.cancelable || false);

        // define inherited MouseEvent properties
        // skip bubbles and cancelable since they're set above in initEvent()
        for (var i = 2, p; i < MOUSE_PROPS.length; i++) {
          p = MOUSE_PROPS[i];
          e[p] = inDict[p] || MOUSE_DEFAULTS[i];
        }
        e.buttons = inDict.buttons || 0;

        // Spec requires that pointers without pressure specified use 0.5 for down
        // state and 0 for up state.
        var pressure = 0;
        if (inDict.pressure) {
          pressure = inDict.pressure;
        } else {
          pressure = e.buttons ? 0.5 : 0;
        }

        // add x/y properties aliased to clientX/Y
        e.x = e.clientX;
        e.y = e.clientY;

        // define the properties of the PointerEvent interface
        e.pointerId = inDict.pointerId || 0;
        e.width = inDict.width || 0;
        e.height = inDict.height || 0;
        e.pressure = pressure;
        e.tiltX = inDict.tiltX || 0;
        e.tiltY = inDict.tiltY || 0;
        e.pointerType = inDict.pointerType || '';
        e.hwTimestamp = inDict.hwTimestamp || 0;
        e.isPrimary = inDict.isPrimary || false;
        return e;
      }

      var _PointerEvent = _PointerEvent__PointerEvent;

      function shadowSelector(v) {
        return 'body /shadow-deep/ ' + selector(v);
      }

      function selector(v) {
        return '[touch-action="' + v + '"]';
      }

      function rule(v) {
        return '{ -ms-touch-action: ' + v + '; touch-action: ' + v + '; touch-action-delay: none; }';
      }
      var attrib2css = [
        'none',
        'auto',
        'pan-x',
        'pan-y',
        {
          rule: 'pan-x pan-y',
          selectors: [
            'pan-x pan-y',
            'pan-y pan-x'
          ]
        }
      ];
      var styles = '';
      // only install stylesheet if the browser has touch action support
      var head = document.head;
      var hasNativePE = window.PointerEvent || window.MSPointerEvent;
      // only add shadow selectors if shadowdom is supported
      var hasShadowRoot = !window.ShadowDOMPolyfill && document.head.createShadowRoot;

      function applyAttributeStyles() {
        if (hasNativePE) {
          attrib2css.forEach(function(r) {
            if (String(r) === r) {
              styles += selector(r) + rule(r) + '\n';
              if (hasShadowRoot) {
                styles += shadowSelector(r) + rule(r) + '\n';
              }
            } else {
              styles += r.selectors.map(selector) + rule(r.rule) + '\n';
              if (hasShadowRoot) {
                styles += r.selectors.map(shadowSelector) + rule(r.rule) + '\n';
              }
            }
          });

          var el = document.createElement('style');
          el.textContent = styles;
          document.head.appendChild(el);
        }
      }

      var mouse__pointermap = _dispatcher.pointermap;
      // radius around touchend that swallows mouse events
      var DEDUP_DIST = 25;

      var WHICH_TO_BUTTONS = [0, 1, 4, 2];

      var HAS_BUTTONS = false;
      try {
        HAS_BUTTONS = new MouseEvent('test', {
          buttons: 1
        }).buttons === 1;
      } catch (e) {}

      // handler block for native mouse events
      var mouseEvents = {
        POINTER_ID: 1,
        POINTER_TYPE: 'mouse',
        events: [
          'mousedown',
          'mousemove',
          'mouseup',
          'mouseover',
          'mouseout'
        ],
        register: function(target) {
          _dispatcher.listen(target, this.events);
        },
        unregister: function(target) {
          _dispatcher.unlisten(target, this.events);
        },
        lastTouches: [],
        // collide with the global mouse listener
        isEventSimulatedFromTouch: function(inEvent) {
          var lts = this.lastTouches;
          var x = inEvent.clientX,
            y = inEvent.clientY;
          for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {
            // simulated mouse events will be swallowed near a primary touchend
            var dx = Math.abs(x - t.x),
              dy = Math.abs(y - t.y);
            if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {
              return true;
            }
          }
        },
        prepareEvent: function(inEvent) {
          var e = _dispatcher.cloneEvent(inEvent);
          // forward mouse preventDefault
          var pd = e.preventDefault;
          e.preventDefault = function() {
            inEvent.preventDefault();
            pd();
          };
          e.pointerId = this.POINTER_ID;
          e.isPrimary = true;
          e.pointerType = this.POINTER_TYPE;
          if (!HAS_BUTTONS) {
            e.buttons = WHICH_TO_BUTTONS[e.which] || 0;
          }
          return e;
        },
        mousedown: function(inEvent) {
          if (!this.isEventSimulatedFromTouch(inEvent)) {
            var p = mouse__pointermap.has(this.POINTER_ID);
            // TODO(dfreedman) workaround for some elements not sending mouseup
            // http://crbug/149091
            if (p) {
              this.cancel(inEvent);
            }
            var e = this.prepareEvent(inEvent);
            mouse__pointermap.set(this.POINTER_ID, inEvent);
            _dispatcher.down(e);
          }
        },
        mousemove: function(inEvent) {
          if (!this.isEventSimulatedFromTouch(inEvent)) {
            var e = this.prepareEvent(inEvent);
            _dispatcher.move(e);
          }
        },
        mouseup: function(inEvent) {
          if (!this.isEventSimulatedFromTouch(inEvent)) {
            var p = mouse__pointermap.get(this.POINTER_ID);
            if (p && p.button === inEvent.button) {
              var e = this.prepareEvent(inEvent);
              _dispatcher.up(e);
              this.cleanupMouse();
            }
          }
        },
        mouseover: function(inEvent) {
          if (!this.isEventSimulatedFromTouch(inEvent)) {
            var e = this.prepareEvent(inEvent);
            _dispatcher.enterOver(e);
          }
        },
        mouseout: function(inEvent) {
          if (!this.isEventSimulatedFromTouch(inEvent)) {
            var e = this.prepareEvent(inEvent);
            _dispatcher.leaveOut(e);
          }
        },
        cancel: function(inEvent) {
          var e = this.prepareEvent(inEvent);
          _dispatcher.cancel(e);
          this.cleanupMouse();
        },
        cleanupMouse: function() {
          mouse__pointermap['delete'](this.POINTER_ID);
        }
      };

      var mouse = mouseEvents;

      var captureInfo = _dispatcher.captureInfo;
      var findTarget = targeting.findTarget.bind(targeting);
      var allShadows = targeting.allShadows.bind(targeting);
      var touch__pointermap = _dispatcher.pointermap;
      var touchMap = Array.prototype.map.call.bind(Array.prototype.map);
      // This should be long enough to ignore compat mouse events made by touch
      var DEDUP_TIMEOUT = 2500;
      var CLICK_COUNT_TIMEOUT = 200;
      var ATTRIB = 'touch-action';
      var INSTALLER;
      // The presence of touch event handlers blocks scrolling, and so we must be careful to
      // avoid adding handlers unnecessarily.  Chrome plans to add a touch-action-delay property
      // (crbug.com/329559) to address this, and once we have that we can opt-in to a simpler
      // handler registration mechanism.  Rather than try to predict how exactly to opt-in to
      // that we'll just leave this disabled until there is a build of Chrome to test.
      var HAS_TOUCH_ACTION_DELAY = false;

      // handler block for native touch events
      var touchEvents = {
        events: [
          'touchstart',
          'touchmove',
          'touchend',
          'touchcancel'
        ],
        register: function(target) {
          if (HAS_TOUCH_ACTION_DELAY) {
            _dispatcher.listen(target, this.events);
          } else {
            INSTALLER.enableOnSubtree(target);
          }
        },
        unregister: function(target) {
          if (HAS_TOUCH_ACTION_DELAY) {
            _dispatcher.unlisten(target, this.events);
          } else {
            // TODO(dfreedman): is it worth it to disconnect the MO?
          }
        },
        elementAdded: function(el) {
          var a = el.getAttribute(ATTRIB);
          var st = this.touchActionToScrollType(a);
          if (st) {
            el._scrollType = st;
            _dispatcher.listen(el, this.events);
            // set touch-action on shadows as well
            allShadows(el).forEach(function(s) {
              s._scrollType = st;
              _dispatcher.listen(s, this.events);
            }, this);
          }
        },
        elementRemoved: function(el) {
          el._scrollType = undefined;
          _dispatcher.unlisten(el, this.events);
          // remove touch-action from shadow
          allShadows(el).forEach(function(s) {
            s._scrollType = undefined;
            _dispatcher.unlisten(s, this.events);
          }, this);
        },
        elementChanged: function(el, oldValue) {
          var a = el.getAttribute(ATTRIB);
          var st = this.touchActionToScrollType(a);
          var oldSt = this.touchActionToScrollType(oldValue);
          // simply update scrollType if listeners are already established
          if (st && oldSt) {
            el._scrollType = st;
            allShadows(el).forEach(function(s) {
              s._scrollType = st;
            }, this);
          } else if (oldSt) {
            this.elementRemoved(el);
          } else if (st) {
            this.elementAdded(el);
          }
        },
        scrollTypes: {
          EMITTER: 'none',
          XSCROLLER: 'pan-x',
          YSCROLLER: 'pan-y',
          SCROLLER: /^(?:pan-x pan-y)|(?:pan-y pan-x)|auto$/
        },
        touchActionToScrollType: function(touchAction) {
          var t = touchAction;
          var st = this.scrollTypes;
          if (t === 'none') {
            return 'none';
          } else if (t === st.XSCROLLER) {
            return 'X';
          } else if (t === st.YSCROLLER) {
            return 'Y';
          } else if (st.SCROLLER.exec(t)) {
            return 'XY';
          }
        },
        POINTER_TYPE: 'touch',
        firstTouch: null,
        isPrimaryTouch: function(inTouch) {
          return this.firstTouch === inTouch.identifier;
        },
        setPrimaryTouch: function(inTouch) {
          // set primary touch if there no pointers, or the only pointer is the mouse
          if (touch__pointermap.pointers() === 0 || (touch__pointermap.pointers() === 1 && touch__pointermap.has(1))) {
            this.firstTouch = inTouch.identifier;
            this.firstXY = {
              X: inTouch.clientX,
              Y: inTouch.clientY
            };
            this.scrolling = false;
            this.cancelResetClickCount();
          }
        },
        removePrimaryPointer: function(inPointer) {
          if (inPointer.isPrimary) {
            this.firstTouch = null;
            this.firstXY = null;
            this.resetClickCount();
          }
        },
        clickCount: 0,
        resetId: null,
        resetClickCount: function() {
          var fn = function() {
            this.clickCount = 0;
            this.resetId = null;
          }.bind(this);
          this.resetId = setTimeout(fn, CLICK_COUNT_TIMEOUT);
        },
        cancelResetClickCount: function() {
          if (this.resetId) {
            clearTimeout(this.resetId);
          }
        },
        typeToButtons: function(type) {
          var ret = 0;
          if (type === 'touchstart' || type === 'touchmove') {
            ret = 1;
          }
          return ret;
        },
        touchToPointer: function(inTouch) {
          var cte = this.currentTouchEvent;
          var e = _dispatcher.cloneEvent(inTouch);
          // Spec specifies that pointerId 1 is reserved for Mouse.
          // Touch identifiers can start at 0.
          // Add 2 to the touch identifier for compatibility.
          var id = e.pointerId = inTouch.identifier + 2;
          e.target = captureInfo[id] || findTarget(e);
          e.bubbles = true;
          e.cancelable = true;
          e.detail = this.clickCount;
          e.button = 0;
          e.buttons = this.typeToButtons(cte.type);
          e.width = inTouch.webkitRadiusX || inTouch.radiusX || 0;
          e.height = inTouch.webkitRadiusY || inTouch.radiusY || 0;
          e.pressure = inTouch.webkitForce || inTouch.force || 0.5;
          e.isPrimary = this.isPrimaryTouch(inTouch);
          e.pointerType = this.POINTER_TYPE;
          // forward touch preventDefaults
          var self = this;
          e.preventDefault = function() {
            self.scrolling = false;
            self.firstXY = null;
            cte.preventDefault();
          };
          return e;
        },
        processTouches: function(inEvent, inFunction) {
          var tl = inEvent.changedTouches;
          this.currentTouchEvent = inEvent;
          for (var i = 0, t; i < tl.length; i++) {
            t = tl[i];
            inFunction.call(this, this.touchToPointer(t));
          }
        },
        // For single axis scrollers, determines whether the element should emit
        // pointer events or behave as a scroller
        shouldScroll: function(inEvent) {
          if (this.firstXY) {
            var ret;
            var scrollAxis = inEvent.currentTarget._scrollType;
            if (scrollAxis === 'none') {
              // this element is a touch-action: none, should never scroll
              ret = false;
            } else if (scrollAxis === 'XY') {
              // this element should always scroll
              ret = true;
            } else {
              var t = inEvent.changedTouches[0];
              // check the intended scroll axis, and other axis
              var a = scrollAxis;
              var oa = scrollAxis === 'Y' ? 'X' : 'Y';
              var da = Math.abs(t['client' + a] - this.firstXY[a]);
              var doa = Math.abs(t['client' + oa] - this.firstXY[oa]);
              // if delta in the scroll axis > delta other axis, scroll instead of
              // making events
              ret = da >= doa;
            }
            this.firstXY = null;
            return ret;
          }
        },
        findTouch: function(inTL, inId) {
          for (var i = 0, l = inTL.length, t; i < l && (t = inTL[i]); i++) {
            if (t.identifier === inId) {
              return true;
            }
          }
        },
        // In some instances, a touchstart can happen without a touchend. This
        // leaves the pointermap in a broken state.
        // Therefore, on every touchstart, we remove the touches that did not fire a
        // touchend event.
        // To keep state globally consistent, we fire a
        // pointercancel for this "abandoned" touch
        vacuumTouches: function(inEvent) {
          var tl = inEvent.touches;
          // pointermap.pointers() should be < tl.length here, as the touchstart has not
          // been processed yet.
          if (touch__pointermap.pointers() >= tl.length) {
            var d = [];
            touch__pointermap.forEach(function(value, key) {
              // Never remove pointerId == 1, which is mouse.
              // Touch identifiers are 2 smaller than their pointerId, which is the
              // index in pointermap.
              if (key !== 1 && !this.findTouch(tl, key - 2)) {
                var p = value.out;
                d.push(p);
              }
            }, this);
            d.forEach(this.cancelOut, this);
          }
        },
        touchstart: function(inEvent) {
          this.vacuumTouches(inEvent);
          this.setPrimaryTouch(inEvent.changedTouches[0]);
          this.dedupSynthMouse(inEvent);
          if (!this.scrolling) {
            this.clickCount++;
            this.processTouches(inEvent, this.overDown);
          }
        },
        overDown: function(inPointer) {
          var p = touch__pointermap.set(inPointer.pointerId, {
            target: inPointer.target,
            out: inPointer,
            outTarget: inPointer.target
          });
          _dispatcher.over(inPointer);
          _dispatcher.enter(inPointer);
          _dispatcher.down(inPointer);
        },
        touchmove: function(inEvent) {
          if (!this.scrolling) {
            if (this.shouldScroll(inEvent)) {
              this.scrolling = true;
              this.touchcancel(inEvent);
            } else {
              inEvent.preventDefault();
              this.processTouches(inEvent, this.moveOverOut);
            }
          }
        },
        moveOverOut: function(inPointer) {
          var event = inPointer;
          var pointer = touch__pointermap.get(event.pointerId);
          // a finger drifted off the screen, ignore it
          if (!pointer) {
            return;
          }
          var outEvent = pointer.out;
          var outTarget = pointer.outTarget;
          _dispatcher.move(event);
          if (outEvent && outTarget !== event.target) {
            outEvent.relatedTarget = event.target;
            event.relatedTarget = outTarget;
            // recover from retargeting by shadow
            outEvent.target = outTarget;
            if (event.target) {
              _dispatcher.leaveOut(outEvent);
              _dispatcher.enterOver(event);
            } else {
              // clean up case when finger leaves the screen
              event.target = outTarget;
              event.relatedTarget = null;
              this.cancelOut(event);
            }
          }
          pointer.out = event;
          pointer.outTarget = event.target;
        },
        touchend: function(inEvent) {
          this.dedupSynthMouse(inEvent);
          this.processTouches(inEvent, this.upOut);
        },
        upOut: function(inPointer) {
          if (!this.scrolling) {
            _dispatcher.up(inPointer);
            _dispatcher.out(inPointer);
            _dispatcher.leave(inPointer);
          }
          this.cleanUpPointer(inPointer);
        },
        touchcancel: function(inEvent) {
          this.processTouches(inEvent, this.cancelOut);
        },
        cancelOut: function(inPointer) {
          _dispatcher.cancel(inPointer);
          _dispatcher.out(inPointer);
          _dispatcher.leave(inPointer);
          this.cleanUpPointer(inPointer);
        },
        cleanUpPointer: function(inPointer) {
          touch__pointermap['delete'](inPointer.pointerId);
          this.removePrimaryPointer(inPointer);
        },
        // prevent synth mouse events from creating pointer events
        dedupSynthMouse: function(inEvent) {
          var lts = mouse.lastTouches;
          var t = inEvent.changedTouches[0];
          // only the primary finger will synth mouse events
          if (this.isPrimaryTouch(t)) {
            // remember x/y of last touch
            var lt = {
              x: t.clientX,
              y: t.clientY
            };
            lts.push(lt);
            var fn = (function(lts, lt) {
              var i = lts.indexOf(lt);
              if (i > -1) {
                lts.splice(i, 1);
              }
            }).bind(null, lts, lt);
            setTimeout(fn, DEDUP_TIMEOUT);
          }
        }
      };

      if (!HAS_TOUCH_ACTION_DELAY) {
        INSTALLER = new installer(touchEvents.elementAdded, touchEvents.elementRemoved, touchEvents.elementChanged, touchEvents);
      }

      var touch = touchEvents;

      var ms__pointermap = _dispatcher.pointermap;
      var HAS_BITMAP_TYPE = window.MSPointerEvent && typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE === 'number';
      var msEvents = {
        events: [
          'MSPointerDown',
          'MSPointerMove',
          'MSPointerUp',
          'MSPointerOut',
          'MSPointerOver',
          'MSPointerCancel',
          'MSGotPointerCapture',
          'MSLostPointerCapture'
        ],
        register: function(target) {
          _dispatcher.listen(target, this.events);
        },
        unregister: function(target) {
          _dispatcher.unlisten(target, this.events);
        },
        POINTER_TYPES: [
          '',
          'unavailable',
          'touch',
          'pen',
          'mouse'
        ],
        prepareEvent: function(inEvent) {
          var e = inEvent;
          if (HAS_BITMAP_TYPE) {
            e = _dispatcher.cloneEvent(inEvent);
            e.pointerType = this.POINTER_TYPES[inEvent.pointerType];
          }
          return e;
        },
        cleanup: function(id) {
          ms__pointermap['delete'](id);
        },
        MSPointerDown: function(inEvent) {
          ms__pointermap.set(inEvent.pointerId, inEvent);
          var e = this.prepareEvent(inEvent);
          _dispatcher.down(e);
        },
        MSPointerMove: function(inEvent) {
          var e = this.prepareEvent(inEvent);
          _dispatcher.move(e);
        },
        MSPointerUp: function(inEvent) {
          var e = this.prepareEvent(inEvent);
          _dispatcher.up(e);
          this.cleanup(inEvent.pointerId);
        },
        MSPointerOut: function(inEvent) {
          var e = this.prepareEvent(inEvent);
          _dispatcher.leaveOut(e);
        },
        MSPointerOver: function(inEvent) {
          var e = this.prepareEvent(inEvent);
          _dispatcher.enterOver(e);
        },
        MSPointerCancel: function(inEvent) {
          var e = this.prepareEvent(inEvent);
          _dispatcher.cancel(e);
          this.cleanup(inEvent.pointerId);
        },
        MSLostPointerCapture: function(inEvent) {
          var e = _dispatcher.makeEvent('lostpointercapture', inEvent);
          _dispatcher.dispatchEvent(e);
        },
        MSGotPointerCapture: function(inEvent) {
          var e = _dispatcher.makeEvent('gotpointercapture', inEvent);
          _dispatcher.dispatchEvent(e);
        }
      };

      var ms = msEvents;

      function platform_events__applyPolyfill() {
        // only activate if this platform does not have pointer events
        if (!window.PointerEvent) {
          window.PointerEvent = _PointerEvent;

          if (window.navigator.msPointerEnabled) {
            var tp = window.navigator.msMaxTouchPoints;
            Object.defineProperty(window.navigator, 'maxTouchPoints', {
              value: tp,
              enumerable: true
            });
            _dispatcher.registerSource('ms', ms);
          } else {
            _dispatcher.registerSource('mouse', mouse);
            if (window.ontouchstart !== undefined) {
              _dispatcher.registerSource('touch', touch);
            }
          }

          _dispatcher.register(document);
        }
      }

      var n = window.navigator;
      var s, r;

      function assertDown(id) {
        if (!_dispatcher.pointermap.has(id)) {
          throw new Error('InvalidPointerId');
        }
      }
      if (n.msPointerEnabled) {
        s = function(pointerId) {
          assertDown(pointerId);
          this.msSetPointerCapture(pointerId);
        };
        r = function(pointerId) {
          assertDown(pointerId);
          this.msReleasePointerCapture(pointerId);
        };
      } else {
        s = function setPointerCapture(pointerId) {
          assertDown(pointerId);
          _dispatcher.setCapture(pointerId, this);
        };
        r = function releasePointerCapture(pointerId) {
          assertDown(pointerId);
          _dispatcher.releaseCapture(pointerId, this);
        };
      }

      function capture__applyPolyfill() {
        if (window.Element && !Element.prototype.setPointerCapture) {
          Object.defineProperties(Element.prototype, {
            'setPointerCapture': {
              value: s
            },
            'releasePointerCapture': {
              value: r
            }
          });
        }
      }

      applyAttributeStyles();
      platform_events__applyPolyfill();
      capture__applyPolyfill();

      var pointerevents = {
        dispatcher: _dispatcher,
        Installer: installer,
        PointerEvent: _PointerEvent,
        PointerMap: _pointermap,
        targetFinding: targeting
      };

      return pointerevents;

    }));
  </script>
  <script>
    /* canvas-toBlob.js
     * A canvas.toBlob() implementation.
     * 2013-12-27
     * 
     * By Eli Grey, http://eligrey.com and Devin Samarin, https://github.com/eboyjr
     * License: X11/MIT
     *   See LICENSE.md
     */

    /*global self */
    /*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
      plusplus: true */

    /*! @source http://purl.eligrey.com/github/canvas-toBlob.js/blob/master/canvas-toBlob.js */

    (function(view) {
      "use strict";
      var
        Uint8Array = view.Uint8Array,
        HTMLCanvasElement = view.HTMLCanvasElement,
        canvas_proto = HTMLCanvasElement && HTMLCanvasElement.prototype,
        is_base64_regex = /\s*;\s*base64\s*(?:;|$)/i,
        to_data_url = "toDataURL",
        base64_ranks, decode_base64 = function(base64) {
          var
            len = base64.length,
            buffer = new Uint8Array(len / 4 * 3 | 0),
            i = 0,
            outptr = 0,
            last = [0, 0],
            state = 0,
            save = 0,
            rank, code, undef;
          while (len--) {
            code = base64.charCodeAt(i++);
            rank = base64_ranks[code - 43];
            if (rank !== 255 && rank !== undef) {
              last[1] = last[0];
              last[0] = code;
              save = (save << 6) | rank;
              state++;
              if (state === 4) {
                buffer[outptr++] = save >>> 16;
                if (last[1] !== 61 /* padding character */ ) {
                  buffer[outptr++] = save >>> 8;
                }
                if (last[0] !== 61 /* padding character */ ) {
                  buffer[outptr++] = save;
                }
                state = 0;
              }
            }
          }
          // 2/3 chance there's going to be some null bytes at the end, but that
          // doesn't really matter with most image formats.
          // If it somehow matters for you, truncate the buffer up outptr.
          return buffer;
        };
      if (Uint8Array) {
        base64_ranks = new Uint8Array([
          62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 0, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
        ]);
      }
      if (HTMLCanvasElement && !canvas_proto.toBlob) {
        canvas_proto.toBlob = function(callback, type /*, ...args*/ ) {
          if (!type) {
            type = "image/png";
          }
          if (this.mozGetAsFile) {
            callback(this.mozGetAsFile("canvas", type));
            return;
          }
          var
            args = Array.prototype.slice.call(arguments, 1),
            dataURI = this[to_data_url].apply(this, args),
            header_end = dataURI.indexOf(","),
            data = dataURI.substring(header_end + 1),
            is_base64 = is_base64_regex.test(dataURI.substring(0, header_end)),
            blob;
          if (Blob.fake) {
            // no reason to decode a data: URI that's just going to become a data URI again
            blob = new Blob
            if (is_base64) {
              blob.encoding = "base64";
            } else {
              blob.encoding = "URI";
            }
            blob.data = data;
            blob.size = data.length;
          } else if (Uint8Array) {
            if (is_base64) {
              blob = new Blob([decode_base64(data)], {
                type: type
              });
            } else {
              blob = new Blob([decodeURIComponent(data)], {
                type: type
              });
            }
          }
          callback(blob);
        };

        if (canvas_proto.toDataURLHD) {
          canvas_proto.toBlobHD = function() {
            to_data_url = "toDataURLHD";
            var blob = this.toBlob();
            to_data_url = "toDataURL";
            return blob;
          }
        } else {
          canvas_proto.toBlobHD = canvas_proto.toBlob;
        }
      }
    }(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content || this));
  </script>
  <script>
    // gif.js @ https://github.com/jnordberg/gif.js/tree/92d27a02841339e202c75150dcf6fe5f4fa42ec5
    (function(f) {
      if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f()
      } else if (typeof define === "function" && define.amd) {
        define([], f)
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window
        } else if (typeof global !== "undefined") {
          g = global
        } else if (typeof self !== "undefined") {
          g = self
        } else {
          g = this
        }
        g.GIF = f()
      }
    })(function() {
      var define, module, exports;
      return function() {
        function r(e, n, t) {
          function o(i, f) {
            if (!n[i]) {
              if (!e[i]) {
                var c = "function" == typeof require && require;
                if (!f && c) return c(i, !0);
                if (u) return u(i, !0);
                var a = new Error("Cannot find module '" + i + "'");
                throw a.code = "MODULE_NOT_FOUND", a
              }
              var p = n[i] = {
                exports: {}
              };
              e[i][0].call(p.exports, function(r) {
                var n = e[i][1][r];
                return o(n || r)
              }, p, p.exports, r, e, n, t)
            }
            return n[i].exports
          }
          for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
          return o
        }
        return r
      }()({
        1: [function(require, module, exports) {
          function EventEmitter() {
            this._events = this._events || {};
            this._maxListeners = this._maxListeners || undefined
          }
          module.exports = EventEmitter;
          EventEmitter.EventEmitter = EventEmitter;
          EventEmitter.prototype._events = undefined;
          EventEmitter.prototype._maxListeners = undefined;
          EventEmitter.defaultMaxListeners = 10;
          EventEmitter.prototype.setMaxListeners = function(n) {
            if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError("n must be a positive number");
            this._maxListeners = n;
            return this
          };
          EventEmitter.prototype.emit = function(type) {
            var er, handler, len, args, i, listeners;
            if (!this._events) this._events = {};
            if (type === "error") {
              if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
                er = arguments[1];
                if (er instanceof Error) {
                  throw er
                } else {
                  var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
                  err.context = er;
                  throw err
                }
              }
            }
            handler = this._events[type];
            if (isUndefined(handler)) return false;
            if (isFunction(handler)) {
              switch (arguments.length) {
                case 1:
                  handler.call(this);
                  break;
                case 2:
                  handler.call(this, arguments[1]);
                  break;
                case 3:
                  handler.call(this, arguments[1], arguments[2]);
                  break;
                default:
                  args = Array.prototype.slice.call(arguments, 1);
                  handler.apply(this, args)
              }
            } else if (isObject(handler)) {
              args = Array.prototype.slice.call(arguments, 1);
              listeners = handler.slice();
              len = listeners.length;
              for (i = 0; i < len; i++) listeners[i].apply(this, args)
            }
            return true
          };
          EventEmitter.prototype.addListener = function(type, listener) {
            var m;
            if (!isFunction(listener)) throw TypeError("listener must be a function");
            if (!this._events) this._events = {};
            if (this._events.newListener) this.emit("newListener", type, isFunction(listener.listener) ? listener.listener : listener);
            if (!this._events[type]) this._events[type] = listener;
            else if (isObject(this._events[type])) this._events[type].push(listener);
            else this._events[type] = [this._events[type], listener];
            if (isObject(this._events[type]) && !this._events[type].warned) {
              if (!isUndefined(this._maxListeners)) {
                m = this._maxListeners
              } else {
                m = EventEmitter.defaultMaxListeners
              }
              if (m && m > 0 && this._events[type].length > m) {
                this._events[type].warned = true;
                console.error("(node) warning: possible EventEmitter memory " + "leak detected. %d listeners added. " + "Use emitter.setMaxListeners() to increase limit.", this._events[type].length);
                if (typeof console.trace === "function") {
                  console.trace()
                }
              }
            }
            return this
          };
          EventEmitter.prototype.on = EventEmitter.prototype.addListener;
          EventEmitter.prototype.once = function(type, listener) {
            if (!isFunction(listener)) throw TypeError("listener must be a function");
            var fired = false;

            function g() {
              this.removeListener(type, g);
              if (!fired) {
                fired = true;
                listener.apply(this, arguments)
              }
            }
            g.listener = listener;
            this.on(type, g);
            return this
          };
          EventEmitter.prototype.removeListener = function(type, listener) {
            var list, position, length, i;
            if (!isFunction(listener)) throw TypeError("listener must be a function");
            if (!this._events || !this._events[type]) return this;
            list = this._events[type];
            length = list.length;
            position = -1;
            if (list === listener || isFunction(list.listener) && list.listener === listener) {
              delete this._events[type];
              if (this._events.removeListener) this.emit("removeListener", type, listener)
            } else if (isObject(list)) {
              for (i = length; i-- > 0;) {
                if (list[i] === listener || list[i].listener && list[i].listener === listener) {
                  position = i;
                  break
                }
              }
              if (position < 0) return this;
              if (list.length === 1) {
                list.length = 0;
                delete this._events[type]
              } else {
                list.splice(position, 1)
              }
              if (this._events.removeListener) this.emit("removeListener", type, listener)
            }
            return this
          };
          EventEmitter.prototype.removeAllListeners = function(type) {
            var key, listeners;
            if (!this._events) return this;
            if (!this._events.removeListener) {
              if (arguments.length === 0) this._events = {};
              else if (this._events[type]) delete this._events[type];
              return this
            }
            if (arguments.length === 0) {
              for (key in this._events) {
                if (key === "removeListener") continue;
                this.removeAllListeners(key)
              }
              this.removeAllListeners("removeListener");
              this._events = {};
              return this
            }
            listeners = this._events[type];
            if (isFunction(listeners)) {
              this.removeListener(type, listeners)
            } else if (listeners) {
              while (listeners.length) this.removeListener(type, listeners[listeners.length - 1])
            }
            delete this._events[type];
            return this
          };
          EventEmitter.prototype.listeners = function(type) {
            var ret;
            if (!this._events || !this._events[type]) ret = [];
            else if (isFunction(this._events[type])) ret = [this._events[type]];
            else ret = this._events[type].slice();
            return ret
          };
          EventEmitter.prototype.listenerCount = function(type) {
            if (this._events) {
              var evlistener = this._events[type];
              if (isFunction(evlistener)) return 1;
              else if (evlistener) return evlistener.length
            }
            return 0
          };
          EventEmitter.listenerCount = function(emitter, type) {
            return emitter.listenerCount(type)
          };

          function isFunction(arg) {
            return typeof arg === "function"
          }

          function isNumber(arg) {
            return typeof arg === "number"
          }

          function isObject(arg) {
            return typeof arg === "object" && arg !== null
          }

          function isUndefined(arg) {
            return arg === void 0
          }
        }, {}],
        2: [function(require, module, exports) {
          var UA, browser, mode, platform, ua;
          ua = navigator.userAgent.toLowerCase();
          platform = navigator.platform.toLowerCase();
          UA = ua.match(/(opera|ie|firefox|chrome|version)[\s\/:]([\w\d\.]+)?.*?(safari|version[\s\/:]([\w\d\.]+)|$)/) || [null, "unknown", 0];
          mode = UA[1] === "ie" && document.documentMode;
          browser = {
            name: UA[1] === "version" ? UA[3] : UA[1],
            version: mode || parseFloat(UA[1] === "opera" && UA[4] ? UA[4] : UA[2]),
            platform: {
              name: ua.match(/ip(?:ad|od|hone)/) ? "ios" : (ua.match(/(?:webos|android)/) || platform.match(/mac|win|linux/) || ["other"])[0]
            }
          };
          browser[browser.name] = true;
          browser[browser.name + parseInt(browser.version, 10)] = true;
          browser.platform[browser.platform.name] = true;
          module.exports = browser
        }, {}],
        3: [function(require, module, exports) {
          var EventEmitter, GIF, browser, extend = function(child, parent) {
              for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key]
              }

              function ctor() {
                this.constructor = child
              }
              ctor.prototype = parent.prototype;
              child.prototype = new ctor;
              child.__super__ = parent.prototype;
              return child
            },
            hasProp = {}.hasOwnProperty,
            indexOf = [].indexOf || function(item) {
              for (var i = 0, l = this.length; i < l; i++) {
                if (i in this && this[i] === item) return i
              }
              return -1
            },
            slice = [].slice;
          EventEmitter = require("events").EventEmitter;
          browser = require("./browser.coffee");
          GIF = function(superClass) {
            var defaults, frameDefaults;
            extend(GIF, superClass);
            defaults = {
              workerScript: "gif.worker.js",
              workers: 2,
              repeat: 0,
              background: "#fff",
              quality: 10,
              width: null,
              height: null,
              transparent: null,
              debug: false,
              dither: false
            };
            frameDefaults = {
              delay: 500,
              copy: false,
              dispose: -1
            };

            function GIF(options) {
              var base, key, value;
              this.running = false;
              this.options = {};
              this.frames = [];
              this.freeWorkers = [];
              this.activeWorkers = [];
              this.setOptions(options);
              for (key in defaults) {
                value = defaults[key];
                if ((base = this.options)[key] == null) {
                  base[key] = value
                }
              }
            }
            GIF.prototype.setOption = function(key, value) {
              this.options[key] = value;
              if (this._canvas != null && (key === "width" || key === "height")) {
                return this._canvas[key] = value
              }
            };
            GIF.prototype.setOptions = function(options) {
              var key, results, value;
              results = [];
              for (key in options) {
                if (!hasProp.call(options, key)) continue;
                value = options[key];
                results.push(this.setOption(key, value))
              }
              return results
            };
            GIF.prototype.addFrame = function(image, options) {
              var frame, key;
              if (options == null) {
                options = {}
              }
              frame = {};
              frame.transparent = this.options.transparent;
              for (key in frameDefaults) {
                frame[key] = options[key] || frameDefaults[key]
              }
              if (this.options.width == null) {
                this.setOption("width", image.width)
              }
              if (this.options.height == null) {
                this.setOption("height", image.height)
              }
              if (typeof ImageData !== "undefined" && ImageData !== null && image instanceof ImageData) {
                frame.data = image.data
              } else if (typeof CanvasRenderingContext2D !== "undefined" && CanvasRenderingContext2D !== null && image instanceof CanvasRenderingContext2D || typeof WebGLRenderingContext !== "undefined" && WebGLRenderingContext !== null && image instanceof WebGLRenderingContext) {
                if (options.copy) {
                  frame.data = this.getContextData(image)
                } else {
                  frame.context = image
                }
              } else if (image.childNodes != null) {
                if (options.copy) {
                  frame.data = this.getImageData(image)
                } else {
                  frame.image = image
                }
              } else {
                throw new Error("Invalid image")
              }
              return this.frames.push(frame)
            };
            GIF.prototype.render = function() {
              var i, j, numWorkers, ref;
              if (this.running) {
                throw new Error("Already running")
              }
              if (this.options.width == null || this.options.height == null) {
                throw new Error("Width and height must be set prior to rendering")
              }
              this.running = true;
              this.nextFrame = 0;
              this.finishedFrames = 0;
              this.imageParts = function() {
                var j, ref, results;
                results = [];
                for (i = j = 0, ref = this.frames.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                  results.push(null)
                }
                return results
              }.call(this);
              numWorkers = this.spawnWorkers();
              if (this.options.globalPalette === true) {
                this.renderNextFrame()
              } else {
                for (i = j = 0, ref = numWorkers; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                  this.renderNextFrame()
                }
              }
              this.emit("start");
              return this.emit("progress", 0)
            };
            GIF.prototype.abort = function() {
              var worker;
              while (true) {
                worker = this.activeWorkers.shift();
                if (worker == null) {
                  break
                }
                this.log("killing active worker");
                worker.terminate()
              }
              this.running = false;
              return this.emit("abort")
            };
            GIF.prototype.spawnWorkers = function() {
              var j, numWorkers, ref, results;
              numWorkers = Math.min(this.options.workers, this.frames.length);
              (function() {
                results = [];
                for (var j = ref = this.freeWorkers.length; ref <= numWorkers ? j < numWorkers : j > numWorkers; ref <= numWorkers ? j++ : j--) {
                  results.push(j)
                }
                return results
              }).apply(this).forEach(function(_this) {
                return function(i) {
                  var worker;
                  _this.log("spawning worker " + i);
                  worker = new Worker(_this.options.workerScript);
                  worker.onmessage = function(event) {
                    _this.activeWorkers.splice(_this.activeWorkers.indexOf(worker), 1);
                    _this.freeWorkers.push(worker);
                    return _this.frameFinished(event.data)
                  };
                  return _this.freeWorkers.push(worker)
                }
              }(this));
              return numWorkers
            };
            GIF.prototype.frameFinished = function(frame) {
              var i, j, ref;
              this.log("frame " + frame.index + " finished - " + this.activeWorkers.length + " active");
              this.finishedFrames++;
              this.emit("progress", this.finishedFrames / this.frames.length);
              this.imageParts[frame.index] = frame;
              if (this.options.globalPalette === true) {
                this.options.globalPalette = frame.globalPalette;
                this.log("global palette analyzed");
                if (this.frames.length > 2) {
                  for (i = j = 1, ref = this.freeWorkers.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
                    this.renderNextFrame()
                  }
                }
              }
              if (indexOf.call(this.imageParts, null) >= 0) {
                return this.renderNextFrame()
              } else {
                return this.finishRendering()
              }
            };
            GIF.prototype.finishRendering = function() {
              var data, frame, i, image, j, k, l, len, len1, len2, len3, offset, page, ref, ref1, ref2;
              len = 0;
              ref = this.imageParts;
              for (j = 0, len1 = ref.length; j < len1; j++) {
                frame = ref[j];
                len += (frame.data.length - 1) * frame.pageSize + frame.cursor
              }
              len += frame.pageSize - frame.cursor;
              this.log("rendering finished - filesize " + Math.round(len / 1e3) + "kb");
              data = new Uint8Array(len);
              offset = 0;
              ref1 = this.imageParts;
              for (k = 0, len2 = ref1.length; k < len2; k++) {
                frame = ref1[k];
                ref2 = frame.data;
                for (i = l = 0, len3 = ref2.length; l < len3; i = ++l) {
                  page = ref2[i];
                  data.set(page, offset);
                  if (i === frame.data.length - 1) {
                    offset += frame.cursor
                  } else {
                    offset += frame.pageSize
                  }
                }
              }
              image = new Blob([data], {
                type: "image/gif"
              });
              return this.emit("finished", image, data)
            };
            GIF.prototype.renderNextFrame = function() {
              var frame, task, worker;
              if (this.freeWorkers.length === 0) {
                throw new Error("No free workers")
              }
              if (this.nextFrame >= this.frames.length) {
                return
              }
              frame = this.frames[this.nextFrame++];
              worker = this.freeWorkers.shift();
              task = this.getTask(frame);
              this.log("starting frame " + (task.index + 1) + " of " + this.frames.length);
              this.activeWorkers.push(worker);
              return worker.postMessage(task)
            };
            GIF.prototype.getContextData = function(ctx) {
              return ctx.getImageData(0, 0, this.options.width, this.options.height).data
            };
            GIF.prototype.getImageData = function(image) {
              var ctx;
              if (this._canvas == null) {
                this._canvas = document.createElement("canvas");
                this._canvas.width = this.options.width;
                this._canvas.height = this.options.height
              }
              ctx = this._canvas.getContext("2d");
              ctx.fillStyle = this.options.background;
              ctx.fillRect(0, 0, this.options.width, this.options.height);
              ctx.drawImage(image, 0, 0);
              return this.getContextData(ctx)
            };
            GIF.prototype.getTask = function(frame) {
              var index, task;
              index = this.frames.indexOf(frame);
              task = {
                index: index,
                last: index === this.frames.length - 1,
                delay: frame.delay,
                dispose: frame.dispose,
                transparent: frame.transparent,
                width: this.options.width,
                height: this.options.height,
                quality: this.options.quality,
                dither: this.options.dither,
                globalPalette: this.options.globalPalette,
                repeat: this.options.repeat,
                canTransfer: browser.name === "chrome"
              };
              if (frame.data != null) {
                task.data = frame.data
              } else if (frame.context != null) {
                task.data = this.getContextData(frame.context)
              } else if (frame.image != null) {
                task.data = this.getImageData(frame.image)
              } else {
                throw new Error("Invalid frame")
              }
              return task
            };
            GIF.prototype.log = function() {
              var args;
              args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
              if (!this.options.debug) {
                return
              }
              return console.log.apply(console, args)
            };
            return GIF
          }(EventEmitter);
          module.exports = GIF
        }, {
          "./browser.coffee": 2,
          events: 1
        }]
      }, {}, [3])(3)
    });
    //# sourceMappingURL=gif.js.map
  </script>
  <script>
    ! function(e) {
      if ("object" == typeof exports && "undefined" != typeof module) module.exports = e();
      else if ("function" == typeof define && define.amd) define([], e);
      else {
        var f;
        "undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof self && (f = self), f.Palette = e()
      }
    }(function() {
      var define, module, exports;
      return (function e(t, n, r) {
        function s(o, u) {
          if (!n[o]) {
            if (!t[o]) {
              var a = typeof require == "function" && require;
              if (!u && a) return a(o, !0);
              if (i) return i(o, !0);
              var f = new Error("Cannot find module '" + o + "'");
              throw f.code = "MODULE_NOT_FOUND", f
            }
            var l = n[o] = {
              exports: {}
            };
            t[o][0].call(l.exports, function(e) {
              var n = t[o][1][e];
              return s(n ? n : e)
            }, l, l.exports, e, t, n, r)
          }
          return n[o].exports
        }
        var i = typeof require == "function" && require;
        for (var o = 0; o < r.length; o++) s(r[o]);
        return s
      })({
        1: [function(require, module, exports) {
          (function(global) {
            var Color, LoadingErrors, P, Palette, RandomColor, RandomPalette, load_palette, options,
              extend = function(child, parent) {
                for (var key in parent) {
                  if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                  this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
              },
              hasProp = {}.hasOwnProperty;

            Palette = require("./Palette");

            Color = require("./Color");

            RandomColor = (function(superClass) {
              extend(RandomColor, superClass);

              function RandomColor() {
                this.randomize();
              }

              RandomColor.prototype.randomize = function() {
                this.h = Math.random() * 360;
                this.s = Math.random() * 100;
                return this.l = Math.random() * 100;
              };

              RandomColor.prototype.toString = function() {
                this.randomize();
                return "hsl(" + this.h + ", " + this.s + "%, " + this.l + "%)";
              };

              RandomColor.prototype.is = function() {
                return false;
              };

              return RandomColor;

            })(Color);

            RandomPalette = (function(superClass) {
              extend(RandomPalette, superClass);

              function RandomPalette() {
                var i, j, ref;
                RandomPalette.__super__.constructor.call(this);
                this.loaded_as = "Completely Random Colors™";
                this.loaded_as_clause = "(.crc sjf(Df09sjdfksdlfmnm ';';";
                this.confidence = 0;
                this.finalize();
                for (i = j = 0, ref = Math.random() * 15 + 5; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
                  this.push(new RandomColor());
                }
              }

              return RandomPalette;

            })(Palette);

            LoadingErrors = (function(superClass) {
              extend(LoadingErrors, superClass);

              function LoadingErrors(errors1) {
                var error;
                this.errors = errors1;
                this.message = "Some errors were encountered when loading:" + (function() {
                  var j, len, ref, results;
                  ref = this.errors;
                  results = [];
                  for (j = 0, len = ref.length; j < len; j++) {
                    error = ref[j];
                    results.push("\n\t" + error.message);
                  }
                  return results;
                }).call(this);
              }

              return LoadingErrors;

            })(Error);

            load_palette = function(o, callback) {
              var e, err, errors, exts_pretty, j, k, len, len1, msg, palette, palette_loaders, pl;
              palette_loaders = [{
                name: "Paint Shop Pro palette",
                exts: ["pal", "psppalette"],
                load: require("./loaders/PaintShopPro")
              }, {
                name: "RIFF PAL",
                exts: ["pal"],
                load: require("./loaders/RIFF")
              }, {
                name: "ColorSchemer palette",
                exts: ["cs"],
                load: require("./loaders/ColorSchemer")
              }, {
                name: "Paint.NET palette",
                exts: ["txt", "pdn"],
                load: require("./loaders/Paint.NET")
              }, {
                name: "GIMP palette",
                exts: ["gpl", "gimp", "colors"],
                load: require("./loaders/GIMP")
              }, {
                name: "hey look some colors",
                exts: ["txt", "html", "css", "xml", "svg", "etc"],
                load: require("./loaders/Generic")
              }, {
                name: "Houndstooth Palette Locellate",
                exts: ["hpl"],
                load: require("./loaders/HPL")
              }, {
                name: "StarCraft palette",
                exts: ["pal"],
                load: require("./loaders/StarCraft")
              }, {
                name: "StarCraft terrain palette",
                exts: ["wpe"],
                load: require("./loaders/StarCraftPadded")
              }];
              for (j = 0, len = palette_loaders.length; j < len; j++) {
                pl = palette_loaders[j];
                pl.matches_ext = pl.exts.indexOf(o.file_ext) !== -1;
              }
              palette_loaders.sort(function(pl1, pl2) {
                return pl2.matches_ext - pl1.matches_ext;
              });
              errors = [];
              for (k = 0, len1 = palette_loaders.length; k < len1; k++) {
                pl = palette_loaders[k];
                try {
                  palette = pl.load(o);
                  if (palette.length === 0) {
                    palette = null;
                    throw new Error("no colors returned");
                  }
                } catch (_error) {
                  e = _error;
                  msg = "failed to load " + o.file_name + " as " + pl.name + ": " + e.message;
                  if (pl.matches_ext && !e.message.match(/not a/i)) {
                    if (typeof console !== "undefined" && console !== null) {
                      if (typeof console.error === "function") {
                        console.error(msg);
                      }
                    }
                  } else {
                    if (typeof console !== "undefined" && console !== null) {
                      if (typeof console.warn === "function") {
                        console.warn(msg);
                      }
                    }
                  }
                  err = new Error(msg);
                  err.error = e;
                  errors.push(err);
                }
                if (palette) {
                  if (typeof console !== "undefined" && console !== null) {
                    if (typeof console.info === "function") {
                      console.info("loaded " + o.file_name + " as " + pl.name);
                    }
                  }
                  palette.confidence = pl.matches_ext ? 0.9 : 0.01;
                  palette.loaded_as = pl.name;
                  exts_pretty = "(." + (pl.exts.join(", .")) + ")";
                  if (pl.matches_ext) {
                    palette.loaded_as_clause = exts_pretty;
                  } else {
                    palette.loaded_as_clause = " for some reason";
                  }
                  palette.finalize();
                  callback(null, palette);
                  return;
                }
              }
              callback(new LoadingErrors(errors));
            };

            options = function(o) {
              var ref, ref1, ref2, ref3, ref4, ref5;
              if (o == null) {
                o = {};
              }
              if (typeof o === "string" || o instanceof String) {
                o = {
                  file_name: o
                };
              }
              if ((typeof File !== "undefined" && File !== null) && o instanceof File) {
                o = {
                  file: o
                };
              }
              if (o.min_colors == null) {
                o.min_colors = (ref = o.minColors) != null ? ref : 2;
              }
              if (o.max_colors == null) {
                o.max_colors = (ref1 = o.maxColors) != null ? ref1 : 256;
              }
              if (o.file_name == null) {
                o.file_name = (ref2 = (ref3 = o.fileName) != null ? ref3 : o.fname) != null ? ref2 : (ref4 = o.file) != null ? ref4.name : void 0;
              }
              if (o.file_ext == null) {
                o.file_ext = (ref5 = o.fileExt) != null ? ref5 : ("" + o.file_name).split(".").pop();
              }
              o.file_ext = ("" + o.file_ext).toLowerCase();
              return o;
            };

            Palette.load = function(o, callback) {
              var fr, fs;
              if (!o) {
                throw new Error("Parameters required: Palette.load(options, function callback(err, palette){})");
              }
              if (!callback) {
                throw new Error("Callback required: Palette.load(options, function callback(err, palette){})");
              }
              o = options(o);
              if (o.data) {
                return load_palette(o, callback);
              } else if ((typeof File !== "undefined" && File !== null) && o.file instanceof File) {
                fr = new FileReader;
                fr.onload = function() {
                  o.data = fr.result;
                  return load_palette(o, callback);
                };
                return fr.readAsBinaryString(o.file);
              } else if (typeof global !== "undefined" && global !== null) {
                fs = require("fs");
                return fs.readFile(o.file_name, function(err, data) {
                  if (err) {
                    return callback(err);
                  } else {
                    o.data = data.toString("binary");
                    return load_palette(o, callback);
                  }
                });
              } else {
                return callback(new Error("Could not load. The File API may not be supported."));
              }
            };

            Palette.gimme = function(o, callback) {
              o = options(o);
              return Palette.load(o, function(err, palette) {
                return callback(null, palette != null ? palette : new RandomPalette);
              });
            };

            P = module.exports = Palette;

            P.Color = Color;

            P.Palette = Palette;

            P.RandomColor = RandomColor;

            P.RandomPalette = RandomPalette;



          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

        }, {
          "./Color": 3,
          "./Palette": 4,
          "./loaders/ColorSchemer": 5,
          "./loaders/GIMP": 6,
          "./loaders/Generic": 7,
          "./loaders/HPL": 8,
          "./loaders/Paint.NET": 9,
          "./loaders/PaintShopPro": 10,
          "./loaders/RIFF": 11,
          "./loaders/StarCraft": 12,
          "./loaders/StarCraftPadded": 13,
          "fs": "fs"
        }],
        2: [function(require, module, exports) {

          /*
          BinaryReader

          Modified by Isaiah Odhner
          @TODO: use jDataView + jBinary instead

          Refactored by Vjeux <vjeuxx@gmail.com>
          http://blog.vjeux.com/2010/javascript/javascript-binary-reader.html

          Original
          + Jonas Raoni Soares Silva
          @ http://jsfromhell.com/classes/binary-parser [rev. #1]
           */
          var BinaryReader;

          module.exports = BinaryReader = (function() {
            function BinaryReader(data) {
              this._buffer = data;
              this._pos = 0;
            }

            BinaryReader.prototype.readByte = function() {
              var ch;
              this._checkSize(8);
              ch = this._buffer.charCodeAt(this._pos) & 0xff;
              this._pos += 1;
              return ch & 0xff;
            };

            BinaryReader.prototype.readUnicodeString = function() {
              var i, j, length, ref, str;
              length = this.readUInt16();
              console.log({
                length: length
              });
              this._checkSize(length * 16);
              str = "";
              for (i = j = 0, ref = length; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
                str += String.fromCharCode(this._buffer.substr(this._pos, 1) | (this._buffer.substr(this._pos + 1, 1) << 8));
                this._pos += 2;
              }
              return str;
            };

            BinaryReader.prototype.readInt8 = function() {
              return this._decodeInt(8, true);
            };

            BinaryReader.prototype.readUInt8 = function() {
              return this._decodeInt(8, false);
            };

            BinaryReader.prototype.readInt16 = function() {
              return this._decodeInt(16, true);
            };

            BinaryReader.prototype.readUInt16 = function() {
              return this._decodeInt(16, false);
            };

            BinaryReader.prototype.readInt32 = function() {
              return this._decodeInt(32, true);
            };

            BinaryReader.prototype.readUInt32 = function() {
              return this._decodeInt(32, false);
            };

            BinaryReader.prototype.readFloat = function() {
              return this._decodeFloat(23, 8);
            };

            BinaryReader.prototype.readDouble = function() {
              return this._decodeFloat(52, 11);
            };

            BinaryReader.prototype.readChar = function() {
              return this.readString(1);
            };

            BinaryReader.prototype.readString = function(length) {
              var result;
              this._checkSize(length * 8);
              result = this._buffer.substr(this._pos, length);
              this._pos += length;
              return result;
            };

            BinaryReader.prototype.seek = function(pos) {
              this._pos = pos;
              return this._checkSize(0);
            };

            BinaryReader.prototype.getPosition = function() {
              return this._pos;
            };

            BinaryReader.prototype.getSize = function() {
              return this._buffer.length;
            };

            BinaryReader.prototype._decodeFloat = function(precisionBits, exponentBits) {
              var length = precisionBits + exponentBits + 1;
              var size = length >> 3;
              this._checkSize(length);

              var bias = Math.pow(2, exponentBits - 1) - 1;
              var signal = this._readBits(precisionBits + exponentBits, 1, size);
              var exponent = this._readBits(precisionBits, exponentBits, size);
              var significand = 0;
              var divisor = 2;
              var curByte = 0; //length + (-precisionBits >> 3) - 1;
              do {
                var byteValue = this._readByte(++curByte, size);
                var startBit = precisionBits % 8 || 8;
                var mask = 1 << startBit;
                while (mask >>= 1) {
                  if (byteValue & mask) {
                    significand += 1 / divisor;
                  }
                  divisor *= 2;
                }
              } while (precisionBits -= startBit);

              this._pos += size;

              return exponent == (bias << 1) + 1 ? significand ? NaN : signal ? -Infinity : +Infinity :
                (1 + signal * -2) * (exponent || significand ? !exponent ? Math.pow(2, -bias + 1) * significand :
                  Math.pow(2, exponent - bias) * (1 + significand) : 0);
            };

            BinaryReader.prototype._decodeInt = function(bits, signed) {
              var x = this._readBits(0, bits, bits / 8),
                max = Math.pow(2, bits);
              var result = signed && x >= max / 2 ? x - max : x;

              this._pos += bits / 8;
              return result;
            };

            BinaryReader.prototype._shl = function(a, b) {
              for (++b; --b; a = ((a %= 0x7fffffff + 1) & 0x40000000) == 0x40000000 ? a * 2 : (a - 0x40000000) * 2 + 0x7fffffff + 1);
              return a;
            };

            BinaryReader.prototype._readByte = function(i, size) {
              return this._buffer.charCodeAt(this._pos + size - i - 1) & 0xff;
            };

            BinaryReader.prototype._readBits = function(start, length, size) {
              var offsetLeft = (start + length) % 8;
              var offsetRight = start % 8;
              var curByte = size - (start >> 3) - 1;
              var lastByte = size + (-(start + length) >> 3);
              var diff = curByte - lastByte;

              var sum = (this._readByte(curByte, size) >> offsetRight) & ((1 << (diff ? 8 - offsetRight : length)) - 1);

              if (diff && offsetLeft) {
                sum += (this._readByte(lastByte++, size) & ((1 << offsetLeft) - 1)) << (diff-- << 3) - offsetRight;
              }

              while (diff) {
                sum += this._shl(this._readByte(lastByte++, size), (diff-- << 3) - offsetRight);
              }

              return sum;
            };

            BinaryReader.prototype._checkSize = function(neededBits) {
              if (this._pos + Math.ceil(neededBits / 8) > this._buffer.length) {
                throw new Error("Index out of bound");
              }
            };

            return BinaryReader;

          })();



        }, {}],
        3: [function(require, module, exports) {
          var Color;

          module.exports = Color = (function() {
            function Color(arg) {
              var _, c, i, j, k, len, len1, m, powed, ref, ref1, rgb, white, xyz, y;
              this.r = arg.r, this.g = arg.g, this.b = arg.b, this.h = arg.h, this.s = arg.s, this.v = arg.v, this.l = arg.l, c = arg.c, m = arg.m, y = arg.y, k = arg.k, this.name = arg.name;
              if ((this.r != null) && (this.g != null) && (this.b != null)) {

              } else if ((this.h != null) && (this.s != null)) {
                if (this.v != null) {
                  this.l = (2 - this.s / 100) * this.v / 2;
                  this.s = this.s * this.v / (this.l < 50 ? this.l * 2 : 200 - this.l * 2);
                  if (isNaN(this.s)) {
                    this.s = 0;
                  }
                } else if (this.l != null) {

                } else {
                  throw new Error("Hue, saturation, and...? (either lightness or value)");
                }
              } else if ((c != null) && (m != null) && (y != null) && (k != null)) {
                c /= 100;
                m /= 100;
                y /= 100;
                k /= 100;
                this.r = 255 * (1 - Math.min(1, c * (1 - k) + k));
                this.g = 255 * (1 - Math.min(1, m * (1 - k) + k));
                this.b = 255 * (1 - Math.min(1, y * (1 - k) + k));
              } else {
                if ((this.l != null) && (this.a != null) && (this.b != null)) {
                  white = {
                    x: 95.047,
                    y: 100.000,
                    z: 108.883
                  };
                  xyz = {
                    y: (raw.l + 16) / 116,
                    x: raw.a / 500 + xyz.y,
                    z: xyz.y - raw.b / 200
                  };
                  ref = "xyz";
                  for (i = 0, len = ref.length; i < len; i++) {
                    _ = ref[i];
                    powed = Math.pow(xyz[_], 3);
                    if (powed > 0.008856) {
                      xyz[_] = powed;
                    } else {
                      xyz[_] = (xyz[_] - 16 / 116) / 7.787;
                    }
                  }
                }
                if ((this.x != null) && (this.y != null) && (this.z != null)) {
                  xyz = {
                    x: raw.x / 100,
                    y: raw.y / 100,
                    z: raw.z / 100
                  };
                  rgb = {
                    r: xyz.x * 3.2406 + xyz.y * -1.5372 + xyz.z * -0.4986,
                    g: xyz.x * -0.9689 + xyz.y * 1.8758 + xyz.z * 0.0415,
                    b: xyz.x * 0.0557 + xyz.y * -0.2040 + xyz.z * 1.0570
                  };
                  ref1 = "rgb";
                  for (j = 0, len1 = ref1.length; j < len1; j++) {
                    _ = ref1[j];
                    if (rgb[_] < 0) {
                      rgb[_] = 0;
                    }
                    if (rgb[_] > 0.0031308) {
                      rgb[_] = 1.055 * Math.pow(rgb[_], 1 / 2.4) - 0.055;
                    } else {
                      rgb[_] *= 12.92;
                    }
                  }
                } else {
                  throw new Error("Color constructor must be called with {r,g,b} or {h,s,v} or {h,s,l} or {c,m,y,k} or {x,y,z} or {l,a,b}");
                }
              }
            }

            Color.prototype.toString = function() {
              if (this.r != null) {
                if (this.a != null) {
                  return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + this.a + ")";
                } else {
                  return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
                }
              } else if (this.h != null) {
                if (this.a != null) {
                  return "hsla(" + this.h + ", " + this.s + "%, " + this.l + "%, " + this.a + ")";
                } else {
                  return "hsl(" + this.h + ", " + this.s + "%, " + this.l + "%)";
                }
              }
            };

            Color.prototype.is = function(color) {
              return ("" + this) === ("" + color);
            };

            return Color;

          })();



        }, {}],
        4: [function(require, module, exports) {
          var Color, Palette,
            extend = function(child, parent) {
              for (var key in parent) {
                if (hasProp.call(parent, key)) child[key] = parent[key];
              }

              function ctor() {
                this.constructor = child;
              }
              ctor.prototype = parent.prototype;
              child.prototype = new ctor();
              child.__super__ = parent.prototype;
              return child;
            },
            hasProp = {}.hasOwnProperty;

          Color = require("./Color");

          module.exports = Palette = (function(superClass) {
            extend(Palette, superClass);

            function Palette() {
              Palette.__super__.constructor.call(this);
              this.with_duplicates = this;
            }

            Palette.prototype.add = function(o) {
              var color, i, len1, new_color;
              new_color = new Color(o);
              if (this.with_duplicates === this) {
                this.with_duplicates = new Palette();
              }
              this.with_duplicates.push(new_color);
              for (i = 0, len1 = this.length; i < len1; i++) {
                color = this[i];
                if (color.is(new_color)) {
                  new_color.is_duplicate = true;
                  return;
                }
              }
              return this.push(new_color);
            };

            Palette.prototype.finalize = function() {
              if (!this.n_columns) {
                this.guess_dimensions();
              }
              if (this.with_duplicates) {
                return this.with_duplicates.guess_dimensions();
              }
            };

            Palette.prototype.guess_dimensions = function() {
              var candidate_dimensions, cd, i, j, len, len1, n_columns, n_rows, ref, results, squarest;
              len = this.length;
              candidate_dimensions = [];
              for (n_columns = i = 0, ref = len; 0 <= ref ? i <= ref : i >= ref; n_columns = 0 <= ref ? ++i : --i) {
                n_rows = len / n_columns;
                if (n_rows === Math.round(n_rows)) {
                  candidate_dimensions.push([n_rows, n_columns]);
                }
              }
              squarest = [0, 3495093];
              results = [];
              for (j = 0, len1 = candidate_dimensions.length; j < len1; j++) {
                cd = candidate_dimensions[j];
                if (Math.abs(cd[0] - cd[1]) < Math.abs(squarest[0] - squarest[1])) {
                  results.push(squarest = cd);
                } else {
                  results.push(void 0);
                }
              }
              return results;
            };

            return Palette;

          })(Array);



        }, {
          "./Color": 3
        }],
        5: [function(require, module, exports) {
          var BinaryReader, Palette;

          BinaryReader = require("../BinaryReader");

          Palette = require("../Palette");

          module.exports = function(arg) {
            var br, data, i, length, palette, version;
            data = arg.data;
            palette = new Palette();
            br = new BinaryReader(data);
            version = br.readUInt16();
            length = br.readUInt16();
            i = 0;
            while (i < length) {
              br.seek(8 + i * 26);
              palette.add({
                r: br.readByte(),
                g: br.readByte(),
                b: br.readByte()
              });
              i += 1;
            }
            return palette;
          };



        }, {
          "../BinaryReader": 2,
          "../Palette": 4
        }],
        6: [function(require, module, exports) {
          var Palette;

          Palette = require("../Palette");

          module.exports = function(arg) {
            var data, i, line, lines, m, palette, r_g_b_name;
            data = arg.data;
            lines = data.split(/[\n\r]+/m);
            if (lines[0] !== "GIMP Palette") {
              throw new Error("Not a GIMP Palette");
            }
            palette = new Palette();
            i = 1;
            while ((i += 1) < lines.length) {
              line = lines[i];
              if (line.match(/^#/) || line === "") {
                continue;
              }
              m = line.match(/Name:\s*(.*)/);
              if (m) {
                palette.name = m[1];
                continue;
              }
              m = line.match(/Columns:\s*(.*)/);
              if (m) {
                palette.n_columns = Number(m[1]);
                palette.has_dimensions = true;
                continue;
              }
              r_g_b_name = line.match(/^\s*([0-9]+)\s+([0-9]+)\s+([0-9]+)(?:\s+(.*))?$/);
              if (!r_g_b_name) {
                throw new Error("Line " + i + " doesn't match pattern r_g_b_name");
              }
              palette.add({
                r: r_g_b_name[1],
                g: r_g_b_name[2],
                b: r_g_b_name[3],
                name: r_g_b_name[4]
              });
            }
            return palette;
          };



        }, {
          "../Palette": 4
        }],
        7: [function(require, module, exports) {
          var Palette;

          Palette = require("../Palette");

          module.exports = function(arg) {
            var data, hex, i, len, most_colors, n, palette, palette_hsl, palette_hsla, palette_rgb, palette_rgba, palette_xRGB, palette_xRRGGBB, palettes;
            data = arg.data;
            palettes = [palette_xRRGGBB = new Palette(), palette_xRGB = new Palette(), palette_rgb = new Palette(), palette_hsl = new Palette(), palette_hsla = new Palette(), palette_rgba = new Palette()];
            hex = function(x) {
              return parseInt(x, 16);
            };
            data.replace(/\#([0-9A-F]{2})?([0-9A-F]{3})([0-9A-F]{3})?(?![0-9A-F])/gim, function(m, $0, $1, $2) {
              var alpha, xRGB;
              alpha = hex($0);
              if ($2) {
                xRGB = $1 + $2;
                return palette_xRRGGBB.add({
                  r: hex(xRGB[0] + xRGB[1]),
                  g: hex(xRGB[2] + xRGB[3]),
                  b: hex(xRGB[4] + xRGB[5]),
                  a: alpha
                });
              } else {
                xRGB = $1;
                return palette_xRGB.add({
                  r: hex(xRGB[0] + xRGB[0]),
                  g: hex(xRGB[1] + xRGB[1]),
                  b: hex(xRGB[2] + xRGB[2]),
                  a: alpha
                });
              }
            });
            data.replace(/rgb\(\s*([0-9]{1,3}),\s*([0-9]{1,3}),\s*([0-9]{1,3})\s*\)/gim, function(m) {
              return palette_rgb.add({
                r: Number(m[1]),
                g: Number(m[2]),
                b: Number(m[3])
              });
            });
            data.replace(/rgba\(\s*([0-9]{1,3}),\s*([0-9]{1,3}),\s*([0-9]{1,3}),\s*([0-9]{1,3}|0\.[0-9]+)\s*\)/gim, function(m) {
              return palette_rgb.add({
                r: Number(m[1]),
                g: Number(m[2]),
                b: Number(m[3]),
                a: Number(m[4])
              });
            });
            data.replace(/hsl\(\s*([0-9]{1,3}),\s*([0-9]{1,3}),\s*([0-9]{1,3})\s*\)/gim, function(m) {
              return palette_rgb.add({
                h: Number(m[1]),
                s: Number(m[2]),
                l: Number(m[3])
              });
            });
            most_colors = [];
            for (i = 0, len = palettes.length; i < len; i++) {
              palette = palettes[i];
              if (palette.length >= most_colors.length) {
                most_colors = palette;
              }
            }
            n = most_colors.length;
            if (n < 4) {
              throw new Error(["No colors found", "Only one color found", "Only a couple colors found", "Only a few colors found"][n] + (" (" + n + ")"));
            }
            return most_colors;
          };



        }, {
          "../Palette": 4
        }],
        8: [function(require, module, exports) {
          var Palette;

          Palette = require("../Palette");

          module.exports = function(arg) {
            var data, i, j, len, line, lines, palette, rgb;
            data = arg.data;
            lines = data.split(/[\n\r]+/m);
            if (lines[0] !== "Palette") {
              throw new Error("Not an HPL palette");
            }
            if (!lines[1].match(/Version [34]\.0/)) {
              throw new Error("Unsupported HPL version");
            }
            palette = new Palette();
            for (i = j = 0, len = lines.length; j < len; i = ++j) {
              line = lines[i];
              if (line.match(/.+ .* .+/)) {
                rgb = line.split(" ");
                palette.add({
                  r: rgb[0],
                  g: rgb[1],
                  b: rgb[2]
                });
              }
            }
            return palette;
          };



        }, {
          "../Palette": 4
        }],
        9: [function(require, module, exports) {
          var BinaryReader, Palette;

          BinaryReader = require("../BinaryReader");

          Palette = require("../Palette");

          module.exports = function(arg) {
            var data, hex, i, len, line, m, palette, ref;
            data = arg.data;
            palette = new Palette();
            hex = function(x) {
              return parseInt(x, 16);
            };
            ref = data.split(/[\n\r]+/m);
            for (i = 0, len = ref.length; i < len; i++) {
              line = ref[i];
              m = line.match(/^([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})$/i);
              if (m) {
                palette.add({
                  a: hex(m[1]),
                  r: hex(m[2]),
                  g: hex(m[3]),
                  b: hex(m[4])
                });
              }
            }
            return palette;
          };



        }, {
          "../BinaryReader": 2,
          "../Palette": 4
        }],
        10: [function(require, module, exports) {
          var BinaryReader, Palette;

          BinaryReader = require("../BinaryReader");

          Palette = require("../Palette");

          module.exports = function(arg) {
            var data, i, j, len, line, lines, palette, rgb;
            data = arg.data;
            lines = data.split(/[\n\r]+/m);
            if (lines[0] !== "JASC-PAL") {
              throw new Error("Not a JASC-PAL");
            }
            if (lines[1] !== "0100") {
              throw new Error("Unknown JASC-PAL version");
            }
            if (lines[2] !== "256") {
              "that's ok";
            }
            palette = new Palette();
            for (i = j = 0, len = lines.length; j < len; i = ++j) {
              line = lines[i];
              if (line !== "" && i > 2) {
                rgb = line.split(" ");
                palette.add({
                  r: rgb[0],
                  g: rgb[1],
                  b: rgb[2]
                });
              }
            }
            return palette;
          };



        }, {
          "../BinaryReader": 2,
          "../Palette": 4
        }],
        11: [function(require, module, exports) {
          var BinaryReader, Palette;

          BinaryReader = require("../BinaryReader");

          Palette = require("../Palette");

          module.exports = function(arg) {
            var br, chunkSize, chunkType, data, dataSize, i, palNumEntries, palVersion, palette, riff, type;
            data = arg.data;
            br = new BinaryReader(data);
            riff = br.readString(4);
            dataSize = br.readUInt32();
            type = br.readString(4);
            if (riff !== "RIFF") {
              throw new Error("RIFF header not found; not a RIFF PAL file");
            }
            if (type !== "PAL ") {
              throw new Error("RIFF header says this isn't a PAL file,\nmore of a sort of " + ((type + "").trim()) + " file");
            }
            chunkType = br.readString(4);
            chunkSize = br.readUInt32();
            palVersion = br.readUInt16();
            palNumEntries = br.readUInt16();
            if (chunkType !== "data") {
              throw new Error("Data chunk not found (...'" + chunkType + "'?)");
            }
            if (palVersion !== 0x0300) {
              throw new Error("Unsupported PAL file version: 0x" + (palVersion.toString(16)));
            }
            palette = new Palette();
            i = 0;
            while ((i += 1) < palNumEntries - 1) {
              palette.add({
                r: br.readByte(),
                g: br.readByte(),
                b: br.readByte(),
                _: br.readByte()
              });
            }
            return palette;
          };



        }, {
          "../BinaryReader": 2,
          "../Palette": 4
        }],
        12: [function(require, module, exports) {
          var BinaryReader, Palette;

          BinaryReader = require("../BinaryReader");

          Palette = require("../Palette");

          module.exports = function(arg) {
            var br, data, i, j, palette;
            data = arg.data;
            palette = new Palette();
            br = new BinaryReader(data);
            for (i = j = 0; j < 255; i = ++j) {
              palette.add({
                r: br.readByte(),
                g: br.readByte(),
                b: br.readByte()
              });
            }
            return palette;
          };



        }, {
          "../BinaryReader": 2,
          "../Palette": 4
        }],
        13: [function(require, module, exports) {
          var BinaryReader, Palette;

          BinaryReader = require("../BinaryReader");

          Palette = require("../Palette");

          module.exports = function(arg) {
            var br, data, i, j, palette;
            data = arg.data;
            palette = new Palette();
            br = new BinaryReader(data);
            for (i = j = 0; j < 255; i = ++j) {
              palette.add({
                r: br.readByte(),
                g: br.readByte(),
                b: br.readByte(),
                _: br.readByte()
              });
            }
            palette.n_columns = 16;
            return palette;
          };



        }, {
          "../BinaryReader": 2,
          "../Palette": 4
        }]
      }, {}, [1])(1)
    });
    //# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlc1xcYnJvd3NlcmlmeVxcbm9kZV9tb2R1bGVzXFxicm93c2VyLXBhY2tcXF9wcmVsdWRlLmpzIiwiQzpcXFVzZXJzXFxJc2FpYWhcXCEhUHJvamVjdHNcXHBhbGV0dGUuanNcXHNyY1xcbWFpbi5jb2ZmZWUiLCJDOlxcVXNlcnNcXElzYWlhaFxcISFQcm9qZWN0c1xccGFsZXR0ZS5qc1xcc3JjXFxCaW5hcnlSZWFkZXIuY29mZmVlIiwiQzpcXFVzZXJzXFxJc2FpYWhcXCEhUHJvamVjdHNcXHBhbGV0dGUuanNcXHNyY1xcQ29sb3IuY29mZmVlIiwiQzpcXFVzZXJzXFxJc2FpYWhcXCEhUHJvamVjdHNcXHBhbGV0dGUuanNcXHNyY1xcUGFsZXR0ZS5jb2ZmZWUiLCJDOlxcVXNlcnNcXElzYWlhaFxcISFQcm9qZWN0c1xccGFsZXR0ZS5qc1xcc3JjXFxsb2FkZXJzXFxDb2xvclNjaGVtZXIuY29mZmVlIiwiQzpcXFVzZXJzXFxJc2FpYWhcXCEhUHJvamVjdHNcXHBhbGV0dGUuanNcXHNyY1xcbG9hZGVyc1xcR0lNUC5jb2ZmZWUiLCJDOlxcVXNlcnNcXElzYWlhaFxcISFQcm9qZWN0c1xccGFsZXR0ZS5qc1xcc3JjXFxsb2FkZXJzXFxHZW5lcmljLmNvZmZlZSIsIkM6XFxVc2Vyc1xcSXNhaWFoXFwhIVByb2plY3RzXFxwYWxldHRlLmpzXFxzcmNcXGxvYWRlcnNcXEhQTC5jb2ZmZWUiLCJDOlxcVXNlcnNcXElzYWlhaFxcISFQcm9qZWN0c1xccGFsZXR0ZS5qc1xcc3JjXFxsb2FkZXJzXFxQYWludC5ORVQuY29mZmVlIiwiQzpcXFVzZXJzXFxJc2FpYWhcXCEhUHJvamVjdHNcXHBhbGV0dGUuanNcXHNyY1xcbG9hZGVyc1xcUGFpbnRTaG9wUHJvLmNvZmZlZSIsIkM6XFxVc2Vyc1xcSXNhaWFoXFwhIVByb2plY3RzXFxwYWxldHRlLmpzXFxzcmNcXGxvYWRlcnNcXFJJRkYuY29mZmVlIiwiQzpcXFVzZXJzXFxJc2FpYWhcXCEhUHJvamVjdHNcXHBhbGV0dGUuanNcXHNyY1xcbG9hZGVyc1xcU3RhckNyYWZ0LmNvZmZlZSIsIkM6XFxVc2Vyc1xcSXNhaWFoXFwhIVByb2plY3RzXFxwYWxldHRlLmpzXFxzcmNcXGxvYWRlcnNcXFN0YXJDcmFmdFBhZGRlZC5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FDQ0EsSUFBQSxtRkFBQTtFQUFBOzZCQUFBOztBQUFBLE9BQUEsR0FBVSxPQUFBLENBQVEsV0FBUixDQUFWLENBQUE7O0FBQUEsS0FDQSxHQUFRLE9BQUEsQ0FBUSxTQUFSLENBRFIsQ0FBQTs7QUFBQTtBQUlDLGlDQUFBLENBQUE7O0FBQWEsRUFBQSxxQkFBQSxHQUFBO0FBQ1osSUFBQSxJQUFDLENBQUEsU0FBRCxDQUFBLENBQUEsQ0FEWTtFQUFBLENBQWI7O0FBQUEsd0JBR0EsU0FBQSxHQUFXLFNBQUEsR0FBQTtBQUNWLElBQUEsSUFBQyxDQUFBLENBQUQsR0FBSyxJQUFJLENBQUMsTUFBTCxDQUFBLENBQUEsR0FBZ0IsR0FBckIsQ0FBQTtBQUFBLElBQ0EsSUFBQyxDQUFBLENBQUQsR0FBSyxJQUFJLENBQUMsTUFBTCxDQUFBLENBQUEsR0FBZ0IsR0FEckIsQ0FBQTtXQUVBLElBQUMsQ0FBQSxDQUFELEdBQUssSUFBSSxDQUFDLE1BQUwsQ0FBQSxDQUFBLEdBQWdCLElBSFg7RUFBQSxDQUhYLENBQUE7O0FBQUEsd0JBUUEsUUFBQSxHQUFVLFNBQUEsR0FBQTtBQUNULElBQUEsSUFBQyxDQUFBLFNBQUQsQ0FBQSxDQUFBLENBQUE7V0FDQSxNQUFBLEdBQU8sSUFBQyxDQUFBLENBQVIsR0FBVSxJQUFWLEdBQWMsSUFBQyxDQUFBLENBQWYsR0FBaUIsS0FBakIsR0FBc0IsSUFBQyxDQUFBLENBQXZCLEdBQXlCLEtBRmhCO0VBQUEsQ0FSVixDQUFBOztBQUFBLHdCQVlBLEVBQUEsR0FBSSxTQUFBLEdBQUE7V0FBRyxNQUFIO0VBQUEsQ0FaSixDQUFBOztxQkFBQTs7R0FEeUIsTUFIMUIsQ0FBQTs7QUFBQTtBQW1C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QUgsQ0FBQSxDQUFIO0FBQUEsTUFDQSxDQUFBLEVBQUcsRUFBRSxDQUFDLFFBQUgsQ0FBQSxDQURIO0FBQUEsTUFFQSxDQUFBLEVBQUcsRUFBRSxDQUFDLFFBQUgsQ0FBQSxDQUZIO0FBQUEsTUFHQSxDQUFBLEVBQUcsRUFBRSxDQUFDLFFBQUgsQ0FBQSxDQUhIO0tBREQsQ0FBQSxDQUREO0FBQUEsR0FIQTtBQUFBLEVBVUEsT0FBTyxDQUFDLFNBQVIsR0FBb0IsRUFWcEIsQ0FBQTtTQVdBLFFBYmdCO0FBQUEsQ0FIakIsQ0FBQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJcclxuUGFsZXR0ZSA9IHJlcXVpcmUgXCIuL1BhbGV0dGVcIlxyXG5Db2xvciA9IHJlcXVpcmUgXCIuL0NvbG9yXCJcclxuXHJcbmNsYXNzIFJhbmRvbUNvbG9yIGV4dGVuZHMgQ29sb3JcclxuXHRjb25zdHJ1Y3RvcjogLT5cclxuXHRcdEByYW5kb21pemUoKVxyXG5cdFxyXG5cdHJhbmRvbWl6ZTogLT5cclxuXHRcdEBoID0gTWF0aC5yYW5kb20oKSAqIDM2MFxyXG5cdFx0QHMgPSBNYXRoLnJhbmRvbSgpICogMTAwXHJcblx0XHRAbCA9IE1hdGgucmFuZG9tKCkgKiAxMDBcclxuXHRcclxuXHR0b1N0cmluZzogLT5cclxuXHRcdEByYW5kb21pemUoKVxyXG5cdFx0XCJoc2woI3tAaH0sICN7QHN9JSwgI3tAbH0lKVwiXHJcblx0XHJcblx0aXM6IC0+IG5vXHJcblxyXG5jbGFzcyBSYW5kb21QYWxldHRlIGV4dGVuZHMgUGFsZXR0ZVxyXG5cdGNvbnN0cnVjdG9yOiAtPlxyXG5cdFx0c3VwZXIoKVxyXG5cdFx0QGxvYWRlZF9hcyA9IFwiQ29tcGxldGVseSBSYW5kb20gQ29sb3Jz4oSiXCJcclxuXHRcdEBsb2FkZWRfYXNfY2xhdXNlID0gXCIoLmNyYyBzamYoRGYwOXNqZGZrc2RsZm1ubSAnOyc7XCJcclxuXHRcdEBjb25maWRlbmNlID0gMFxyXG5cdFx0QGZpbmFsaXplKClcclxuXHRcdGZvciBpIGluIFswLi5NYXRoLnJhbmRvbSgpKjE1KzVdXHJcblx0XHRcdEBwdXNoIG5ldyBSYW5kb21Db2xvcigpXHJcblxyXG5jbGFzcyBMb2FkaW5nRXJyb3JzIGV4dGVuZHMgRXJyb3JcclxuXHRjb25zdHJ1Y3RvcjogKEBlcnJvcnMpLT5cclxuXHRcdEBtZXNzYWdlID0gXCJTb21lIGVycm9ycyB3ZXJlIGVuY291bnRlcmVkIHdoZW4gbG9hZGluZzpcIiArXHJcblx0XHRcdGZvciBlcnJvciBpbiBAZXJyb3JzXHJcblx0XHRcdFx0XCJcXG5cXHRcIiArIGVycm9yLm1lc3NhZ2VcclxuXHJcbmxvYWRfcGFsZXR0ZSA9IChvLCBjYWxsYmFjayktPlxyXG5cdFxyXG5cdHBhbGV0dGVfbG9hZGVycyA9IFtcclxuXHRcdHtcclxuXHRcdFx0bmFtZTogXCJQYWludCBTaG9wIFBybyBwYWxldHRlXCJcclxuXHRcdFx0ZXh0czogW1wicGFsXCIsIFwicHNwcGFsZXR0ZVwiXVxyXG5cdFx0XHRsb2FkOiByZXF1aXJlIFwiLi9sb2FkZXJzL1BhaW50U2hvcFByb1wiXHJcblx0XHR9XHJcblx0XHR7XHJcblx0XHRcdG5hbWU6IFwiUklGRiBQQUxcIlxyXG5cdFx0XHRleHRzOiBbXCJwYWxcIl1cclxuXHRcdFx0bG9hZDogcmVxdWlyZSBcIi4vbG9hZGVycy9SSUZGXCJcclxuXHRcdH1cclxuXHRcdHtcclxuXHRcdFx0bmFtZTogXCJDb2xvclNjaGVtZXIgcGFsZXR0ZVwiXHJcblx0XHRcdGV4dHM6IFtcImNzXCJdXHJcblx0XHRcdGxvYWQ6IHJlcXVpcmUgXCIuL2xvYWRlcnMvQ29sb3JTY2hlbWVyXCJcclxuXHRcdH1cclxuXHRcdHtcclxuXHRcdFx0bmFtZTogXCJQYWludC5ORVQgcGFsZXR0ZVwiXHJcblx0XHRcdGV4dHM6IFtcInR4dFwiLCBcInBkblwiXVxyXG5cdFx0XHRsb2FkOiByZXF1aXJlIFwiLi9sb2FkZXJzL1BhaW50Lk5FVFwiXHJcblx0XHR9XHJcblx0XHR7XHJcblx0XHRcdG5hbWU6IFwiR0lNUCBwYWxldHRlXCJcclxuXHRcdFx0ZXh0czogW1wiZ3BsXCIsIFwiZ2ltcFwiLCBcImNvbG9yc1wiXVxyXG5cdFx0XHRsb2FkOiByZXF1aXJlIFwiLi9sb2FkZXJzL0dJTVBcIlxyXG5cdFx0fVxyXG5cdFx0e1xyXG5cdFx0XHRuYW1lOiBcImhleSBsb29rIHNvbWUgY29sb3JzXCJcclxuXHRcdFx0ZXh0czogW1widHh0XCIsIFwiaHRtbFwiLCBcImNzc1wiLCBcInhtbFwiLCBcInN2Z1wiLCBcImV0Y1wiXVxyXG5cdFx0XHQjIEBUT0RPOiByZW5hbWUgdGhpcyB0byBcIkNTU1wiIChpdCdzIG5vdCB2ZXJ5IFwiZ2VuZXJpY1wiKVxyXG5cdFx0XHRsb2FkOiByZXF1aXJlIFwiLi9sb2FkZXJzL0dlbmVyaWNcIlxyXG5cdFx0fVxyXG5cdFx0IyB7XHJcblx0XHQjIFx0bmFtZTogXCJBZG9iZSBDb2xvciBTd2F0Y2hcIlxyXG5cdFx0IyBcdGV4dHM6IFtcImFjb1wiXVxyXG5cdFx0IyBcdGxvYWQ6IHJlcXVpcmUgXCIuL2xvYWRlcnMvQWRvYmVDb2xvclN3YXRjaFwiXHJcblx0XHQjIH1cclxuXHRcdCMge1xyXG5cdFx0IyBcdG5hbWU6IFwiQWRvYmUgQ29sb3IgVGFibGVcIlxyXG5cdFx0IyBcdGV4dHM6IFtcImFjdFwiXVxyXG5cdFx0IyBcdGxvYWQ6IHJlcXVpcmUgXCIuL2xvYWRlcnMvQWRvYmVDb2xvclRhYmxlXCJcclxuXHRcdCMgfVxyXG5cdFx0IyB7XHJcblx0XHQjIFx0bmFtZTogXCJBZG9iZSBTd2F0Y2ggRXhjaGFuZ2VcIlxyXG5cdFx0IyBcdGV4dHM6IFtcImFzZVwiXVxyXG5cdFx0IyBcdGxvYWQ6IHJlcXVpcmUgXCIuL2xvYWRlcnMvQWRvYmVTd2F0Y2hFeGNoYW5nZVwiXHJcblx0XHQjIH1cclxuXHRcdCMge1xyXG5cdFx0IyBcdG5hbWU6IFwiQWRvYmUgQ29sb3IgQm9va1wiXHJcblx0XHQjIFx0ZXh0czogW1wiYWNiXCJdXHJcblx0XHQjIFx0bG9hZDogcmVxdWlyZSBcIi4vbG9hZGVycy9BZG9iZUNvbG9yQm9va1wiXHJcblx0XHQjIH1cclxuXHRcdHtcclxuXHRcdFx0bmFtZTogXCJIb3VuZHN0b290aCBQYWxldHRlIExvY2VsbGF0ZVwiXHJcblx0XHRcdGV4dHM6IFtcImhwbFwiXVxyXG5cdFx0XHRsb2FkOiByZXF1aXJlIFwiLi9sb2FkZXJzL0hQTFwiXHJcblx0XHR9XHJcblx0XHR7XHJcblx0XHRcdG5hbWU6IFwiU3RhckNyYWZ0IHBhbGV0dGVcIlxyXG5cdFx0XHRleHRzOiBbXCJwYWxcIl1cclxuXHRcdFx0bG9hZDogcmVxdWlyZSBcIi4vbG9hZGVycy9TdGFyQ3JhZnRcIlxyXG5cdFx0fVxyXG5cdFx0e1xyXG5cdFx0XHRuYW1lOiBcIlN0YXJDcmFmdCB0ZXJyYWluIHBhbGV0dGVcIlxyXG5cdFx0XHRleHRzOiBbXCJ3cGVcIl1cclxuXHRcdFx0bG9hZDogcmVxdWlyZSBcIi4vbG9hZGVycy9TdGFyQ3JhZnRQYWRkZWRcIlxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHQjIHtcclxuXHRcdCMgXHRuYW1lOiBcIkF1dG9DQUQgQ29sb3IgQm9va1wiXHJcblx0XHQjIFx0ZXh0czogW1wiYWNiXCJdXHJcblx0XHQjIFx0bG9hZDogcmVxdWlyZSBcIi4vbG9hZGVycy9BdXRvQ0FEQ29sb3JCb29rXCJcclxuXHRcdCMgfVxyXG5cdFx0XHJcblx0XHQjIHtcclxuXHRcdCMgXHQjIChzYW1lIGFzIFBhaW50IFNob3AgUHJvIHBhbGV0dGU/KVxyXG5cdFx0IyBcdG5hbWU6IFwiQ29yZWxEUkFXIHBhbGV0dGVcIlxyXG5cdFx0IyBcdGV4dHM6IFtcInBhbFwiLCBcImNwbFwiXVxyXG5cdFx0IyBcdGxvYWQ6IHJlcXVpcmUgXCIuL2xvYWRlcnMvQ29yZWxEUkFXXCJcclxuXHRcdCMgfVxyXG5cdF1cclxuXHRcclxuXHQjIGZpbmQgcGFsZXR0ZSBsb2FkZXJzIHRoYXQgdXNlIHRoaXMgZmlsZSBleHRlbnNpb25cclxuXHRmb3IgcGwgaW4gcGFsZXR0ZV9sb2FkZXJzXHJcblx0XHRwbC5tYXRjaGVzX2V4dCA9IHBsLmV4dHMuaW5kZXhPZihvLmZpbGVfZXh0KSBpc250IC0xXHJcblx0XHJcblx0IyBtb3ZlIHBhbGV0dGUgbG9hZGVycyB0byB0aGUgYmVnaW5uaW5nIHRoYXQgdXNlIHRoaXMgZmlsZSBleHRlbnNpb25cclxuXHRwYWxldHRlX2xvYWRlcnMuc29ydCAocGwxLCBwbDIpLT5cclxuXHRcdHBsMi5tYXRjaGVzX2V4dCAtIHBsMS5tYXRjaGVzX2V4dFxyXG5cdFxyXG5cdCMgdHJ5IGxvYWRpbmcgc3R1ZmZcclxuXHRlcnJvcnMgPSBbXVxyXG5cdGZvciBwbCBpbiBwYWxldHRlX2xvYWRlcnNcclxuXHRcdFxyXG5cdFx0dHJ5XHJcblx0XHRcdHBhbGV0dGUgPSBwbC5sb2FkKG8pXHJcblx0XHRcdGlmIHBhbGV0dGUubGVuZ3RoIGlzIDBcclxuXHRcdFx0XHRwYWxldHRlID0gbnVsbFxyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciBcIm5vIGNvbG9ycyByZXR1cm5lZFwiXHJcblx0XHRjYXRjaCBlXHJcblx0XHRcdG1zZyA9IFwiZmFpbGVkIHRvIGxvYWQgI3tvLmZpbGVfbmFtZX0gYXMgI3twbC5uYW1lfTogI3tlLm1lc3NhZ2V9XCJcclxuXHRcdFx0aWYgcGwubWF0Y2hlc19leHQgYW5kIG5vdCBlLm1lc3NhZ2UubWF0Y2goL25vdCBhL2kpXHJcblx0XHRcdFx0Y29uc29sZT8uZXJyb3I/IG1zZ1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0Y29uc29sZT8ud2Fybj8gbXNnXHJcblx0XHRcdFxyXG5cdFx0XHRlcnIgPSBuZXcgRXJyb3IgbXNnXHJcblx0XHRcdGVyci5lcnJvciA9IGVcclxuXHRcdFx0ZXJyb3JzLnB1c2ggZXJyXHJcblx0XHRcclxuXHRcdGlmIHBhbGV0dGVcclxuXHRcdFx0Y29uc29sZT8uaW5mbz8gXCJsb2FkZWQgI3tvLmZpbGVfbmFtZX0gYXMgI3twbC5uYW1lfVwiXHJcblx0XHRcdHBhbGV0dGUuY29uZmlkZW5jZSA9IGlmIHBsLm1hdGNoZXNfZXh0IHRoZW4gMC45IGVsc2UgMC4wMVxyXG5cdFx0XHRwYWxldHRlLmxvYWRlZF9hcyA9IHBsLm5hbWVcclxuXHRcdFx0ZXh0c19wcmV0dHkgPSBcIiguI3twbC5leHRzLmpvaW4oXCIsIC5cIil9KVwiXHJcblx0XHRcdFxyXG5cdFx0XHRpZiBwbC5tYXRjaGVzX2V4dFxyXG5cdFx0XHRcdHBhbGV0dGUubG9hZGVkX2FzX2NsYXVzZSA9IGV4dHNfcHJldHR5XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHRwYWxldHRlLmxvYWRlZF9hc19jbGF1c2UgPSBcIiBmb3Igc29tZSByZWFzb25cIlxyXG5cdFx0XHRcclxuXHRcdFx0cGFsZXR0ZS5maW5hbGl6ZSgpXHJcblx0XHRcdGNhbGxiYWNrKG51bGwsIHBhbGV0dGUpXHJcblx0XHRcdHJldHVyblxyXG5cdFxyXG5cdGNhbGxiYWNrKG5ldyBMb2FkaW5nRXJyb3JzKGVycm9ycykpXHJcblx0cmV0dXJuXHJcblxyXG5vcHRpb25zID0gKG8gPSB7fSktPlxyXG5cdGlmIHR5cGVvZiBvIGlzIFwic3RyaW5nXCIgb3IgbyBpbnN0YW5jZW9mIFN0cmluZ1xyXG5cdFx0byA9IGZpbGVfbmFtZTogb1xyXG5cdGlmIEZpbGU/IGFuZCBvIGluc3RhbmNlb2YgRmlsZVxyXG5cdFx0byA9IGZpbGU6IG9cclxuXHRcclxuXHRvLm1pbl9jb2xvcnMgPz0gby5taW5Db2xvcnMgPyAyXHJcblx0by5tYXhfY29sb3JzID89IG8ubWF4Q29sb3JzID8gMjU2XHJcblx0by5maWxlX25hbWUgPz0gby5maWxlTmFtZSA/IG8uZm5hbWUgPyBvLmZpbGU/Lm5hbWVcclxuXHRvLmZpbGVfZXh0ID89IG8uZmlsZUV4dCA/IFwiI3tvLmZpbGVfbmFtZX1cIi5zcGxpdChcIi5cIikucG9wKClcclxuXHRvLmZpbGVfZXh0ID0gKFwiI3tvLmZpbGVfZXh0fVwiKS50b0xvd2VyQ2FzZSgpXHJcblx0b1xyXG5cdFxyXG5cclxuIyBHZXQgcGFsZXR0ZSBmcm9tIGEgZmlsZVxyXG5QYWxldHRlLmxvYWQgPSAobywgY2FsbGJhY2spLT5cclxuXHRpZiBub3Qgb1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yIFwiUGFyYW1ldGVycyByZXF1aXJlZDogUGFsZXR0ZS5sb2FkKG9wdGlvbnMsIGZ1bmN0aW9uIGNhbGxiYWNrKGVyciwgcGFsZXR0ZSl7fSlcIlxyXG5cdGlmIG5vdCBjYWxsYmFja1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yIFwiQ2FsbGJhY2sgcmVxdWlyZWQ6IFBhbGV0dGUubG9hZChvcHRpb25zLCBmdW5jdGlvbiBjYWxsYmFjayhlcnIsIHBhbGV0dGUpe30pXCJcclxuXHRcclxuXHRvID0gb3B0aW9ucyBvXHJcblx0XHJcblx0aWYgby5kYXRhXHJcblx0XHRsb2FkX3BhbGV0dGUobywgY2FsbGJhY2spXHJcblx0ZWxzZSBpZiBGaWxlPyBhbmQgby5maWxlIGluc3RhbmNlb2YgRmlsZVxyXG5cdFx0ZnIgPSBuZXcgRmlsZVJlYWRlclxyXG5cdFx0ZnIub25sb2FkID0gLT5cclxuXHRcdFx0by5kYXRhID0gZnIucmVzdWx0XHJcblx0XHRcdGxvYWRfcGFsZXR0ZShvLCBjYWxsYmFjaylcclxuXHRcdGZyLnJlYWRBc0JpbmFyeVN0cmluZyBvLmZpbGVcclxuXHRlbHNlIGlmIGdsb2JhbD9cclxuXHRcdFxyXG5cdFx0ZnMgPSByZXF1aXJlIFwiZnNcIlxyXG5cdFx0ZnMucmVhZEZpbGUgby5maWxlX25hbWUsIChlcnIsIGRhdGEpLT5cclxuXHRcdFx0aWYgZXJyXHJcblx0XHRcdFx0Y2FsbGJhY2soZXJyKVxyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0by5kYXRhID0gZGF0YS50b1N0cmluZyhcImJpbmFyeVwiKVxyXG5cdFx0XHRcdGxvYWRfcGFsZXR0ZShvLCBjYWxsYmFjaylcclxuXHRlbHNlXHJcblx0XHRjYWxsYmFjayhuZXcgRXJyb3IoXCJDb3VsZCBub3QgbG9hZC4gVGhlIEZpbGUgQVBJIG1heSBub3QgYmUgc3VwcG9ydGVkLlwiKSlcclxuXHJcblxyXG4jIEdldCBhIHBhbGV0dGUgZnJvbSBhIGZpbGUgb3IgYnkgYW55IG1lYW5zIG5lc3Nlc2FyeVxyXG4jIChhcyBpbiBmYWxsIGJhY2sgdG8gY29tcGxldGVseSByYW5kb20gZGF0YSlcclxuUGFsZXR0ZS5naW1tZSA9IChvLCBjYWxsYmFjayktPlxyXG5cdG8gPSBvcHRpb25zIG9cclxuXHRcclxuXHRQYWxldHRlLmxvYWQgbywgKGVyciwgcGFsZXR0ZSktPlxyXG5cdFx0Y2FsbGJhY2sobnVsbCwgcGFsZXR0ZSA/IG5ldyBSYW5kb21QYWxldHRlKVxyXG5cclxuIyBFeHBvcnRzXHJcblAgPSBtb2R1bGUuZXhwb3J0cyA9IFBhbGV0dGVcclxuUC5Db2xvciA9IENvbG9yXHJcblAuUGFsZXR0ZSA9IFBhbGV0dGVcclxuUC5SYW5kb21Db2xvciA9IFJhbmRvbUNvbG9yXHJcblAuUmFuZG9tUGFsZXR0ZSA9IFJhbmRvbVBhbGV0dGVcclxuIyBQLkxvYWRpbmdFcnJvcnMgPSBMb2FkaW5nRXJyb3JzXHJcbiIsIlxyXG4jIyNcclxuQmluYXJ5UmVhZGVyXHJcblxyXG5Nb2RpZmllZCBieSBJc2FpYWggT2RobmVyXHJcbkBUT0RPOiB1c2UgakRhdGFWaWV3ICsgakJpbmFyeSBpbnN0ZWFkXHJcblxyXG5SZWZhY3RvcmVkIGJ5IFZqZXV4IDx2amV1eHhAZ21haWwuY29tPlxyXG5odHRwOi8vYmxvZy52amV1eC5jb20vMjAxMC9qYXZhc2NyaXB0L2phdmFzY3JpcHQtYmluYXJ5LXJlYWRlci5odG1sXHJcblxyXG5PcmlnaW5hbFxyXG4rIEpvbmFzIFJhb25pIFNvYXJlcyBTaWx2YVxyXG5AIGh0dHA6Ly9qc2Zyb21oZWxsLmNvbS9jbGFzc2VzL2JpbmFyeS1wYXJzZXIgW3Jldi4gIzFdXHJcbiMjI1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPVxyXG5jbGFzcyBCaW5hcnlSZWFkZXJcclxuXHRjb25zdHJ1Y3RvcjogKGRhdGEpLT5cclxuXHRcdEBfYnVmZmVyID0gZGF0YVxyXG5cdFx0QF9wb3MgPSAwXHJcblxyXG5cdCMgUHVibGljIChjdXN0b20pXHJcblx0XHJcblx0cmVhZEJ5dGU6IC0+XHJcblx0XHRAX2NoZWNrU2l6ZSg4KVxyXG5cdFx0Y2ggPSB0aGlzLl9idWZmZXIuY2hhckNvZGVBdChAX3BvcykgJiAweGZmXHJcblx0XHRAX3BvcyArPSAxXHJcblx0XHRjaCAmIDB4ZmZcclxuXHRcclxuXHRyZWFkVW5pY29kZVN0cmluZzogLT5cclxuXHRcdGxlbmd0aCA9IEByZWFkVUludDE2KClcclxuXHRcdGNvbnNvbGUubG9nIHtsZW5ndGh9XHJcblx0XHRAX2NoZWNrU2l6ZShsZW5ndGggKiAxNilcclxuXHRcdHN0ciA9IFwiXCJcclxuXHRcdGZvciBpIGluIFswLi5sZW5ndGhdXHJcblx0XHRcdHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKEBfYnVmZmVyLnN1YnN0cihAX3BvcywgMSkgfCAoQF9idWZmZXIuc3Vic3RyKEBfcG9zKzEsIDEpIDw8IDgpKVxyXG5cdFx0XHRAX3BvcyArPSAyXHJcblx0XHRzdHJcclxuXHRcclxuXHQjIFB1YmxpY1xyXG5cdFxyXG5cdHJlYWRJbnQ4OiAtPiBAX2RlY29kZUludCg4LCB0cnVlKVxyXG5cdHJlYWRVSW50ODogLT4gQF9kZWNvZGVJbnQoOCwgZmFsc2UpXHJcblx0cmVhZEludDE2OiAtPiBAX2RlY29kZUludCgxNiwgdHJ1ZSlcclxuXHRyZWFkVUludDE2OiAtPiBAX2RlY29kZUludCgxNiwgZmFsc2UpXHJcblx0cmVhZEludDMyOiAtPiBAX2RlY29kZUludCgzMiwgdHJ1ZSlcclxuXHRyZWFkVUludDMyOiAtPiBAX2RlY29kZUludCgzMiwgZmFsc2UpXHJcblxyXG5cdHJlYWRGbG9hdDogLT4gQF9kZWNvZGVGbG9hdCgyMywgOClcclxuXHRyZWFkRG91YmxlOiAtPiBAX2RlY29kZUZsb2F0KDUyLCAxMSlcclxuXHRcclxuXHRyZWFkQ2hhcjogLT4gQHJlYWRTdHJpbmcoMSlcclxuXHRyZWFkU3RyaW5nOiAobGVuZ3RoKS0+XHJcblx0XHRAX2NoZWNrU2l6ZShsZW5ndGggKiA4KVxyXG5cdFx0cmVzdWx0ID0gQF9idWZmZXIuc3Vic3RyKEBfcG9zLCBsZW5ndGgpXHJcblx0XHRAX3BvcyArPSBsZW5ndGhcclxuXHRcdHJlc3VsdFxyXG5cclxuXHRzZWVrOiAocG9zKS0+XHJcblx0XHRAX3BvcyA9IHBvc1xyXG5cdFx0QF9jaGVja1NpemUoMClcclxuXHRcclxuXHRnZXRQb3NpdGlvbjogLT4gQF9wb3NcclxuXHRcclxuXHRnZXRTaXplOiAtPiBAX2J1ZmZlci5sZW5ndGhcclxuXHRcclxuXHJcblxyXG5cdCMgUHJpdmF0ZVxyXG5cdFxyXG5cdF9kZWNvZGVGbG9hdDogYGZ1bmN0aW9uKHByZWNpc2lvbkJpdHMsIGV4cG9uZW50Qml0cyl7XHJcblx0XHR2YXIgbGVuZ3RoID0gcHJlY2lzaW9uQml0cyArIGV4cG9uZW50Qml0cyArIDE7XHJcblx0XHR2YXIgc2l6ZSA9IGxlbmd0aCA+PiAzO1xyXG5cdFx0dGhpcy5fY2hlY2tTaXplKGxlbmd0aCk7XHJcblxyXG5cdFx0dmFyIGJpYXMgPSBNYXRoLnBvdygyLCBleHBvbmVudEJpdHMgLSAxKSAtIDE7XHJcblx0XHR2YXIgc2lnbmFsID0gdGhpcy5fcmVhZEJpdHMocHJlY2lzaW9uQml0cyArIGV4cG9uZW50Qml0cywgMSwgc2l6ZSk7XHJcblx0XHR2YXIgZXhwb25lbnQgPSB0aGlzLl9yZWFkQml0cyhwcmVjaXNpb25CaXRzLCBleHBvbmVudEJpdHMsIHNpemUpO1xyXG5cdFx0dmFyIHNpZ25pZmljYW5kID0gMDtcclxuXHRcdHZhciBkaXZpc29yID0gMjtcclxuXHRcdHZhciBjdXJCeXRlID0gMDsgLy9sZW5ndGggKyAoLXByZWNpc2lvbkJpdHMgPj4gMykgLSAxO1xyXG5cdFx0ZG8ge1xyXG5cdFx0XHR2YXIgYnl0ZVZhbHVlID0gdGhpcy5fcmVhZEJ5dGUoKytjdXJCeXRlLCBzaXplKTtcclxuXHRcdFx0dmFyIHN0YXJ0Qml0ID0gcHJlY2lzaW9uQml0cyAlIDggfHwgODtcclxuXHRcdFx0dmFyIG1hc2sgPSAxIDw8IHN0YXJ0Qml0O1xyXG5cdFx0XHR3aGlsZSAobWFzayA+Pj0gMSkge1xyXG5cdFx0XHRcdGlmIChieXRlVmFsdWUgJiBtYXNrKSB7XHJcblx0XHRcdFx0XHRzaWduaWZpY2FuZCArPSAxIC8gZGl2aXNvcjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZGl2aXNvciAqPSAyO1xyXG5cdFx0XHR9XHJcblx0XHR9IHdoaWxlIChwcmVjaXNpb25CaXRzIC09IHN0YXJ0Qml0KTtcclxuXHJcblx0XHR0aGlzLl9wb3MgKz0gc2l6ZTtcclxuXHJcblx0XHRyZXR1cm4gZXhwb25lbnQgPT0gKGJpYXMgPDwgMSkgKyAxID8gc2lnbmlmaWNhbmQgPyBOYU4gOiBzaWduYWwgPyAtSW5maW5pdHkgOiArSW5maW5pdHlcclxuXHRcdFx0OiAoMSArIHNpZ25hbCAqIC0yKSAqIChleHBvbmVudCB8fCBzaWduaWZpY2FuZCA/ICFleHBvbmVudCA/IE1hdGgucG93KDIsIC1iaWFzICsgMSkgKiBzaWduaWZpY2FuZFxyXG5cdFx0XHQ6IE1hdGgucG93KDIsIGV4cG9uZW50IC0gYmlhcykgKiAoMSArIHNpZ25pZmljYW5kKSA6IDApO1xyXG5cdH1gXHJcblxyXG5cdF9kZWNvZGVJbnQ6IGBmdW5jdGlvbihiaXRzLCBzaWduZWQpe1xyXG5cdFx0dmFyIHggPSB0aGlzLl9yZWFkQml0cygwLCBiaXRzLCBiaXRzIC8gOCksIG1heCA9IE1hdGgucG93KDIsIGJpdHMpO1xyXG5cdFx0dmFyIHJlc3VsdCA9IHNpZ25lZCAmJiB4ID49IG1heCAvIDIgPyB4IC0gbWF4IDogeDtcclxuXHJcblx0XHR0aGlzLl9wb3MgKz0gYml0cyAvIDg7XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1gXHJcblxyXG5cdCNzaGwgZml4OiBIZW5yaSBUb3JnZW1hbmUgfjE5OTYgKGNvbXByZXNzZWQgYnkgSm9uYXMgUmFvbmkpXHJcblx0X3NobDogYGZ1bmN0aW9uIChhLCBiKXtcclxuXHRcdGZvciAoKytiOyAtLWI7IGEgPSAoKGEgJT0gMHg3ZmZmZmZmZiArIDEpICYgMHg0MDAwMDAwMCkgPT0gMHg0MDAwMDAwMCA/IGEgKiAyIDogKGEgLSAweDQwMDAwMDAwKSAqIDIgKyAweDdmZmZmZmZmICsgMSk7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9YFxyXG5cdFxyXG5cdF9yZWFkQnl0ZTogYGZ1bmN0aW9uIChpLCBzaXplKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fYnVmZmVyLmNoYXJDb2RlQXQodGhpcy5fcG9zICsgc2l6ZSAtIGkgLSAxKSAmIDB4ZmY7XHJcblx0fWBcclxuXHJcblx0X3JlYWRCaXRzOiBgZnVuY3Rpb24gKHN0YXJ0LCBsZW5ndGgsIHNpemUpIHtcclxuXHRcdHZhciBvZmZzZXRMZWZ0ID0gKHN0YXJ0ICsgbGVuZ3RoKSAlIDg7XHJcblx0XHR2YXIgb2Zmc2V0UmlnaHQgPSBzdGFydCAlIDg7XHJcblx0XHR2YXIgY3VyQnl0ZSA9IHNpemUgLSAoc3RhcnQgPj4gMykgLSAxO1xyXG5cdFx0dmFyIGxhc3RCeXRlID0gc2l6ZSArICgtKHN0YXJ0ICsgbGVuZ3RoKSA+PiAzKTtcclxuXHRcdHZhciBkaWZmID0gY3VyQnl0ZSAtIGxhc3RCeXRlO1xyXG5cclxuXHRcdHZhciBzdW0gPSAodGhpcy5fcmVhZEJ5dGUoY3VyQnl0ZSwgc2l6ZSkgPj4gb2Zmc2V0UmlnaHQpICYgKCgxIDw8IChkaWZmID8gOCAtIG9mZnNldFJpZ2h0IDogbGVuZ3RoKSkgLSAxKTtcclxuXHJcblx0XHRpZiAoZGlmZiAmJiBvZmZzZXRMZWZ0KSB7XHJcblx0XHRcdHN1bSArPSAodGhpcy5fcmVhZEJ5dGUobGFzdEJ5dGUrKywgc2l6ZSkgJiAoKDEgPDwgb2Zmc2V0TGVmdCkgLSAxKSkgPDwgKGRpZmYtLSA8PCAzKSAtIG9mZnNldFJpZ2h0OyBcclxuXHRcdH1cclxuXHJcblx0XHR3aGlsZSAoZGlmZikge1xyXG5cdFx0XHRzdW0gKz0gdGhpcy5fc2hsKHRoaXMuX3JlYWRCeXRlKGxhc3RCeXRlKyssIHNpemUpLCAoZGlmZi0tIDw8IDMpIC0gb2Zmc2V0UmlnaHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzdW07XHJcblx0fWBcclxuXHJcblx0X2NoZWNrU2l6ZTogKG5lZWRlZEJpdHMpLT5cclxuXHRcdGlmIEBfcG9zICsgTWF0aC5jZWlsKG5lZWRlZEJpdHMgLyA4KSA+IEBfYnVmZmVyLmxlbmd0aFxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IgXCJJbmRleCBvdXQgb2YgYm91bmRcIlxyXG5cclxuIiwiXHJcbm1vZHVsZS5leHBvcnRzID1cclxuY2xhc3MgQ29sb3JcclxuXHQjIEBUT0RPOiBkb24ndCBhc3NpZ24ge0ByLCBAZywgQGIsIEBoLCBAcywgQHYsIEBsfSByaWdodCBhd2F5XHJcblx0IyAobW9yZSBvZiBhIHRvLWRvbid0LCByZWFsbHkpXHJcblx0Y29uc3RydWN0b3I6ICh7XHJcblx0XHRAciwgQGcsIEBiLFxyXG5cdFx0QGgsIEBzLCBAdiwgQGwsXHJcblx0XHRjLCBtLCB5LCBrLFxyXG5cdFx0QG5hbWVcclxuXHR9KS0+XHJcblx0XHRpZiBAcj8gYW5kIEBnPyBhbmQgQGI/XHJcblx0XHRcdCMgUmVkIEdyZWVuIEJsdWVcclxuXHRcdGVsc2UgaWYgQGg/IGFuZCBAcz9cclxuXHRcdFx0IyBDeWxpbmRyaWNhbCBDb2xvciBTcGFjZVxyXG5cdFx0XHRpZiBAdj9cclxuXHRcdFx0XHQjIEh1ZSBTYXR1cmF0aW9uIFZhbHVlXHJcblx0XHRcdFx0QGwgPSAoMiAtIEBzIC8gMTAwKSAqIEB2IC8gMlxyXG5cdFx0XHRcdEBzID0gQHMgKiBAdiAvIChpZiBAbCA8IDUwIHRoZW4gQGwgKiAyIGVsc2UgMjAwIC0gQGwgKiAyKVxyXG5cdFx0XHRcdEBzID0gMCBpZiBpc05hTiBAc1xyXG5cdFx0XHRlbHNlIGlmIEBsP1xyXG5cdFx0XHRcdCMgSHVlIFNhdHVyYXRpb24gTGlnaHRuZXNzXHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IgXCJIdWUsIHNhdHVyYXRpb24sIGFuZC4uLj8gKGVpdGhlciBsaWdodG5lc3Mgb3IgdmFsdWUpXCJcclxuXHRcdGVsc2UgaWYgYz8gYW5kIG0/IGFuZCB5PyBhbmQgaz9cclxuXHRcdFx0IyBDeWFuIE1hZ2VudGEgWWVsbG93IGJsYWNLXHJcblx0XHRcdCMgVU5URVNURURcclxuXHRcdFx0YyAvPSAxMDBcclxuXHRcdFx0bSAvPSAxMDBcclxuXHRcdFx0eSAvPSAxMDBcclxuXHRcdFx0ayAvPSAxMDBcclxuXHRcdFx0XHJcblx0XHRcdEByID0gMjU1ICogKDEgLSBNYXRoLm1pbigxLCBjICogKDEgLSBrKSArIGspKVxyXG5cdFx0XHRAZyA9IDI1NSAqICgxIC0gTWF0aC5taW4oMSwgbSAqICgxIC0gaykgKyBrKSlcclxuXHRcdFx0QGIgPSAyNTUgKiAoMSAtIE1hdGgubWluKDEsIHkgKiAoMSAtIGspICsgaykpXHJcblx0XHRlbHNlXHJcblx0XHRcdCMgVU5URVNURUQgVU5URVNURUQgVU5URVNURUQgVU5URVNURUQgVU5URVNURUQgVU5URVNURURcclxuXHRcdFx0aWYgQGw/IGFuZCBAYT8gYW5kIEBiP1xyXG5cdFx0XHRcdHdoaXRlID1cclxuXHRcdFx0XHRcdHg6IDk1LjA0N1xyXG5cdFx0XHRcdFx0eTogMTAwLjAwMFxyXG5cdFx0XHRcdFx0ejogMTA4Ljg4M1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdHh5eiA9IFxyXG5cdFx0XHRcdFx0eTogKHJhdy5sICsgMTYpIC8gMTE2XHJcblx0XHRcdFx0XHR4OiByYXcuYSAvIDUwMCArIHh5ei55XHJcblx0XHRcdFx0XHR6OiB4eXoueSAtIHJhdy5iIC8gMjAwXHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Zm9yIF8gaW4gXCJ4eXpcIlxyXG5cdFx0XHRcdFx0cG93ZWQgPSBNYXRoLnBvdyh4eXpbX10sIDMpXHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdGlmIHBvd2VkID4gMC4wMDg4NTZcclxuXHRcdFx0XHRcdFx0eHl6W19dID0gcG93ZWRcclxuXHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0eHl6W19dID0gKHh5eltfXSAtIDE2IC8gMTE2KSAvIDcuNzg3XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdCN4eXpbX10gPSBfcm91bmQoeHl6W19dICogd2hpdGVbX10pXHJcblx0XHRcdFx0XHJcblx0XHRcdCMgVU5URVNURUQgVU5URVNURUQgVU5URVNURUQgVU5URVNURURcclxuXHRcdFx0aWYgQHg/IGFuZCBAeT8gYW5kIEB6P1xyXG5cdFx0XHRcdHh5eiA9XHJcblx0XHRcdFx0XHR4OiByYXcueCAvIDEwMFxyXG5cdFx0XHRcdFx0eTogcmF3LnkgLyAxMDBcclxuXHRcdFx0XHRcdHo6IHJhdy56IC8gMTAwXHJcblx0XHRcdFx0XHJcblx0XHRcdFx0cmdiID1cclxuXHRcdFx0XHRcdHI6IHh5ei54ICogMy4yNDA2ICsgeHl6LnkgKiAtMS41MzcyICsgeHl6LnogKiAtMC40OTg2XHJcblx0XHRcdFx0XHRnOiB4eXoueCAqIC0wLjk2ODkgKyB4eXoueSAqIDEuODc1OCArIHh5ei56ICogMC4wNDE1XHJcblx0XHRcdFx0XHRiOiB4eXoueCAqIDAuMDU1NyArIHh5ei55ICogLTAuMjA0MCArIHh5ei56ICogMS4wNTcwXHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Zm9yIF8gaW4gXCJyZ2JcIlxyXG5cdFx0XHRcdFx0I3JnYltfXSA9IF9yb3VuZChyZ2JbX10pXHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdGlmIHJnYltfXSA8IDBcclxuXHRcdFx0XHRcdFx0cmdiW19dID0gMFxyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRpZiByZ2JbX10gPiAwLjAwMzEzMDhcclxuXHRcdFx0XHRcdFx0cmdiW19dID0gMS4wNTUgKiBNYXRoLnBvdyhyZ2JbX10sICgxIC8gMi40KSkgLSAwLjA1NVxyXG5cdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHRyZ2JbX10gKj0gMTIuOTJcclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0XHQjcmdiW19dID0gTWF0aC5yb3VuZChyZ2JbX10gKiAyNTUpXHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IgXCJDb2xvciBjb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHtyLGcsYn0gb3Ige2gscyx2fSBvciB7aCxzLGx9IG9yIHtjLG0seSxrfSBvciB7eCx5LHp9IG9yIHtsLGEsYn1cIlxyXG5cdFx0XHJcblx0XHJcblx0dG9TdHJpbmc6IC0+XHJcblx0XHRpZiBAcj9cclxuXHRcdFx0IyBSZWQgR3JlZW4gQmx1ZVxyXG5cdFx0XHRpZiBAYT8gIyBBbHBoYVxyXG5cdFx0XHRcdFwicmdiYSgje0ByfSwgI3tAZ30sICN7QGJ9LCAje0BhfSlcIlxyXG5cdFx0XHRlbHNlICMgT3BhcXVlXHJcblx0XHRcdFx0XCJyZ2IoI3tAcn0sICN7QGd9LCAje0BifSlcIlxyXG5cdFx0ZWxzZSBpZiBAaD9cclxuXHRcdFx0IyBIdWUgU2F0dXJhdGlvbiBMaWdodG5lc3NcclxuXHRcdFx0IyAoQXNzdW1lIGg6MC0zNjAsIHM6MC0xMDAsIGw6MC0xMDApXHJcblx0XHRcdGlmIEBhPyAjIEFscGhhXHJcblx0XHRcdFx0XCJoc2xhKCN7QGh9LCAje0BzfSUsICN7QGx9JSwgI3tAYX0pXCJcclxuXHRcdFx0ZWxzZSAjIE9wYXF1ZVxyXG5cdFx0XHRcdFwiaHNsKCN7QGh9LCAje0BzfSUsICN7QGx9JSlcIlxyXG5cdFxyXG5cdGlzOiAoY29sb3IpLT5cclxuXHRcdFwiI3tAfVwiIGlzIFwiI3tjb2xvcn1cIlxyXG4iLCJcclxuQ29sb3IgPSByZXF1aXJlIFwiLi9Db2xvclwiXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9XHJcbmNsYXNzIFBhbGV0dGUgZXh0ZW5kcyBBcnJheVxyXG5cdFxyXG5cdGNvbnN0cnVjdG9yOiAtPlxyXG5cdFx0c3VwZXIoKVxyXG5cdFx0QHdpdGhfZHVwbGljYXRlcyA9IEBcclxuXHRcdFxyXG5cdGFkZDogKG8pLT5cclxuXHRcdG5ld19jb2xvciA9IG5ldyBDb2xvcihvKVxyXG5cdFx0XHJcblx0XHRpZiBAd2l0aF9kdXBsaWNhdGVzIGlzIEBcclxuXHRcdFx0QHdpdGhfZHVwbGljYXRlcyA9IG5ldyBQYWxldHRlKClcclxuXHRcdFxyXG5cdFx0QHdpdGhfZHVwbGljYXRlcy5wdXNoIG5ld19jb2xvclxyXG5cdFx0XHJcblx0XHRmb3IgY29sb3IgaW4gQFxyXG5cdFx0XHRpZiBjb2xvci5pcyBuZXdfY29sb3JcclxuXHRcdFx0XHRuZXdfY29sb3IuaXNfZHVwbGljYXRlID0gdHJ1ZVxyXG5cdFx0XHRcdHJldHVyblxyXG5cdFx0XHJcblx0XHRAcHVzaCBuZXdfY29sb3JcclxuXHRcclxuXHRmaW5hbGl6ZTogLT5cclxuXHRcdGlmIG5vdCBAbl9jb2x1bW5zXHJcblx0XHRcdEBndWVzc19kaW1lbnNpb25zKClcclxuXHRcdGlmIEB3aXRoX2R1cGxpY2F0ZXNcclxuXHRcdFx0QHdpdGhfZHVwbGljYXRlcy5ndWVzc19kaW1lbnNpb25zKClcclxuXHRcdFxyXG5cdGd1ZXNzX2RpbWVuc2lvbnM6IC0+XHJcblx0XHRsZW4gPSBAbGVuZ3RoXHJcblx0XHRjYW5kaWRhdGVfZGltZW5zaW9ucyA9IFtdXHJcblx0XHRmb3Igbl9jb2x1bW5zIGluIFswLi5sZW5dXHJcblx0XHRcdG5fcm93cyA9IGxlbiAvIG5fY29sdW1uc1xyXG5cdFx0XHRpZiBuX3Jvd3MgaXMgTWF0aC5yb3VuZCBuX3Jvd3NcclxuXHRcdFx0XHRjYW5kaWRhdGVfZGltZW5zaW9ucy5wdXNoIFtuX3Jvd3MsIG5fY29sdW1uc11cclxuXHRcdFxyXG5cdFx0c3F1YXJlc3QgPSBbMCwgMzQ5NTA5M11cclxuXHRcdGZvciBjZCBpbiBjYW5kaWRhdGVfZGltZW5zaW9uc1xyXG5cdFx0XHRpZiBNYXRoLmFicyhjZFswXSAtIGNkWzFdKSA8IE1hdGguYWJzKHNxdWFyZXN0WzBdIC0gc3F1YXJlc3RbMV0pXHJcblx0XHRcdFx0c3F1YXJlc3QgPSBjZFxyXG5cdFx0XHJcblx0XHQjQG5fY29sdW1ucyA9IHNxdWFyZXN0WzFdXHJcbiIsIlxyXG4jIExvYWQgYSBDb2xvclNjaGVtZXIgcGFsZXR0ZVxyXG5cclxuQmluYXJ5UmVhZGVyID0gcmVxdWlyZSBcIi4uL0JpbmFyeVJlYWRlclwiXHJcblBhbGV0dGUgPSByZXF1aXJlIFwiLi4vUGFsZXR0ZVwiXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9ICh7ZGF0YX0pLT5cclxuXHRcclxuXHRwYWxldHRlID0gbmV3IFBhbGV0dGUoKVxyXG5cdGJyID0gbmV3IEJpbmFyeVJlYWRlcihkYXRhKVxyXG5cdFxyXG5cdHZlcnNpb24gPSBici5yZWFkVUludDE2KCkgIyBvciBzb21ldGhpbmdcclxuXHRsZW5ndGggPSBici5yZWFkVUludDE2KClcclxuXHRpID0gMFxyXG5cdHdoaWxlIGkgPCBsZW5ndGhcclxuXHRcdGJyLnNlZWsoOCArIGkgKiAyNilcclxuXHRcdHBhbGV0dGUuYWRkXHJcblx0XHRcdHI6IGJyLnJlYWRCeXRlKClcclxuXHRcdFx0ZzogYnIucmVhZEJ5dGUoKVxyXG5cdFx0XHRiOiBici5yZWFkQnl0ZSgpXHJcblx0XHRpICs9IDFcclxuXHJcblx0cGFsZXR0ZVxyXG5cclxuIiwiXHJcbiMgTG9hZCBhIEdJTVAgcGFsZXR0ZVxyXG5cclxuUGFsZXR0ZSA9IHJlcXVpcmUgXCIuLi9QYWxldHRlXCJcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKHtkYXRhfSktPlxyXG5cdGxpbmVzID0gZGF0YS5zcGxpdCgvW1xcblxccl0rL20pXHJcblx0aWYgbGluZXNbMF0gaXNudCBcIkdJTVAgUGFsZXR0ZVwiXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IgXCJOb3QgYSBHSU1QIFBhbGV0dGVcIlxyXG5cdFxyXG5cdHBhbGV0dGUgPSBuZXcgUGFsZXR0ZSgpXHJcblx0aSA9IDFcclxuXHR3aGlsZSAoaSArPSAxKSA8IGxpbmVzLmxlbmd0aFxyXG5cdFx0bGluZSA9IGxpbmVzW2ldXHJcblx0XHRcclxuXHRcdGlmIGxpbmUubWF0Y2goL14jLykgb3IgbGluZSBpcyBcIlwiIHRoZW4gY29udGludWVcclxuXHRcdFxyXG5cdFx0bSA9IGxpbmUubWF0Y2goL05hbWU6XFxzKiguKikvKVxyXG5cdFx0aWYgbVxyXG5cdFx0XHRwYWxldHRlLm5hbWUgPSBtWzFdXHJcblx0XHRcdGNvbnRpbnVlXHJcblx0XHRtID0gbGluZS5tYXRjaCgvQ29sdW1uczpcXHMqKC4qKS8pXHJcblx0XHRpZiBtXHJcblx0XHRcdHBhbGV0dGUubl9jb2x1bW5zID0gTnVtYmVyKG1bMV0pXHJcblx0XHRcdHBhbGV0dGUuaGFzX2RpbWVuc2lvbnMgPSB5ZXNcclxuXHRcdFx0Y29udGludWVcclxuXHRcdFxyXG5cdFx0cl9nX2JfbmFtZSA9IGxpbmUubWF0Y2goL15cXHMqKFswLTldKylcXHMrKFswLTldKylcXHMrKFswLTldKykoPzpcXHMrKC4qKSk/JC8pXHJcblx0XHRpZiBub3Qgcl9nX2JfbmFtZVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IgXCJMaW5lICN7aX0gZG9lc24ndCBtYXRjaCBwYXR0ZXJuIHJfZ19iX25hbWVcIlxyXG5cdFx0XHJcblx0XHRwYWxldHRlLmFkZFxyXG5cdFx0XHRyOiByX2dfYl9uYW1lWzFdXHJcblx0XHRcdGc6IHJfZ19iX25hbWVbMl1cclxuXHRcdFx0Yjogcl9nX2JfbmFtZVszXVxyXG5cdFx0XHRuYW1lOiByX2dfYl9uYW1lWzRdXHJcblx0XHRcclxuXHRwYWxldHRlXHJcbiIsIlxyXG4jIERldGVjdCBDU1MgY29sb3JzIChleGNlcHQgbmFtZWQgY29sb3JzKVxyXG5cclxuUGFsZXR0ZSA9IHJlcXVpcmUgXCIuLi9QYWxldHRlXCJcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKHtkYXRhfSktPlxyXG5cdFxyXG5cdHBhbGV0dGVzID0gW1xyXG5cdFx0cGFsZXR0ZV94UlJHR0JCID0gbmV3IFBhbGV0dGUoKVxyXG5cdFx0cGFsZXR0ZV94UkdCID0gbmV3IFBhbGV0dGUoKVxyXG5cdFx0cGFsZXR0ZV9yZ2IgPSBuZXcgUGFsZXR0ZSgpXHJcblx0XHRwYWxldHRlX2hzbCA9IG5ldyBQYWxldHRlKClcclxuXHRcdHBhbGV0dGVfaHNsYSA9IG5ldyBQYWxldHRlKClcclxuXHRcdHBhbGV0dGVfcmdiYSA9IG5ldyBQYWxldHRlKClcclxuXHRdXHJcblx0XHJcblx0aGV4ID0gKHgpLT4gcGFyc2VJbnQoeCwgMTYpXHJcblx0XHJcblx0ZGF0YS5yZXBsYWNlIC8vL1xyXG5cdFx0XFwjICMgaGFzaHRhZyAjICMvXHJcblx0XHQoWzAtOUEtRl17Mn0pPyAjIGFscGhhXHJcblx0XHQoWzAtOUEtRl17M30pICMgdGhyZWUgZGlnaXRzICgjQTBDKVxyXG5cdFx0KFswLTlBLUZdezN9KT8gIyBzaXggZGlnaXRzICgjQUEwMENDKVxyXG5cdFx0XHJcblx0XHQoPyFbMC05QS1GXSkgIyAoYW5kIG5vIG1vcmUhKVxyXG5cdC8vL2dpbSwgKG0sICQwLCAkMSwgJDIpLT5cclxuXHRcdFxyXG5cdFx0YWxwaGEgPSBoZXggJDBcclxuXHRcdFxyXG5cdFx0aWYgJDJcclxuXHRcdFx0eFJHQiA9ICQxICsgJDJcclxuXHRcdFx0cGFsZXR0ZV94UlJHR0JCLmFkZFxyXG5cdFx0XHRcdHI6IGhleCB4UkdCWzBdICsgeFJHQlsxXVxyXG5cdFx0XHRcdGc6IGhleCB4UkdCWzJdICsgeFJHQlszXVxyXG5cdFx0XHRcdGI6IGhleCB4UkdCWzRdICsgeFJHQls1XVxyXG5cdFx0XHRcdGE6IGFscGhhXHJcblx0XHRlbHNlXHJcblx0XHRcdHhSR0IgPSAkMVxyXG5cdFx0XHRwYWxldHRlX3hSR0IuYWRkXHJcblx0XHRcdFx0cjogaGV4IHhSR0JbMF0gKyB4UkdCWzBdXHJcblx0XHRcdFx0ZzogaGV4IHhSR0JbMV0gKyB4UkdCWzFdXHJcblx0XHRcdFx0YjogaGV4IHhSR0JbMl0gKyB4UkdCWzJdXHJcblx0XHRcdFx0YTogYWxwaGFcclxuXHRcclxuXHRkYXRhLnJlcGxhY2UgLy8vXHJcblx0XHRyZ2JcXChcclxuXHRcdFx0XFxzKlxyXG5cdFx0XHQoWzAtOV17MSwzfSkgIyByZWRcclxuXHRcdCxcdFxccypcclxuXHRcdFx0KFswLTldezEsM30pICMgZ3JlZW5cclxuXHRcdCxcdFxccypcclxuXHRcdFx0KFswLTldezEsM30pICMgYmx1ZVxyXG5cdFx0XHRcXHMqXHJcblx0XHRcXClcclxuXHQvLy9naW0sIChtKS0+XHJcblx0XHRwYWxldHRlX3JnYi5hZGRcclxuXHRcdFx0cjogTnVtYmVyIG1bMV1cclxuXHRcdFx0ZzogTnVtYmVyIG1bMl1cclxuXHRcdFx0YjogTnVtYmVyIG1bM11cclxuXHRcclxuXHRkYXRhLnJlcGxhY2UgLy8vXHJcblx0XHRyZ2JhXFwoXHJcblx0XHRcdFxccypcclxuXHRcdFx0KFswLTldezEsM30pICMgcmVkXHJcblx0XHQsXHRcXHMqXHJcblx0XHRcdChbMC05XXsxLDN9KSAjIGdyZWVuXHJcblx0XHQsXHRcXHMqXHJcblx0XHRcdChbMC05XXsxLDN9KSAjIGJsdWVcclxuXHRcdCxcdFxccypcclxuXHRcdFx0KFswLTldezEsM318MFxcLlswLTldKykgIyBhbHBoYVxyXG5cdFx0XHRcXHMqXHJcblx0XHRcXClcclxuXHQvLy9naW0sIChtKS0+XHJcblx0XHRwYWxldHRlX3JnYi5hZGRcclxuXHRcdFx0cjogTnVtYmVyIG1bMV1cclxuXHRcdFx0ZzogTnVtYmVyIG1bMl1cclxuXHRcdFx0YjogTnVtYmVyIG1bM11cclxuXHRcdFx0YTogTnVtYmVyIG1bNF1cclxuXHRcclxuXHRkYXRhLnJlcGxhY2UgLy8vXHJcblx0XHRoc2xcXChcclxuXHRcdFx0XFxzKlxyXG5cdFx0XHQoWzAtOV17MSwzfSkgIyBodWVcclxuXHRcdCxcdFxccypcclxuXHRcdFx0KFswLTldezEsM30pICMgc2F0dXJhdGlvblxyXG5cdFx0LFx0XFxzKlxyXG5cdFx0XHQoWzAtOV17MSwzfSkgIyB2YWx1ZVxyXG5cdFx0XHRcXHMqXHJcblx0XHRcXClcclxuXHQvLy9naW0sIChtKS0+XHJcblx0XHRwYWxldHRlX3JnYi5hZGRcclxuXHRcdFx0aDogTnVtYmVyIG1bMV1cclxuXHRcdFx0czogTnVtYmVyIG1bMl1cclxuXHRcdFx0bDogTnVtYmVyIG1bM11cclxuXHRcclxuXHRtb3N0X2NvbG9ycyA9IFtdXHJcblx0Zm9yIHBhbGV0dGUgaW4gcGFsZXR0ZXNcclxuXHRcdGlmIHBhbGV0dGUubGVuZ3RoID49IG1vc3RfY29sb3JzLmxlbmd0aFxyXG5cdFx0XHRtb3N0X2NvbG9ycyA9IHBhbGV0dGVcclxuXHRcclxuXHRuID0gbW9zdF9jb2xvcnMubGVuZ3RoXHJcblx0aWYgbiA8IDRcclxuXHRcdHRocm93IG5ldyBFcnJvcihbXHJcblx0XHRcdFwiTm8gY29sb3JzIGZvdW5kXCJcclxuXHRcdFx0XCJPbmx5IG9uZSBjb2xvciBmb3VuZFwiXHJcblx0XHRcdFwiT25seSBhIGNvdXBsZSBjb2xvcnMgZm91bmRcIlxyXG5cdFx0XHRcIk9ubHkgYSBmZXcgY29sb3JzIGZvdW5kXCJcclxuXHRcdF1bbl0gKyBcIiAoI3tufSlcIilcclxuXHRcclxuXHRtb3N0X2NvbG9yc1xyXG4iLCJcclxuIyBXaGF0IGRvZXMgSFBMIHN0YW5kIGZvcj9cclxuIyBIb3dkeSwgUGFsZXR0ZSBMb3ZlcnMhXHJcblxyXG5QYWxldHRlID0gcmVxdWlyZSBcIi4uL1BhbGV0dGVcIlxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoe2RhdGF9KS0+XHJcblx0bGluZXMgPSBkYXRhLnNwbGl0KC9bXFxuXFxyXSsvbSlcclxuXHRpZiBsaW5lc1swXSBpc250IFwiUGFsZXR0ZVwiXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IgXCJOb3QgYW4gSFBMIHBhbGV0dGVcIlxyXG5cdGlmIG5vdCBsaW5lc1sxXS5tYXRjaCAvVmVyc2lvbiBbMzRdXFwuMC9cclxuXHRcdHRocm93IG5ldyBFcnJvciBcIlVuc3VwcG9ydGVkIEhQTCB2ZXJzaW9uXCJcclxuXHRcclxuXHRwYWxldHRlID0gbmV3IFBhbGV0dGUoKVxyXG5cdFxyXG5cdGZvciBsaW5lLCBpIGluIGxpbmVzXHJcblx0XHRpZiBsaW5lLm1hdGNoIC8uKyAuKiAuKy9cclxuXHRcdFx0cmdiID0gbGluZS5zcGxpdChcIiBcIilcclxuXHRcdFx0cGFsZXR0ZS5hZGRcclxuXHRcdFx0XHRyOiByZ2JbMF1cclxuXHRcdFx0XHRnOiByZ2JbMV1cclxuXHRcdFx0XHRiOiByZ2JbMl1cclxuXHRcclxuXHRwYWxldHRlXHJcbiIsIlxyXG4jIExvYWQgYSBQYWludC5ORVQgcGFsZXR0ZSBmaWxlXHJcblxyXG5CaW5hcnlSZWFkZXIgPSByZXF1aXJlIFwiLi4vQmluYXJ5UmVhZGVyXCJcclxuUGFsZXR0ZSA9IHJlcXVpcmUgXCIuLi9QYWxldHRlXCJcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKHtkYXRhfSktPlxyXG5cdFxyXG5cdHBhbGV0dGUgPSBuZXcgUGFsZXR0ZSgpXHJcblx0XHJcblx0aGV4ID0gKHgpLT4gcGFyc2VJbnQoeCwgMTYpXHJcblx0XHJcblx0Zm9yIGxpbmUgaW4gZGF0YS5zcGxpdCgvW1xcblxccl0rL20pXHJcblx0XHRtID0gbGluZS5tYXRjaCgvXihbMC05QS1GXXsyfSkoWzAtOUEtRl17Mn0pKFswLTlBLUZdezJ9KShbMC05QS1GXXsyfSkkL2kpXHJcblx0XHRpZiBtIHRoZW4gcGFsZXR0ZS5hZGRcclxuXHRcdFx0YTogaGV4IG1bMV1cclxuXHRcdFx0cjogaGV4IG1bMl1cclxuXHRcdFx0ZzogaGV4IG1bM11cclxuXHRcdFx0YjogaGV4IG1bNF1cclxuXHRcclxuXHRwYWxldHRlXHJcbiIsIlxyXG4jIExvYWQgYSBKQVNDIFBBTCBmaWxlIChQYWludCBTaG9wIFBybyBwYWxldHRlIGZpbGUpXHJcblxyXG5CaW5hcnlSZWFkZXIgPSByZXF1aXJlIFwiLi4vQmluYXJ5UmVhZGVyXCJcclxuUGFsZXR0ZSA9IHJlcXVpcmUgXCIuLi9QYWxldHRlXCJcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKHtkYXRhfSktPlxyXG5cdGxpbmVzID0gZGF0YS5zcGxpdCgvW1xcblxccl0rL20pXHJcblx0aWYgbGluZXNbMF0gaXNudCBcIkpBU0MtUEFMXCJcclxuXHRcdHRocm93IG5ldyBFcnJvciBcIk5vdCBhIEpBU0MtUEFMXCJcclxuXHRpZiBsaW5lc1sxXSBpc250IFwiMDEwMFwiXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IgXCJVbmtub3duIEpBU0MtUEFMIHZlcnNpb25cIlxyXG5cdGlmIGxpbmVzWzJdIGlzbnQgXCIyNTZcIlxyXG5cdFx0XCJ0aGF0J3Mgb2tcIlxyXG5cdFxyXG5cdHBhbGV0dGUgPSBuZXcgUGFsZXR0ZSgpXHJcblx0I25fY29sb3JzID0gTnVtYmVyKGxpbmVzWzJdKVxyXG5cdFxyXG5cdGZvciBsaW5lLCBpIGluIGxpbmVzXHJcblx0XHRpZiBsaW5lIGlzbnQgXCJcIiBhbmQgaSA+IDJcclxuXHRcdFx0cmdiID0gbGluZS5zcGxpdChcIiBcIilcclxuXHRcdFx0cGFsZXR0ZS5hZGRcclxuXHRcdFx0XHRyOiByZ2JbMF1cclxuXHRcdFx0XHRnOiByZ2JbMV1cclxuXHRcdFx0XHRiOiByZ2JbMl1cclxuXHRcclxuXHRwYWxldHRlXHJcbiIsIlxyXG4jIExvYWQgYSBSZXNvdXJjZSBJbnRlcmNoYW5nZSBGaWxlIEZvcm1hdCBQQUwgZmlsZVxyXG5cclxuIyBwb3J0ZWQgZnJvbSBDIyBjb2RlIGF0IGh0dHA6Ly93b3JtczJkLmluZm8vUGFsZXR0ZV9maWxlXHJcblxyXG5CaW5hcnlSZWFkZXIgPSByZXF1aXJlIFwiLi4vQmluYXJ5UmVhZGVyXCJcclxuUGFsZXR0ZSA9IHJlcXVpcmUgXCIuLi9QYWxldHRlXCJcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKHtkYXRhfSktPlxyXG5cdGJyID0gbmV3IEJpbmFyeVJlYWRlcihkYXRhKVxyXG5cdFxyXG5cdCMgUklGRiBoZWFkZXJcclxuXHRyaWZmID0gYnIucmVhZFN0cmluZyg0KSAjIFwiUklGRlwiXHJcblx0ZGF0YVNpemUgPSBici5yZWFkVUludDMyKClcclxuXHR0eXBlID0gYnIucmVhZFN0cmluZyg0KSAjIFwiUEFMIFwiXHJcblx0XHJcblx0aWYgcmlmZiBpc250IFwiUklGRlwiXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IgXCJSSUZGIGhlYWRlciBub3QgZm91bmQ7IG5vdCBhIFJJRkYgUEFMIGZpbGVcIlxyXG5cdFxyXG5cdGlmIHR5cGUgaXNudCBcIlBBTCBcIlxyXG5cdFx0dGhyb3cgbmV3IEVycm9yIFwiXCJcIlxyXG5cdFx0XHRSSUZGIGhlYWRlciBzYXlzIHRoaXMgaXNuJ3QgYSBQQUwgZmlsZSxcclxuXHRcdFx0bW9yZSBvZiBhIHNvcnQgb2YgI3soKHR5cGUrXCJcIikudHJpbSgpKX0gZmlsZVxyXG5cdFx0XCJcIlwiXHJcblx0XHJcblx0IyBEYXRhIGNodW5rXHJcblx0Y2h1bmtUeXBlID0gYnIucmVhZFN0cmluZyg0KSAjIFwiZGF0YVwiXHJcblx0Y2h1bmtTaXplID0gYnIucmVhZFVJbnQzMigpXHJcblx0cGFsVmVyc2lvbiA9IGJyLnJlYWRVSW50MTYoKSAjIDB4MDMwMFxyXG5cdHBhbE51bUVudHJpZXMgPSBici5yZWFkVUludDE2KClcclxuXHRcclxuXHRcclxuXHRpZiBjaHVua1R5cGUgaXNudCBcImRhdGFcIlxyXG5cdFx0dGhyb3cgbmV3IEVycm9yIFwiRGF0YSBjaHVuayBub3QgZm91bmQgKC4uLicje2NodW5rVHlwZX0nPylcIlxyXG5cdFxyXG5cdGlmIHBhbFZlcnNpb24gaXNudCAweDAzMDBcclxuXHRcdHRocm93IG5ldyBFcnJvciBcIlVuc3VwcG9ydGVkIFBBTCBmaWxlIHZlcnNpb246IDB4I3twYWxWZXJzaW9uLnRvU3RyaW5nKDE2KX1cIlxyXG5cdFxyXG5cdCMgQ29sb3JzXHJcblx0XHJcblx0cGFsZXR0ZSA9IG5ldyBQYWxldHRlKClcclxuXHRpID0gMFxyXG5cdHdoaWxlIChpICs9IDEpIDwgcGFsTnVtRW50cmllcyAtIDFcclxuXHRcdFxyXG5cdFx0cGFsZXR0ZS5hZGRcclxuXHRcdFx0cjogYnIucmVhZEJ5dGUoKVxyXG5cdFx0XHRnOiBici5yZWFkQnl0ZSgpXHJcblx0XHRcdGI6IGJyLnJlYWRCeXRlKClcclxuXHRcdFx0XzogYnIucmVhZEJ5dGUoKSAjIFwiZmxhZ3NcIiwgYWx3YXlzIDB4MDBcclxuXHRcclxuXHRwYWxldHRlXHJcbiIsIlxyXG4jIFBBTCAoU3RhckNyYWZ0IHJhdyBwYWxldHRlKVxyXG5cclxuQmluYXJ5UmVhZGVyID0gcmVxdWlyZSBcIi4uL0JpbmFyeVJlYWRlclwiXHJcblBhbGV0dGUgPSByZXF1aXJlIFwiLi4vUGFsZXR0ZVwiXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9ICh7ZGF0YX0pLT5cclxuXHRcclxuXHRwYWxldHRlID0gbmV3IFBhbGV0dGUoKVxyXG5cdGJyID0gbmV3IEJpbmFyeVJlYWRlcihkYXRhKVxyXG5cdFxyXG5cdGZvciBpIGluIFswLi4uMjU1XVxyXG5cdFx0cGFsZXR0ZS5hZGRcclxuXHRcdFx0cjogYnIucmVhZEJ5dGUoKVxyXG5cdFx0XHRnOiBici5yZWFkQnl0ZSgpXHJcblx0XHRcdGI6IGJyLnJlYWRCeXRlKClcclxuXHRcdFx0Izogbm8gcGFkZGluZ1xyXG5cdFxyXG5cdCM/IHBhbGV0dGUubl9jb2x1bW5zID0gMTZcclxuXHRwYWxldHRlXHJcbiIsIlxyXG4jIFdQRSAoU3RhckNyYWZ0IHBhZGRlZCByYXcgcGFsZXR0ZSlcclxuXHJcbkJpbmFyeVJlYWRlciA9IHJlcXVpcmUgXCIuLi9CaW5hcnlSZWFkZXJcIlxyXG5QYWxldHRlID0gcmVxdWlyZSBcIi4uL1BhbGV0dGVcIlxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoe2RhdGF9KS0+XHJcblx0XHJcblx0cGFsZXR0ZSA9IG5ldyBQYWxldHRlKClcclxuXHRiciA9IG5ldyBCaW5hcnlSZWFkZXIoZGF0YSlcclxuXHRcclxuXHRmb3IgaSBpbiBbMC4uLjI1NV1cclxuXHRcdHBhbGV0dGUuYWRkXHJcblx0XHRcdHI6IGJyLnJlYWRCeXRlKClcclxuXHRcdFx0ZzogYnIucmVhZEJ5dGUoKVxyXG5cdFx0XHRiOiBici5yZWFkQnl0ZSgpXHJcblx0XHRcdF86IGJyLnJlYWRCeXRlKCkgIyBwYWRkaW5nXHJcblx0XHJcblx0cGFsZXR0ZS5uX2NvbHVtbnMgPSAxNlxyXG5cdHBhbGV0dGVcclxuIl19
  </script>
  <script>
    /* FileSaver.js
     * A saveAs() FileSaver implementation.
     * 2015-05-07.2
     *
     * By Eli Grey, http://eligrey.com
     * License: X11/MIT
     *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
     */

    /*global self */
    /*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

    /*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

    var saveAs = saveAs || (function(view) {
      "use strict";
      // IE <10 is explicitly unsupported
      if (typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
        return;
      }
      var
        doc = view.document
        // only get URL when necessary in case Blob.js hasn't overridden it yet
        ,
        get_URL = function() {
          return view.URL || view.webkitURL || view;
        },
        save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a"),
        can_use_save_link = "download" in save_link,
        click = function(node) {
          var event = doc.createEvent("MouseEvents");
          event.initMouseEvent(
            "click", true, false, view, 0, 0, 0, 0, 0, false, false, false, false, 0, null
          );
          node.dispatchEvent(event);
        },
        webkit_req_fs = view.webkitRequestFileSystem,
        req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem,
        throw_outside = function(ex) {
          (view.setImmediate || view.setTimeout)(function() {
            throw ex;
          }, 0);
        },
        force_saveable_type = "application/octet-stream",
        fs_min_size = 0
        // See https://code.google.com/p/chromium/issues/detail?id=375297#c7 and
        // https://github.com/eligrey/FileSaver.js/commit/485930a#commitcomment-8768047
        // for the reasoning behind the timeout and revocation flow
        ,
        arbitrary_revoke_timeout = 500 // in ms
        ,
        revoke = function(file) {
          var revoker = function() {
            if (typeof file === "string") { // file is an object URL
              get_URL().revokeObjectURL(file);
            } else { // file is a File
              file.remove();
            }
          };
          if (view.chrome) {
            revoker();
          } else {
            setTimeout(revoker, arbitrary_revoke_timeout);
          }
        },
        dispatch = function(filesaver, event_types, event) {
          event_types = [].concat(event_types);
          var i = event_types.length;
          while (i--) {
            var listener = filesaver["on" + event_types[i]];
            if (typeof listener === "function") {
              try {
                listener.call(filesaver, event || filesaver);
              } catch (ex) {
                throw_outside(ex);
              }
            }
          }
        },
        auto_bom = function(blob) {
          // prepend BOM for UTF-8 XML and text/* types (including HTML)
          if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
            return new Blob(["\ufeff", blob], {
              type: blob.type
            });
          }
          return blob;
        },
        FileSaver = function(blob, name) {
          blob = auto_bom(blob);
          // First try a.download, then web filesystem, then object URLs
          var
            filesaver = this,
            type = blob.type,
            blob_changed = false,
            object_url, target_view, dispatch_all = function() {
              dispatch(filesaver, "writestart progress write writeend".split(" "));
            }
            // on any filesys errors revert to saving with object URLs
            ,
            fs_error = function() {
              // don't create more object URLs than needed
              if (blob_changed || !object_url) {
                object_url = get_URL().createObjectURL(blob);
              }
              if (target_view) {
                target_view.location.href = object_url;
              } else {
                var new_tab = view.open(object_url, "_blank");
                if (new_tab == undefined && typeof safari !== "undefined") {
                  //Apple do not allow window.open, see http://bit.ly/1kZffRI
                  view.location.href = object_url
                }
              }
              filesaver.readyState = filesaver.DONE;
              dispatch_all();
              revoke(object_url);
            },
            abortable = function(func) {
              return function() {
                if (filesaver.readyState !== filesaver.DONE) {
                  return func.apply(this, arguments);
                }
              };
            },
            create_if_not_found = {
              create: true,
              exclusive: false
            },
            slice;
          filesaver.readyState = filesaver.INIT;
          if (!name) {
            name = "download";
          }
          if (can_use_save_link) {
            object_url = get_URL().createObjectURL(blob);
            save_link.href = object_url;
            save_link.download = name;
            click(save_link);
            filesaver.readyState = filesaver.DONE;
            dispatch_all();
            revoke(object_url);
            return;
          }
          // Object and web filesystem URLs have a problem saving in Google Chrome when
          // viewed in a tab, so I force save with application/octet-stream
          // http://code.google.com/p/chromium/issues/detail?id=91158
          // Update: Google errantly closed 91158, I submitted it again:
          // https://code.google.com/p/chromium/issues/detail?id=389642
          if (view.chrome && type && type !== force_saveable_type) {
            slice = blob.slice || blob.webkitSlice;
            blob = slice.call(blob, 0, blob.size, force_saveable_type);
            blob_changed = true;
          }
          // Since I can't be sure that the guessed media type will trigger a download
          // in WebKit, I append .download to the filename.
          // https://bugs.webkit.org/show_bug.cgi?id=65440
          if (webkit_req_fs && name !== "download") {
            name += ".download";
          }
          if (type === force_saveable_type || webkit_req_fs) {
            target_view = view;
          }
          if (!req_fs) {
            fs_error();
            return;
          }
          fs_min_size += blob.size;
          req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
            fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
              var save = function() {
                dir.getFile(name, create_if_not_found, abortable(function(file) {
                  file.createWriter(abortable(function(writer) {
                    writer.onwriteend = function(event) {
                      target_view.location.href = file.toURL();
                      filesaver.readyState = filesaver.DONE;
                      dispatch(filesaver, "writeend", event);
                      revoke(file);
                    };
                    writer.onerror = function() {
                      var error = writer.error;
                      if (error.code !== error.ABORT_ERR) {
                        fs_error();
                      }
                    };
                    "writestart progress write abort".split(" ").forEach(function(event) {
                      writer["on" + event] = filesaver["on" + event];
                    });
                    writer.write(blob);
                    filesaver.abort = function() {
                      writer.abort();
                      filesaver.readyState = filesaver.DONE;
                    };
                    filesaver.readyState = filesaver.WRITING;
                  }), fs_error);
                }), fs_error);
              };
              dir.getFile(name, {
                create: false
              }, abortable(function(file) {
                // delete file if it already exists
                file.remove();
                save();
              }), abortable(function(ex) {
                if (ex.code === ex.NOT_FOUND_ERR) {
                  save();
                } else {
                  fs_error();
                }
              }));
            }), fs_error);
          }), fs_error);
        },
        FS_proto = FileSaver.prototype,
        saveAs = function(blob, name) {
          return new FileSaver(blob, name);
        };
      // IE 10+ (native saveAs)
      if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
        return function(blob, name) {
          return navigator.msSaveOrOpenBlob(auto_bom(blob), name);
        };
      }

      FS_proto.abort = function() {
        var filesaver = this;
        filesaver.readyState = filesaver.DONE;
        dispatch(filesaver, "abort");
      };
      FS_proto.readyState = FS_proto.INIT = 0;
      FS_proto.WRITING = 1;
      FS_proto.DONE = 2;

      FS_proto.error =
        FS_proto.onwritestart =
        FS_proto.onprogress =
        FS_proto.onwrite =
        FS_proto.onabort =
        FS_proto.onerror =
        FS_proto.onwriteend =
        null;

      return saveAs;
    }(
      typeof self !== "undefined" && self ||
      typeof window !== "undefined" && window ||
      this.content
    ));
    // `self` is undefined in Firefox for Android content script context
    // while `this` is nsIContentFrameMessageManager
    // with an attribute `content` that corresponds to the window

    if (typeof module !== "undefined" && module.exports) {
      module.exports.saveAs = saveAs;
    } else if ((typeof define !== "undefined" && define !== null) && (define.amd != null)) {
      define([], function() {
        return saveAs;
      });
    }
  </script>
  <script>
    (function e(t, n, r) {
      function s(o, u) {
        if (!n[o]) {
          if (!t[o]) {
            var a = typeof require == "function" && require;
            if (!u && a) return a(o, !0);
            if (i) return i(o, !0);
            var f = new Error("Cannot find module '" + o + "'");
            throw f.code = "MODULE_NOT_FOUND", f
          }
          var l = n[o] = {
            exports: {}
          };
          t[o][0].call(l.exports, function(e) {
            var n = t[o][1][e];
            return s(n ? n : e)
          }, l, l.exports, e, t, n, r)
        }
        return n[o].exports
      }
      var i = typeof require == "function" && require;
      for (var o = 0; o < r.length; o++) s(r[o]);
      return s
    })({
      1: [function(require, module, exports) {
        var after, domReady, every;

        after = function(ms, fn) {
          var tid;
          tid = setTimeout(fn, ms);
          return {
            stop: function() {
              return clearTimeout(tid);
            }
          };
        };

        every = function(ms, fn) {
          var iid;
          iid = setInterval(fn, ms);
          return {
            stop: function() {
              return clearInterval(iid);
            }
          };
        };

        domReady = function(callback) {
          if (/in/.test(document.readyState)) {
            return after(10, function() {
              return domReady(callback);
            });
          } else {
            return callback();
          }
        };

        (function(exports) {
          var FD, Font, container, doneTestingFonts, fontAvailabilityChecker, genericFontFamilies, loadFonts, someCommonFontNames, startedLoading, testFonts, testedFonts;
          FD = exports.FontDetective = {};
          genericFontFamilies = ["serif", "sans-serif", "cursive", "fantasy", "monospace"];
          someCommonFontNames = "Helvetica,Lucida Grande,Lucida Sans,Tahoma,Arial,Geneva,Monaco,Verdana,Microsoft Sans Serif,Trebuchet MS,Courier New,Times New Roman,Courier,Lucida Bright,Lucida Sans Typewriter,URW Chancery L,Comic Sans MS,Georgia,Palatino Linotype,Lucida Sans Unicode,Times,Century Schoolbook L,URW Gothic L,Franklin Gothic Medium,Lucida Console,Impact,URW Bookman L,Helvetica Neue,Nimbus Sans L,URW Palladio L,Nimbus Mono L,Nimbus Roman No9 L,Arial Black,Sylfaen,MV Boli,Estrangelo Edessa,Tunga,Gautami,Raavi,Mangal,Shruti,Latha,Kartika,Vrinda,Arial Narrow,Century Gothic,Garamond,Book Antiqua,Bookman Old Style,Calibri,Cambria,Candara,Corbel,Monotype Corsiva,Cambria Math,Consolas,Constantia,MS Reference Sans Serif,MS Mincho,Segoe UI,Arial Unicode MS,Tempus Sans ITC,Kristen ITC,Mistral,Meiryo UI,Juice ITC,Papyrus,Bradley Hand ITC,French Script MT,Malgun Gothic,Microsoft YaHei,Gisha,Leelawadee,Microsoft JhengHei,Haettenschweiler,Microsoft Himalaya,Microsoft Uighur,MoolBoran,Jokerman,DFKai-SB,KaiTi,SimSun-ExtB,Freestyle Script,Vivaldi,FangSong,MingLiU-ExtB,MingLiU_HKSCS,MingLiU_HKSCS-ExtB,PMingLiU-ExtB,Copperplate Gothic Light,Copperplate Gothic Bold,Franklin Gothic Book,Maiandra GD,Perpetua,Eras Demi ITC,Felix Titling,Franklin Gothic Demi,Pristina,Edwardian Script ITC,OCR A Extended,Engravers MT,Eras Light ITC,Franklin Gothic Medium Cond,Rockwell Extra Bold,Rockwell,Curlz MT,Blackadder ITC,Franklin Gothic Heavy,Franklin Gothic Demi Cond,Lucida Handwriting,Segoe UI Light,Segoe UI Semibold,Lucida Calligraphy,Cooper Black,Viner Hand ITC,Britannic Bold,Wide Latin,Old English Text MT,Broadway,Footlight MT Light,Harrington,Snap ITC,Onyx,Playbill,Bauhaus 93,Baskerville Old Face,Algerian,Matura MT Script Capitals,Stencil,Batang,Chiller,Harlow Solid Italic,Kunstler Script,Bernard MT Condensed,Informal Roman,Vladimir Script,Bell MT,Colonna MT,High Tower Text,Californian FB,Ravie,Segoe Script,Brush Script MT,SimSun,Arial Rounded MT Bold,Berlin Sans FB,Centaur,Niagara Solid,Showcard Gothic,Niagara Engraved,Segoe Print,Gabriola,Gill Sans MT,Iskoola Pota,Calisto MT,Script MT Bold,Century Schoolbook,Berlin Sans FB Demi,Magneto,Arabic Typesetting,DaunPenh,Mongolian Baiti,DokChampa,Euphemia,Kalinga,Microsoft Yi Baiti,Nyala,Bodoni MT Poster Compressed,Goudy Old Style,Imprint MT Shadow,Gill Sans MT Condensed,Gill Sans Ultra Bold,Palace Script MT,Lucida Fax,Gill Sans MT Ext Condensed Bold,Goudy Stout,Eras Medium ITC,Rage Italic,Rockwell Condensed,Castellar,Eras Bold ITC,Forte,Gill Sans Ultra Bold Condensed,Perpetua Titling MT,Agency FB,Tw Cen MT,Gigi,Tw Cen MT Condensed,Aparajita,Gloucester MT Extra Condensed,Tw Cen MT Condensed Extra Bold,PMingLiU,Bodoni MT,Bodoni MT Black,Bodoni MT Condensed,MS Gothic,GulimChe,MS UI Gothic,MS PGothic,Gulim,MS PMincho,BatangChe,Dotum,DotumChe,Gungsuh,GungsuhChe,MingLiU,NSimSun,SimHei,DejaVu Sans,DejaVu Sans Condensed,DejaVu Sans Mono,DejaVu Serif,DejaVu Serif Condensed,Eurostile,Matisse ITC,Bitstream Vera Sans Mono,Bitstream Vera Sans,Staccato222 BT,Bitstream Vera Serif,Broadway BT,ParkAvenue BT,Square721 BT,Calligraph421 BT,MisterEarl BT,Cataneo BT,Ruach LET,Rage Italic LET,La Bamba LET,Blackletter686 BT,John Handy LET,Scruff LET,Westwood LET".split(",").sort();
          testedFonts = [];
          doneTestingFonts = false;
          startedLoading = false;
          container = document.createElement("div");
          container.id = "font-detective";

          /*
           * A font class that can be stringified for use in css
           * e.g. font.toString() or (font + ", sans-serif")
           */
          Font = (function() {
            function Font(name, type, style) {
              this.name = name;
              this.type = type;
              this.style = style;
            }

            Font.prototype.toString = function() {
              return '"' + this.name.replace(/\\/g, "\\\\").replace(/"/g, "\\\"") + '"';
            };

            return Font;

          })();
          fontAvailabilityChecker = (function() {
            var baseFontFamilies, baseHeights, baseWidths, span;
            baseFontFamilies = ["monospace", "sans-serif", "serif"];
            span = document.createElement("span");
            span.innerHTML = "mmmmmmmmmmlli";
            span.style.fontSize = "72px";
            baseWidths = {};
            baseHeights = {};
            return {
              init: function() {
                var baseFontFamily, j, len, results;
                document.body.appendChild(container);
                results = [];
                for (j = 0, len = baseFontFamilies.length; j < len; j++) {
                  baseFontFamily = baseFontFamilies[j];
                  span.style.fontFamily = baseFontFamily;
                  container.appendChild(span);
                  baseWidths[baseFontFamily] = span.offsetWidth;
                  baseHeights[baseFontFamily] = span.offsetHeight;
                  results.push(container.removeChild(span));
                }
                return results;
              },
              check: function(font) {
                var baseFontFamily, differs, j, len;
                for (j = 0, len = baseFontFamilies.length; j < len; j++) {
                  baseFontFamily = baseFontFamilies[j];
                  span.style.fontFamily = font + ", " + baseFontFamily;
                  container.appendChild(span);
                  differs = span.offsetWidth !== baseWidths[baseFontFamily] || span.offsetHeight !== baseHeights[baseFontFamily];
                  container.removeChild(span);
                  if (differs) {
                    return true;
                  }
                }
                return false;
              }
            };
          })();
          loadFonts = function() {
            if (startedLoading) {
              return;
            }
            startedLoading = true;
            FD.incomplete = true;
            return domReady((function(_this) {
              return function() {
                var fontName;
                return testFonts((function() {
                  var j, len, results;
                  results = [];
                  for (j = 0, len = someCommonFontNames.length; j < len; j++) {
                    fontName = someCommonFontNames[j];
                    results.push(new Font(fontName));
                  }
                  return results;
                })());
              };
            })(this));
          };
          testFonts = function(fonts) {
            var i, testingFonts;
            fontAvailabilityChecker.init();
            i = 0;
            return testingFonts = every(20, function() {
              var available, callback, font, j, k, l, len, len1, ref, ref1;
              for (j = 0; j <= 5; j++) {
                font = fonts[i];
                available = fontAvailabilityChecker.check(font);
                if (available) {
                  testedFonts.push(font);
                  ref = FD.each.callbacks;
                  for (k = 0, len = ref.length; k < len; k++) {
                    callback = ref[k];
                    callback(font);
                  }
                }
                i++;
                if (i >= fonts.length) {
                  testingFonts.stop();
                  ref1 = FD.all.callbacks;
                  for (l = 0, len1 = ref1.length; l < len1; l++) {
                    callback = ref1[l];
                    callback(testedFonts);
                  }
                  FD.all.callbacks = [];
                  FD.each.callbacks = [];
                  doneTestingFonts = true;
                  return;
                }
              }
            });
          };

          /*
           * FontDetective.preload()
           * Starts detecting fonts early
           */
          FD.preload = loadFonts;

          /*
           * FontDetective.each(function(font){})
           * Calls back with a `Font` every time a font is detected and tested
           */
          FD.each = function(callback) {
            var font, j, len;
            for (j = 0, len = testedFonts.length; j < len; j++) {
              font = testedFonts[j];
              callback(font);
            }
            if (!doneTestingFonts) {
              FD.each.callbacks.push(callback);
              return loadFonts();
            }
          };
          FD.each.callbacks = [];

          /*
           * FontDetective.all(function(fonts){})
           * Calls back with an `Array` of `Font`s when all fonts are detected and tested
           */
          FD.all = function(callback) {
            if (doneTestingFonts) {
              return callback(testedFonts);
            } else {
              FD.all.callbacks.push(callback);
              return loadFonts();
            }
          };
          return FD.all.callbacks = [];
        })(window);


      }, {}]
    }, {}, [1]);
  </script>
  <script>
    /*

 Copyright 2000, Silicon Graphics, Inc. All Rights Reserved.
 Copyright 2015, Google Inc. All Rights Reserved.

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to
 deal in the Software without restriction, including without limitation the
 rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 sell copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice including the dates of first publication and
 either this permission notice or a reference to http://oss.sgi.com/projects/FreeB/
 shall be included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 Original Code. The Original Code is: OpenGL Sample Implementation,
 Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
 Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
 Copyright in any portions created by third parties is as indicated
 elsewhere herein. All Rights Reserved.
*/

    // wrapper added because of https://github.com/brendankenny/libtess.js/issues/15
    var libtess = (function() {

      'use strict';
      var n;

      function t(a, b) {
        return a.b === b.b && a.a === b.a
      }

      function u(a, b) {
        return a.b < b.b || a.b === b.b && a.a <= b.a
      }

      function v(a, b, c) {
        var d = b.b - a.b,
          e = c.b - b.b;
        return 0 < d + e ? d < e ? b.a - a.a + d / (d + e) * (a.a - c.a) : b.a - c.a + e / (d + e) * (c.a - a.a) : 0
      }

      function x(a, b, c) {
        var d = b.b - a.b,
          e = c.b - b.b;
        return 0 < d + e ? (b.a - c.a) * d + (b.a - a.a) * e : 0
      }

      function z(a, b) {
        return a.a < b.a || a.a === b.a && a.b <= b.b
      }

      function aa(a, b, c) {
        var d = b.a - a.a,
          e = c.a - b.a;
        return 0 < d + e ? d < e ? b.b - a.b + d / (d + e) * (a.b - c.b) : b.b - c.b + e / (d + e) * (c.b - a.b) : 0
      }

      function ba(a, b, c) {
        var d = b.a - a.a,
          e = c.a - b.a;
        return 0 < d + e ? (b.b - c.b) * d + (b.b - a.b) * e : 0
      }

      function ca(a) {
        return u(a.b.a, a.a)
      }

      function da(a) {
        return u(a.a, a.b.a)
      }

      function A(a, b, c, d) {
        a = 0 > a ? 0 : a;
        c = 0 > c ? 0 : c;
        return a <= c ? 0 === c ? (b + d) / 2 : b + a / (a + c) * (d - b) : d + c / (a + c) * (b - d)
      };

      function ea(a) {
        var b = B(a.b);
        C(b, a.c);
        C(b.b, a.c);
        D(b, a.a);
        return b
      }

      function E(a, b) {
        var c = !1,
          d = !1;
        a !== b && (b.a !== a.a && (d = !0, F(b.a, a.a)), b.d !== a.d && (c = !0, G(b.d, a.d)), H(b, a), d || (C(b, a.a), a.a.c = a), c || (D(b, a.d), a.d.a = a))
      }

      function I(a) {
        var b = a.b,
          c = !1;
        a.d !== a.b.d && (c = !0, G(a.d, a.b.d));
        a.c === a ? F(a.a, null) : (a.b.d.a = J(a), a.a.c = a.c, H(a, J(a)), c || D(a, a.d));
        b.c === b ? (F(b.a, null), G(b.d, null)) : (a.d.a = J(b), b.a.c = b.c, H(b, J(b)));
        fa(a)
      }

      function K(a) {
        var b = B(a),
          c = b.b;
        H(b, a.e);
        b.a = a.b.a;
        C(c, b.a);
        b.d = c.d = a.d;
        b = b.b;
        H(a.b, J(a.b));
        H(a.b, b);
        a.b.a = b.a;
        b.b.a.c = b.b;
        b.b.d = a.b.d;
        b.f = a.f;
        b.b.f = a.b.f;
        return b
      }

      function L(a, b) {
        var c = !1,
          d = B(a),
          e = d.b;
        b.d !== a.d && (c = !0, G(b.d, a.d));
        H(d, a.e);
        H(e, b);
        d.a = a.b.a;
        e.a = b.a;
        d.d = e.d = a.d;
        a.d.a = e;
        c || D(d, a.d);
        return d
      }

      function B(a) {
        var b = new M,
          c = new M,
          d = a.b.h;
        c.h = d;
        d.b.h = b;
        b.h = a;
        a.b.h = c;
        b.b = c;
        b.c = b;
        b.e = c;
        c.b = b;
        c.c = c;
        return c.e = b
      }

      function H(a, b) {
        var c = a.c,
          d = b.c;
        c.b.e = b;
        d.b.e = a;
        a.c = d;
        b.c = c
      }

      function C(a, b) {
        var c = b.f,
          d = new N(b, c);
        c.e = d;
        b.f = d;
        c = d.c = a;
        do c.a = d, c = c.c; while (c !== a)
      }

      function D(a, b) {
        var c = b.d,
          d = new ga(b, c);
        c.b = d;
        b.d = d;
        d.a = a;
        d.c = b.c;
        c = a;
        do c.d = d, c = c.e; while (c !== a)
      }

      function fa(a) {
        var b = a.h;
        a = a.b.h;
        b.b.h = a;
        a.b.h = b
      }

      function F(a, b) {
        var c = a.c,
          d = c;
        do d.a = b, d = d.c; while (d !== c);
        c = a.f;
        d = a.e;
        d.f = c;
        c.e = d
      }

      function G(a, b) {
        var c = a.a,
          d = c;
        do d.d = b, d = d.e; while (d !== c);
        c = a.d;
        d = a.b;
        d.d = c;
        c.b = d
      };

      function ha(a) {
        var b = 0;
        Math.abs(a[1]) > Math.abs(a[0]) && (b = 1);
        Math.abs(a[2]) > Math.abs(a[b]) && (b = 2);
        return b
      };
      var O = 4 * 1E150;

      function P(a, b) {
        a.f += b.f;
        a.b.f += b.b.f
      }

      function ia(a, b, c) {
        a = a.a;
        b = b.a;
        c = c.a;
        if (b.b.a === a) return c.b.a === a ? u(b.a, c.a) ? 0 >= x(c.b.a, b.a, c.a) : 0 <= x(b.b.a, c.a, b.a) : 0 >= x(c.b.a, a, c.a);
        if (c.b.a === a) return 0 <= x(b.b.a, a, b.a);
        b = v(b.b.a, a, b.a);
        a = v(c.b.a, a, c.a);
        return b >= a
      }

      function Q(a) {
        a.a.i = null;
        var b = a.e;
        b.a.c = b.c;
        b.c.a = b.a;
        a.e = null
      }

      function ja(a, b) {
        I(a.a);
        a.c = !1;
        a.a = b;
        b.i = a
      }

      function ka(a) {
        var b = a.a.a;
        do a = R(a); while (a.a.a === b);
        a.c && (b = L(S(a).a.b, a.a.e), ja(a, b), a = R(a));
        return a
      }

      function la(a, b, c) {
        var d = new ma;
        d.a = c;
        d.e = na(a.f, b.e, d);
        return c.i = d
      }

      function oa(a, b) {
        switch (a.s) {
          case 100130:
            return 0 !== (b & 1);
          case 100131:
            return 0 !== b;
          case 100132:
            return 0 < b;
          case 100133:
            return 0 > b;
          case 100134:
            return 2 <= b || -2 >= b
        }
        return !1
      }

      function pa(a) {
        var b = a.a,
          c = b.d;
        c.c = a.d;
        c.a = b;
        Q(a)
      }

      function T(a, b, c) {
        a = b;
        for (b = b.a; a !== c;) {
          a.c = !1;
          var d = S(a),
            e = d.a;
          if (e.a !== b.a) {
            if (!d.c) {
              pa(a);
              break
            }
            e = L(b.c.b, e.b);
            ja(d, e)
          }
          b.c !== e && (E(J(e), e), E(b, e));
          pa(a);
          b = d.a;
          a = d
        }
        return b
      }

      function U(a, b, c, d, e, f) {
        var g = !0;
        do la(a, b, c.b), c = c.c; while (c !== d);
        for (null === e && (e = S(b).a.b.c);;) {
          d = S(b);
          c = d.a.b;
          if (c.a !== e.a) break;
          c.c !== e && (E(J(c), c), E(J(e), c));
          d.f = b.f - c.f;
          d.d = oa(a, d.f);
          b.b = !0;
          !g && qa(a, b) && (P(c, e), Q(b), I(e));
          g = !1;
          b = d;
          e = c
        }
        b.b = !0;
        f && ra(a, b)
      }

      function sa(a, b, c, d, e) {
        var f = [b.g[0], b.g[1], b.g[2]];
        b.d = null;
        b.d = a.o ? a.o(f, c, d, a.c) || null : null;
        null === b.d && (e ? a.n || (V(a, 100156), a.n = !0) : b.d = c[0])
      }

      function ta(a, b, c) {
        var d = [null, null, null, null];
        d[0] = b.a.d;
        d[1] = c.a.d;
        sa(a, b.a, d, [.5, .5, 0, 0], !1);
        E(b, c)
      }

      function ua(a, b, c, d, e) {
        var f = Math.abs(b.b - a.b) + Math.abs(b.a - a.a),
          g = Math.abs(c.b - a.b) + Math.abs(c.a - a.a),
          h = e + 1;
        d[e] = .5 * g / (f + g);
        d[h] = .5 * f / (f + g);
        a.g[0] += d[e] * b.g[0] + d[h] * c.g[0];
        a.g[1] += d[e] * b.g[1] + d[h] * c.g[1];
        a.g[2] += d[e] * b.g[2] + d[h] * c.g[2]
      }

      function qa(a, b) {
        var c = S(b),
          d = b.a,
          e = c.a;
        if (u(d.a, e.a)) {
          if (0 < x(e.b.a, d.a, e.a)) return !1;
          if (!t(d.a, e.a)) K(e.b), E(d, J(e)), b.b = c.b = !0;
          else if (d.a !== e.a) {
            var c = a.e,
              f = d.a.h;
            if (0 <= f) {
              var c = c.b,
                g = c.d,
                h = c.e,
                k = c.c,
                l = k[f];
              g[l] = g[c.a];
              k[g[l]] = l;
              l <= --c.a && (1 >= l ? W(c, l) : u(h[g[l >> 1]], h[g[l]]) ? W(c, l) : va(c, l));
              h[f] = null;
              k[f] = c.b;
              c.b = f
            } else
              for (c.c[-(f + 1)] = null; 0 < c.a && null === c.c[c.d[c.a - 1]];) --c.a;
            ta(a, J(e), d)
          }
        } else {
          if (0 > x(d.b.a, e.a, d.a)) return !1;
          R(b).b = b.b = !0;
          K(d.b);
          E(J(e), d)
        }
        return !0
      }

      function wa(a, b) {
        var c = S(b),
          d = b.a,
          e = c.a,
          f = d.a,
          g = e.a,
          h = d.b.a,
          k = e.b.a,
          l = new N;
        x(h, a.a, f);
        x(k, a.a, g);
        if (f === g || Math.min(f.a, h.a) > Math.max(g.a, k.a)) return !1;
        if (u(f, g)) {
          if (0 < x(k, f, g)) return !1
        } else if (0 > x(h, g, f)) return !1;
        var r = h,
          p = f,
          q = k,
          y = g,
          m, w;
        u(r, p) || (m = r, r = p, p = m);
        u(q, y) || (m = q, q = y, y = m);
        u(r, q) || (m = r, r = q, q = m, m = p, p = y, y = m);
        u(q, p) ? u(p, y) ? (m = v(r, q, p), w = v(q, p, y), 0 > m + w && (m = -m, w = -w), l.b = A(m, q.b, w, p.b)) : (m = x(r, q, p), w = -x(r, y, p), 0 > m + w && (m = -m, w = -w), l.b = A(m, q.b, w, y.b)) : l.b = (q.b + p.b) / 2;
        z(r, p) || (m = r, r = p, p = m);
        z(q, y) ||
          (m = q, q = y, y = m);
        z(r, q) || (m = r, r = q, q = m, m = p, p = y, y = m);
        z(q, p) ? z(p, y) ? (m = aa(r, q, p), w = aa(q, p, y), 0 > m + w && (m = -m, w = -w), l.a = A(m, q.a, w, p.a)) : (m = ba(r, q, p), w = -ba(r, y, p), 0 > m + w && (m = -m, w = -w), l.a = A(m, q.a, w, y.a)) : l.a = (q.a + p.a) / 2;
        u(l, a.a) && (l.b = a.a.b, l.a = a.a.a);
        r = u(f, g) ? f : g;
        u(r, l) && (l.b = r.b, l.a = r.a);
        if (t(l, f) || t(l, g)) return qa(a, b), !1;
        if (!t(h, a.a) && 0 <= x(h, a.a, l) || !t(k, a.a) && 0 >= x(k, a.a, l)) {
          if (k === a.a) return K(d.b), E(e.b, d), b = ka(b), d = S(b).a, T(a, S(b), c), U(a, b, J(d), d, d, !0), !0;
          if (h === a.a) {
            K(e.b);
            E(d.e, J(e));
            f = c = b;
            g = f.a.b.a;
            do f = R(f); while (f.a.b.a === g);
            b = f;
            f = S(b).a.b.c;
            c.a = J(e);
            e = T(a, c, null);
            U(a, b, e.c, d.b.c, f, !0);
            return !0
          }
          0 <= x(h, a.a, l) && (R(b).b = b.b = !0, K(d.b), d.a.b = a.a.b, d.a.a = a.a.a);
          0 >= x(k, a.a, l) && (b.b = c.b = !0, K(e.b), e.a.b = a.a.b, e.a.a = a.a.a);
          return !1
        }
        K(d.b);
        K(e.b);
        E(J(e), d);
        d.a.b = l.b;
        d.a.a = l.a;
        d.a.h = xa(a.e, d.a);
        d = d.a;
        e = [0, 0, 0, 0];
        l = [f.d, h.d, g.d, k.d];
        d.g[0] = d.g[1] = d.g[2] = 0;
        ua(d, f, h, e, 0);
        ua(d, g, k, e, 2);
        sa(a, d, l, e, !0);
        R(b).b = b.b = c.b = !0;
        return !1
      }

      function ra(a, b) {
        for (var c = S(b);;) {
          for (; c.b;) b = c, c = S(c);
          if (!b.b && (c = b, b = R(b), null === b || !b.b)) break;
          b.b = !1;
          var d = b.a,
            e = c.a,
            f;
          if (f = d.b.a !== e.b.a) a: {
            f = b;
            var g = S(f),
              h = f.a,
              k = g.a,
              l = void 0;
            if (u(h.b.a, k.b.a)) {
              if (0 > x(h.b.a, k.b.a, h.a)) {
                f = !1;
                break a
              }
              R(f).b = f.b = !0;
              l = K(h);
              E(k.b, l);
              l.d.c = f.d
            } else {
              if (0 < x(k.b.a, h.b.a, k.a)) {
                f = !1;
                break a
              }
              f.b = g.b = !0;
              l = K(k);
              E(h.e, k.b);
              l.b.d.c = f.d
            }
            f = !0
          }
          f && (c.c ? (Q(c), I(e), c = S(b), e = c.a) : b.c && (Q(b), I(d), b = R(c), d = b.a));
          if (d.a !== e.a)
            if (d.b.a === e.b.a || b.c || c.c || d.b.a !== a.a && e.b.a !== a.a) qa(a,
              b);
            else if (wa(a, b)) break;
          d.a === e.a && d.b.a === e.b.a && (P(e, d), Q(b), I(d), b = R(c))
        }
      }

      function ya(a, b) {
        a.a = b;
        for (var c = b.c; null === c.i;)
          if (c = c.c, c === b.c) {
            var c = a,
              d = b,
              e = new ma;
            e.a = d.c.b;
            var f = c.f,
              g = f.a;
            do g = g.a; while (null !== g.b && !f.c(f.b, e, g.b));
            var f = g.b,
              h = S(f),
              e = f.a,
              g = h.a;
            if (0 === x(e.b.a, d, e.a)) e = f.a, t(e.a, d) || t(e.b.a, d) || (K(e.b), f.c && (I(e.c), f.c = !1), E(d.c, e), ya(c, d));
            else {
              var k = u(g.b.a, e.b.a) ? f : h,
                h = void 0;
              f.d || k.c ? (k === f ? h = L(d.c.b, e.e) : h = L(g.b.c.b, d.c).b, k.c ? ja(k, h) : (e = c, f = la(c, f, h), f.f = R(f).f + f.a.f, f.d = oa(e, f.f)), ya(c, d)) : U(c, f, d.c, d.c, null, !0)
            }
            return
          } c = ka(c.i);
        e = S(c);
        f = e.a;
        e = T(a,
          e, null);
        if (e.c === f) {
          var f = e,
            e = f.c,
            g = S(c),
            h = c.a,
            k = g.a,
            l = !1;
          h.b.a !== k.b.a && wa(a, c);
          t(h.a, a.a) && (E(J(e), h), c = ka(c), e = S(c).a, T(a, S(c), g), l = !0);
          t(k.a, a.a) && (E(f, J(k)), f = T(a, g, null), l = !0);
          l ? U(a, c, f.c, e, e, !0) : (u(k.a, h.a) ? d = J(k) : d = h, d = L(f.c.b, d), U(a, c, d, d.c, d.c, !1), d.b.i.c = !0, ra(a, c))
        } else U(a, c, e.c, f, f, !0)
      }

      function za(a, b) {
        var c = new ma,
          d = ea(a.b);
        d.a.b = O;
        d.a.a = b;
        d.b.a.b = -O;
        d.b.a.a = b;
        a.a = d.b.a;
        c.a = d;
        c.f = 0;
        c.d = !1;
        c.c = !1;
        c.h = !0;
        c.b = !1;
        d = a.f;
        d = na(d, d.a, c);
        c.e = d
      };

      function Aa(a) {
        this.a = new Ba;
        this.b = a;
        this.c = ia
      }

      function na(a, b, c) {
        do b = b.c; while (null !== b.b && !a.c(a.b, b.b, c));
        a = new Ba(c, b.a, b);
        b.a.c = a;
        return b.a = a
      };

      function Ba(a, b, c) {
        this.b = a || null;
        this.a = b || this;
        this.c = c || this
      };

      function X() {
        this.d = Y;
        this.p = this.b = this.q = null;
        this.j = [0, 0, 0];
        this.s = 100130;
        this.n = !1;
        this.o = this.a = this.e = this.f = null;
        this.m = !1;
        this.c = this.r = this.i = this.k = this.l = this.h = null
      }
      var Y = 0;
      n = X.prototype;
      n.x = function() {
        Z(this, Y)
      };
      n.B = function(a, b) {
        switch (a) {
          case 100142:
            return;
          case 100140:
            switch (b) {
              case 100130:
              case 100131:
              case 100132:
              case 100133:
              case 100134:
                this.s = b;
                return
            }
            break;
          case 100141:
            this.m = !!b;
            return;
          default:
            V(this, 100900);
            return
        }
        V(this, 100901)
      };
      n.y = function(a) {
        switch (a) {
          case 100142:
            return 0;
          case 100140:
            return this.s;
          case 100141:
            return this.m;
          default:
            V(this, 100900)
        }
        return !1
      };
      n.A = function(a, b, c) {
        this.j[0] = a;
        this.j[1] = b;
        this.j[2] = c
      };
      n.z = function(a, b) {
        var c = b ? b : null;
        switch (a) {
          case 100100:
          case 100106:
            this.h = c;
            break;
          case 100104:
          case 100110:
            this.l = c;
            break;
          case 100101:
          case 100107:
            this.k = c;
            break;
          case 100102:
          case 100108:
            this.i = c;
            break;
          case 100103:
          case 100109:
            this.p = c;
            break;
          case 100105:
          case 100111:
            this.o = c;
            break;
          case 100112:
            this.r = c;
            break;
          default:
            V(this, 100900)
        }
      };
      n.C = function(a, b) {
        var c = !1,
          d = [0, 0, 0];
        Z(this, 2);
        for (var e = 0; 3 > e; ++e) {
          var f = a[e]; - 1E150 > f && (f = -1E150, c = !0);
          1E150 < f && (f = 1E150, c = !0);
          d[e] = f
        }
        c && V(this, 100155);
        c = this.q;
        null === c ? (c = ea(this.b), E(c, c.b)) : (K(c), c = c.e);
        c.a.d = b;
        c.a.g[0] = d[0];
        c.a.g[1] = d[1];
        c.a.g[2] = d[2];
        c.f = 1;
        c.b.f = -1;
        this.q = c
      };
      n.u = function(a) {
        Z(this, Y);
        this.d = 1;
        this.b = new Ca;
        this.c = a
      };
      n.t = function() {
        Z(this, 1);
        this.d = 2;
        this.q = null
      };
      n.v = function() {
        Z(this, 2);
        this.d = 1
      };
      n.w = function() {
        Z(this, 1);
        this.d = Y;
        var a = this.j[0],
          b = this.j[1],
          c = this.j[2],
          d = !1,
          e = [a, b, c];
        if (0 === a && 0 === b && 0 === c) {
          for (var b = [-2 * 1E150, -2 * 1E150, -2 * 1E150], f = [2 * 1E150, 2 * 1E150, 2 * 1E150], c = [], g = [], d = this.b.c, a = d.e; a !== d; a = a.e)
            for (var h = 0; 3 > h; ++h) {
              var k = a.g[h];
              k < f[h] && (f[h] = k, g[h] = a);
              k > b[h] && (b[h] = k, c[h] = a)
            }
          a = 0;
          b[1] - f[1] > b[0] - f[0] && (a = 1);
          b[2] - f[2] > b[a] - f[a] && (a = 2);
          if (f[a] >= b[a]) e[0] = 0, e[1] = 0, e[2] = 1;
          else {
            b = 0;
            f = g[a];
            c = c[a];
            g = [0, 0, 0];
            f = [f.g[0] - c.g[0], f.g[1] - c.g[1], f.g[2] - c.g[2]];
            h = [0, 0, 0];
            for (a = d.e; a !== d; a =
              a.e) h[0] = a.g[0] - c.g[0], h[1] = a.g[1] - c.g[1], h[2] = a.g[2] - c.g[2], g[0] = f[1] * h[2] - f[2] * h[1], g[1] = f[2] * h[0] - f[0] * h[2], g[2] = f[0] * h[1] - f[1] * h[0], k = g[0] * g[0] + g[1] * g[1] + g[2] * g[2], k > b && (b = k, e[0] = g[0], e[1] = g[1], e[2] = g[2]);
            0 >= b && (e[0] = e[1] = e[2] = 0, e[ha(f)] = 1)
          }
          d = !0
        }
        g = ha(e);
        a = this.b.c;
        b = (g + 1) % 3;
        c = (g + 2) % 3;
        g = 0 < e[g] ? 1 : -1;
        for (e = a.e; e !== a; e = e.e) e.b = e.g[b], e.a = g * e.g[c];
        if (d) {
          e = 0;
          d = this.b.a;
          for (a = d.b; a !== d; a = a.b)
            if (b = a.a, !(0 >= b.f)) {
              do e += (b.a.b - b.b.a.b) * (b.a.a + b.b.a.a), b = b.e; while (b !== a.a)
            } if (0 > e)
            for (e = this.b.c, d = e.e; d !==
              e; d = d.e) d.a = -d.a
        }
        this.n = !1;
        e = this.b.b;
        for (a = e.h; a !== e; a = d)
          if (d = a.h, b = a.e, t(a.a, a.b.a) && a.e.e !== a && (ta(this, b, a), I(a), a = b, b = a.e), b.e === a) {
            if (b !== a) {
              if (b === d || b === d.b) d = d.h;
              I(b)
            }
            if (a === d || a === d.b) d = d.h;
            I(a)
          } this.e = e = new Da;
        d = this.b.c;
        for (a = d.e; a !== d; a = a.e) a.h = xa(e, a);
        Ea(e);
        this.f = new Aa(this);
        za(this, -O);
        for (za(this, O); null !== (e = Fa(this.e));) {
          for (;;) {
            a: if (a = this.e, 0 === a.a) d = Ga(a.b);
              else if (d = a.c[a.d[a.a - 1]], 0 !== a.b.a && (a = Ga(a.b), u(a, d))) {
              d = a;
              break a
            }
            if (null === d || !t(d, e)) break;d = Fa(this.e);ta(this, e.c,
              d.c)
          }
          ya(this, e)
        }
        this.a = this.f.a.a.b.a.a;
        for (e = 0; null !== (d = this.f.a.a.b);) d.h || ++e, Q(d);
        this.f = null;
        e = this.e;
        e.b = null;
        e.d = null;
        this.e = e.c = null;
        e = this.b;
        for (a = e.a.b; a !== e.a; a = d) d = a.b, a = a.a, a.e.e === a && (P(a.c, a), I(a));
        if (!this.n) {
          e = this.b;
          if (this.m)
            for (a = e.b.h; a !== e.b; a = d) d = a.h, a.b.d.c !== a.d.c ? a.f = a.d.c ? 1 : -1 : I(a);
          else
            for (a = e.a.b; a !== e.a; a = d)
              if (d = a.b, a.c) {
                for (a = a.a; u(a.b.a, a.a); a = a.c.b);
                for (; u(a.a, a.b.a); a = a.e);
                b = a.c.b;
                for (c = void 0; a.e !== b;)
                  if (u(a.b.a, b.a)) {
                    for (; b.e !== a && (ca(b.e) || 0 >= x(b.a, b.b.a, b.e.b.a));) c =
                      L(b.e, b), b = c.b;
                    b = b.c.b
                  } else {
                    for (; b.e !== a && (da(a.c.b) || 0 <= x(a.b.a, a.a, a.c.b.a));) c = L(a, a.c.b), a = c.b;
                    a = a.e
                  } for (; b.e.e !== a;) c = L(b.e, b), b = c.b
              } if (this.h || this.i || this.k || this.l)
            if (this.m)
              for (e = this.b, d = e.a.b; d !== e.a; d = d.b) {
                if (d.c) {
                  this.h && this.h(2, this.c);
                  a = d.a;
                  do this.k && this.k(a.a.d, this.c), a = a.e; while (a !== d.a);
                  this.i && this.i(this.c)
                }
              } else {
                e = this.b;
                d = !!this.l;
                a = !1;
                b = -1;
                for (c = e.a.d; c !== e.a; c = c.d)
                  if (c.c) {
                    a || (this.h && this.h(4, this.c), a = !0);
                    g = c.a;
                    do d && (f = g.b.d.c ? 0 : 1, b !== f && (b = f, this.l && this.l(!!b, this.c))),
                      this.k && this.k(g.a.d, this.c), g = g.e; while (g !== c.a)
                  } a && this.i && this.i(this.c)
              }
          if (this.r) {
            e = this.b;
            for (a = e.a.b; a !== e.a; a = d)
              if (d = a.b, !a.c) {
                b = a.a;
                c = b.e;
                g = void 0;
                do g = c, c = g.e, g.d = null, null === g.b.d && (g.c === g ? F(g.a, null) : (g.a.c = g.c, H(g, J(g))), f = g.b, f.c === f ? F(f.a, null) : (f.a.c = f.c, H(f, J(f))), fa(g)); while (g !== b);
                b = a.d;
                a = a.b;
                a.d = b;
                b.b = a
              } this.r(this.b);
            this.c = this.b = null;
            return
          }
        }
        this.b = this.c = null
      };

      function Z(a, b) {
        if (a.d !== b)
          for (; a.d !== b;)
            if (a.d < b) switch (a.d) {
              case Y:
                V(a, 100151);
                a.u(null);
                break;
              case 1:
                V(a, 100152), a.t()
            } else switch (a.d) {
              case 2:
                V(a, 100154);
                a.v();
                break;
              case 1:
                V(a, 100153), a.w()
            }
      }

      function V(a, b) {
        a.p && a.p(b, a.c)
      };

      function ga(a, b) {
        this.b = a || this;
        this.d = b || this;
        this.a = null;
        this.c = !1
      };

      function M() {
        this.h = this;
        this.i = this.d = this.a = this.e = this.c = this.b = null;
        this.f = 0
      }

      function J(a) {
        return a.b.e
      };

      function Ca() {
        this.c = new N;
        this.a = new ga;
        this.b = new M;
        this.d = new M;
        this.b.b = this.d;
        this.d.b = this.b
      };

      function N(a, b) {
        this.e = a || this;
        this.f = b || this;
        this.d = this.c = null;
        this.g = [0, 0, 0];
        this.h = this.a = this.b = 0
      };

      function Da() {
        this.c = [];
        this.d = null;
        this.a = 0;
        this.e = !1;
        this.b = new Ha
      }

      function Ea(a) {
        a.d = [];
        for (var b = 0; b < a.a; b++) a.d[b] = b;
        a.d.sort(function(a) {
          return function(b, e) {
            return u(a[b], a[e]) ? 1 : -1
          }
        }(a.c));
        a.e = !0;
        Ia(a.b)
      }

      function xa(a, b) {
        if (a.e) {
          var c = a.b,
            d = ++c.a;
          2 * d > c.f && (c.f *= 2, c.c = Ja(c.c, c.f + 1));
          var e;
          0 === c.b ? e = d : (e = c.b, c.b = c.c[c.b]);
          c.e[e] = b;
          c.c[e] = d;
          c.d[d] = e;
          c.h && va(c, d);
          return e
        }
        c = a.a++;
        a.c[c] = b;
        return -(c + 1)
      }

      function Fa(a) {
        if (0 === a.a) return Ka(a.b);
        var b = a.c[a.d[a.a - 1]];
        if (0 !== a.b.a && u(Ga(a.b), b)) return Ka(a.b);
        do --a.a; while (0 < a.a && null === a.c[a.d[a.a - 1]]);
        return b
      };

      function Ha() {
        this.d = Ja([0], 33);
        this.e = [null, null];
        this.c = [0, 0];
        this.a = 0;
        this.f = 32;
        this.b = 0;
        this.h = !1;
        this.d[1] = 1
      }

      function Ja(a, b) {
        for (var c = Array(b), d = 0; d < a.length; d++) c[d] = a[d];
        for (; d < b; d++) c[d] = 0;
        return c
      }

      function Ia(a) {
        for (var b = a.a; 1 <= b; --b) W(a, b);
        a.h = !0
      }

      function Ga(a) {
        return a.e[a.d[1]]
      }

      function Ka(a) {
        var b = a.d,
          c = a.e,
          d = a.c,
          e = b[1],
          f = c[e];
        0 < a.a && (b[1] = b[a.a], d[b[1]] = 1, c[e] = null, d[e] = a.b, a.b = e, 0 < --a.a && W(a, 1));
        return f
      }

      function W(a, b) {
        for (var c = a.d, d = a.e, e = a.c, f = b, g = c[f];;) {
          var h = f << 1;
          h < a.a && u(d[c[h + 1]], d[c[h]]) && (h += 1);
          var k = c[h];
          if (h > a.a || u(d[g], d[k])) {
            c[f] = g;
            e[g] = f;
            break
          }
          c[f] = k;
          e[k] = f;
          f = h
        }
      }

      function va(a, b) {
        for (var c = a.d, d = a.e, e = a.c, f = b, g = c[f];;) {
          var h = f >> 1,
            k = c[h];
          if (0 === h || u(d[k], d[g])) {
            c[f] = g;
            e[g] = f;
            break
          }
          c[f] = k;
          e[k] = f;
          f = h
        }
      };

      function ma() {
        this.e = this.a = null;
        this.f = 0;
        this.c = this.b = this.h = this.d = !1
      }

      function S(a) {
        return a.e.c.b
      }

      function R(a) {
        return a.e.a.b
      };
      this.libtess = {
        GluTesselator: X,
        windingRule: {
          GLU_TESS_WINDING_ODD: 100130,
          GLU_TESS_WINDING_NONZERO: 100131,
          GLU_TESS_WINDING_POSITIVE: 100132,
          GLU_TESS_WINDING_NEGATIVE: 100133,
          GLU_TESS_WINDING_ABS_GEQ_TWO: 100134
        },
        primitiveType: {
          GL_LINE_LOOP: 2,
          GL_TRIANGLES: 4,
          GL_TRIANGLE_STRIP: 5,
          GL_TRIANGLE_FAN: 6
        },
        errorType: {
          GLU_TESS_MISSING_BEGIN_POLYGON: 100151,
          GLU_TESS_MISSING_END_POLYGON: 100153,
          GLU_TESS_MISSING_BEGIN_CONTOUR: 100152,
          GLU_TESS_MISSING_END_CONTOUR: 100154,
          GLU_TESS_COORD_TOO_LARGE: 100155,
          GLU_TESS_NEED_COMBINE_CALLBACK: 100156
        },
        gluEnum: {
          GLU_TESS_MESH: 100112,
          GLU_TESS_TOLERANCE: 100142,
          GLU_TESS_WINDING_RULE: 100140,
          GLU_TESS_BOUNDARY_ONLY: 100141,
          GLU_INVALID_ENUM: 100900,
          GLU_INVALID_VALUE: 100901,
          GLU_TESS_BEGIN: 100100,
          GLU_TESS_VERTEX: 100101,
          GLU_TESS_END: 100102,
          GLU_TESS_ERROR: 100103,
          GLU_TESS_EDGE_FLAG: 100104,
          GLU_TESS_COMBINE: 100105,
          GLU_TESS_BEGIN_DATA: 100106,
          GLU_TESS_VERTEX_DATA: 100107,
          GLU_TESS_END_DATA: 100108,
          GLU_TESS_ERROR_DATA: 100109,
          GLU_TESS_EDGE_FLAG_DATA: 100110,
          GLU_TESS_COMBINE_DATA: 100111
        }
      };
      X.prototype.gluDeleteTess = X.prototype.x;
      X.prototype.gluTessProperty = X.prototype.B;
      X.prototype.gluGetTessProperty = X.prototype.y;
      X.prototype.gluTessNormal = X.prototype.A;
      X.prototype.gluTessCallback = X.prototype.z;
      X.prototype.gluTessVertex = X.prototype.C;
      X.prototype.gluTessBeginPolygon = X.prototype.u;
      X.prototype.gluTessBeginContour = X.prototype.t;
      X.prototype.gluTessEndContour = X.prototype.v;
      X.prototype.gluTessEndPolygon = X.prototype.w;
      if (typeof module !== 'undefined') {
        module.exports = this.libtess;
      }

      // wrapper added because of https://github.com/brendankenny/libtess.js/issues/15
      return this.libtess;
    }).apply(new Object()); // need to provide a valid "this" due to strict mode; simply use a dummy object
  </script>
  <script>
    function parseINIString(data) {
      var regex = {
        section: /^\s*\[\s*([^\]]*)\s*\]\s*$/,
        param: /^\s*([^=]+?)\s*=\s*(.*?)\s*$/,
        comment: /^\s*;.*$/
      };
      var value = {};
      var lines = data.split(/[\r\n]+/);
      var section = null;
      lines.forEach(function(line) {
        if (regex.comment.test(line)) {
          return;
        } else if (regex.param.test(line)) {
          var match = line.match(regex.param);
          if (section) {
            value[section][match[1]] = match[2];
          } else {
            value[match[1]] = match[2];
          }
        } else if (regex.section.test(line)) {
          var match = line.match(regex.section);
          value[match[1]] = {};
          section = match[1];
        } else if (line.length == 0 && section) {
          section = null;
        };
      });
      return value;
    }

    // takes a CSSStyleDeclaration or simple object of CSS properties
    function renderThemeGraphics(cssProperties) {
      var getProp = (propName) => cssProperties.getPropertyValue ? cssProperties.getPropertyValue(propName) : cssProperties[propName];

      var canvas = document.createElement("canvas");
      canvas.width = canvas.height = 2;
      var ctx = canvas.getContext("2d");
      ctx.fillStyle = getProp("--ButtonFace");
      ctx.fillRect(0, 1, 1, 1);
      ctx.fillRect(1, 0, 1, 1);
      ctx.fillStyle = getProp("--ButtonHilight");
      ctx.fillRect(0, 0, 1, 1);
      ctx.fillRect(1, 1, 1, 1);
      var checker = `url("${canvas.toDataURL()}")`;

      var scrollbar_size = parseInt(getProp("--scrollbar-size"));
      if (!isFinite(scrollbar_size)) {
        scrollbar_size = 13;
      }
      var scrollbar_button_inner_size = scrollbar_size - 4;

      // I don't know the exact formula, so approximate and special-case it for now
      // (It may very well *be* special cased, tho)
      var arrow_size = Math.floor(0.3 * scrollbar_size);
      if (scrollbar_size < 16 && scrollbar_size > 13) arrow_size -= 1;

      var arrow_width = arrow_size * 2 - 1;

      var arrow_canvas = document.createElement("canvas");
      var arrow_ctx = arrow_canvas.getContext("2d");
      arrow_canvas.width = arrow_width;
      arrow_canvas.height = arrow_size;
      arrow_ctx.fillStyle = "white";
      for (let y = 0; y < arrow_size; y += 1) {
        for (let x = y; x < arrow_width - y; x += 1) {
          arrow_ctx.fillRect(x, y, 1, 1);
        }
      }

      canvas.width = scrollbar_button_inner_size * 4;
      canvas.height = scrollbar_button_inner_size;
      let i = 0;
      for (let horizontal = 0; horizontal < 2; horizontal += 1) {
        for (let decrement = 0; decrement < 2; decrement += 1) {
          ctx.save();
          ctx.translate(i * scrollbar_button_inner_size, 0);
          ctx.translate(scrollbar_button_inner_size / 2, scrollbar_button_inner_size / 2);
          // ctx.rotate(i * Math.PI / 2);
          if (horizontal) {
            ctx.rotate(-Math.PI / 2);
          }
          if (decrement) {
            ctx.scale(1, -1);
          }
          ctx.translate(-scrollbar_button_inner_size / 2, -scrollbar_button_inner_size / 2);
          ctx.drawImage(arrow_canvas, ~~(scrollbar_button_inner_size / 2 - arrow_width / 2), ~~(scrollbar_button_inner_size / 2 - arrow_size / 2));
          ctx.restore();
          i += 1;
        }
      }

      ctx.save();
      ctx.globalCompositeOperation = "source-in";
      ctx.fillStyle = getProp("--ButtonText");
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      var scrollbar_arrows_ButtonText = `url("${canvas.toDataURL()}")`;
      ctx.fillStyle = getProp("--GrayText");
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      var scrollbar_arrows_GrayText = `url("${canvas.toDataURL()}")`;
      ctx.fillStyle = getProp("--ButtonHilight");
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      var scrollbar_arrows_ButtonHilight = `url("${canvas.toDataURL()}")`;
      // ctx.fillStyle = "red";
      // ctx.fillRect(0, 0, canvas.width, canvas.height);
      // canvas.style.background = "rgba(0, 0, 0, 0.2)";
      // $("h1").append(arrow_canvas).append(canvas);
      ctx.restore();

      function border_image(border_size, svg_contents) {
        var base_size = 8;
        var border_size = border_size;
        var scale = 32;
        var slice_size = border_size * scale;
        var view_size = base_size * scale;
        // transform causes janky buggy garbage
        // var svg = `<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="${view_size}px" height="${view_size}px" viewBox="0 0 ${view_size} ${view_size}">
        // 	<g transform="scale(${scale})">
        // 		${svg_contents}
        // 	</g>
        // </svg>`;
        var svg = `<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="${view_size}px" height="${view_size}px" viewBox="0 0 ${view_size} ${view_size}">
			${svg_contents.replace(/(d|x|y|width|height|stroke-width)="[^"]*"/g, (attr)=> attr.replace(/\d+/g, (n)=> n * scale))}
		</svg>`;
        var url = `data:image/svg+xml,${encodeURIComponent(svg)}`;
        return `url("${url}") ${slice_size} / ${border_size}px`;
      }

      var button_active_border_image = border_image(2, `
		<path d="M0 0h8v8h-8v-8z" fill="${getProp("--ButtonDkShadow")}"/>
		<path d="M1 1h6v6h-6v-6z" fill="${getProp("--ButtonShadow")}"/>
		<path d="M2 2h4v4h-4v-4z" fill="${getProp("--ButtonFace")}"/>
	`);
      var button_default_active_border_image = border_image(2, `
		<path d="M0 0h8v8h-8v-8z" fill="${getProp("--ButtonDkShadow")}"/>
		<path d="M1 1h6v6h-6v-6z" fill="${getProp("--ButtonShadow")}"/>
		<path d="M2 2h4v4h-4v-4z" fill="${getProp("--ButtonFace")}"/>
		<rect x="0" y="0" width="8" height="8" stroke-width="2" stroke="${getProp("--WindowFrame")}" fill="none"/>
	`);
      // TODO: rename
      var button_normal_border_image = border_image(2, `
		<path d="M0 0h7v1h-6v6h-1v-7z" fill="${getProp("--ButtonHilight")}"/>
		<path d="M7 0h1v8h-8v-1h7v-7z" fill="${getProp("--ButtonDkShadow")}"/>
		<path d="M1 1h5v1h-4v4h-1v-5z" fill="${getProp("--ButtonLight")}"/>
		<path d="M6 1h1v6h-6v-1h5v-5z" fill="${getProp("--ButtonShadow")}"/>
		<path d="M2 2h4v4h-4v-4z" fill="${getProp("--ButtonFace")}"/>
	`);
      var inset_deep_border_image = border_image(2, `
		<path d="M0 0h7v1h-6v6h-1v-7z" fill="${getProp("--ButtonDkShadow")}"/>
		<path d="M7 0h1v8h-8v-1h7v-7z" fill="${getProp("--ButtonHilight")}"/>
		<path d="M1 1h5v1h-4v4h-1v-5z" fill="${getProp("--ButtonShadow")}"/>
		<path d="M6 1h1v6h-6v-1h5v-5z" fill="${getProp("--ButtonLight")}"/>
		<path d="M2 2h4v4h-4v-4z" fill="${getProp("--ButtonFace")}"/>
	`);
      var button_default_border_image = border_image(3, `
		<path d="M0 0h8v8h-8v-8z" fill="${getProp("--ButtonDkShadow")}"/>
		<path d="M1 1h5v1h-4v4h-1v-5z" fill="${getProp("--ButtonHilight")}"/>
		<path d="M2 2h3v1h-2v2h-1v-3z" fill="${getProp("--ButtonLight")}"/>
		<path d="M5 2h1v4h-4v-1h3v-3z" fill="${getProp("--ButtonShadow")}"/>
		<path d="M3 3h2v2h-2v-2z" fill="${getProp("--ButtonFace")}"/>
		<rect x="0" y="0" width="8" height="8" stroke-width="2" stroke="${getProp("--WindowFrame")}" fill="none"/>
	`);

      return {
        "--checker": checker,
        "--button-active-border-image": button_active_border_image,
        "--button-normal-border-image": button_normal_border_image,
        "--inset-deep-border-image": inset_deep_border_image,
        "--button-default-border-image": button_default_border_image,
        "--button-default-active-border-image": button_default_active_border_image,
        "--scrollbar-arrows-ButtonText": scrollbar_arrows_ButtonText,
        "--scrollbar-arrows-GrayText": scrollbar_arrows_GrayText,
        "--scrollbar-arrows-ButtonHilight": scrollbar_arrows_ButtonHilight,
        "--scrollbar-size": `${scrollbar_size}px`,
        "--scrollbar-button-inner-size": `${scrollbar_button_inner_size}px`,
      };
    }

    // Parse NonClientMetrics
    // https://docs.microsoft.com/en-us/windows/win32/controls/themesfileformat-overview?redirectedfrom=MSDN#metrics-section
    // https://docs.microsoft.com/en-us/windows/win32/winprog/windows-data-types

    // using https://github.com/toji/js-struct

    // var NonClientMetricsStruct = Struct.create(
    //     Struct.uint32("cbSize"),
    //     Struct.int32("iBorderWidth"),
    //     Struct.int32("iScrollWidth"),
    //     Struct.int32("iScrollHeight"),
    //     Struct.int32("iCaptionWidth"),
    //     Struct.int32("iCaptionHeight"),
    // 	// after that, it may be W or A
    // //   LOGFONTW lfCaptionFont;
    // //   int      iSmCaptionWidth;
    // //   int      iSmCaptionHeight;
    // //   LOGFONTW lfSmCaptionFont;
    // //   int      iMenuWidth;
    // //   int      iMenuHeight;
    // //   LOGFONTW lfMenuFont;
    // //   LOGFONTW lfStatusFont;
    // //   LOGFONTW lfMessageFont;
    // //   int      iPaddedBorderWidth;
    // );

    // var NonClientMetrics_buffer = new Uint8Array(NonClientMetrics_string.split(" ").map((str)=> parseInt(str))).buffer;

    // NonClientMetricsStruct.readStructs(NonClientMetrics_buffer, 0, 1)[0];

    function parseThemeFileString(themeIni) {
      // .theme is a renamed .ini text file
      // .themepack is a renamed .cab file, and parsing it as .ini seems to work well enough for the most part, as the .ini data appears in plain,
      // but it may not if compression is enabled for the .cab file
      var theme = parseINIString(themeIni);
      var colors = theme["Control Panel\\Colors"];
      if (!colors) {
        alert("Invalid theme file, no [Control Panel\\Colors] section");
        console.log(theme);
      }
      for (var k in colors) {
        // for .themepack file support, just ignore bad keys that were parsed
        if (k.match(/\W/)) {
          delete colors[k];
        } else {
          colors[k] = `rgb(${colors[k].split(" ").join(", ")})`;
        }
      }

      var cssProperties = {};
      for (var k in colors) {
        cssProperties[`--${k}`] = colors[k];
      }

      cssProperties = Object.assign(renderThemeGraphics(cssProperties), cssProperties);

      return cssProperties;
    }

    function applyCSSProperties(cssProperties, element = document.documentElement) {
      for (var k in cssProperties) {
        element.style.setProperty(k, cssProperties[k]);
      }
    }

    function makeThemeCSSFile(cssProperties) {
      var css = `
/* This is a generated file. */
:root {
`;
      for (var k in cssProperties) {
        css += `\t${k}: ${cssProperties[k]};\n`;
      }
      css += `}
`;
      return css;
    }
  </script>
  <script>
    (function(exports) {

      // TODO: E\("([a-z]+)"\) -> "<$1>" or get rid of jQuery as a dependency
      function E(t) {
        return document.createElement(t);
      }

      var $G = $(window);


      $Window.Z_INDEX = 5;

      function $Window(options) {
        options = options || {};

        var $w = $(E("div")).addClass("window os-window").appendTo("body");
        $w.$titlebar = $(E("div")).addClass("window-titlebar").appendTo($w);
        $w.$title_area = $(E("div")).addClass("window-title-area").appendTo($w.$titlebar);
        $w.$title = $(E("span")).addClass("window-title").appendTo($w.$title_area);
        $w.$minimize = $(E("button")).addClass("window-minimize-button window-button").appendTo($w.$titlebar);
        $w.$maximize = $(E("button")).addClass("window-maximize-button window-button").appendTo($w.$titlebar);
        $w.$x = $(E("button")).addClass("window-close-button window-button").appendTo($w.$titlebar);
        $w.$content = $(E("div")).addClass("window-content").appendTo($w);

        var $component = options.$component;
        if (options.icon) {
          $w.icon_name = options.icon;
          $w.$icon = $Icon(options.icon, TITLEBAR_ICON_SIZE).prependTo($w.$titlebar);
        }
        if ($component) {
          $w.addClass("component-window");
        }

        const $eventTarget = $({});
        const makeSimpleListenable = (name) => {
          return (callback) => {
            const fn = () => {
              callback();
            };
            $eventTarget.on(name, fn);
            const dispose = () => {
              $eventTarget.off(name, fn);
            };
            return dispose;
          };
        };
        $w.onFocus = makeSimpleListenable("focus");
        $w.onBlur = makeSimpleListenable("blur");
        $w.onClosed = makeSimpleListenable("closed");

        $w.focus = () => {
          if (window.focusedWindow === $w) {
            return;
          }
          window.focusedWindow && focusedWindow.blur();
          $w.bringToFront();
          $w.addClass("focused");
          window.focusedWindow = $w;
          $eventTarget.triggerHandler("focus");
        };
        $w.blur = () => {
          if (window.focusedWindow !== $w) {
            return;
          }
          $w.removeClass("focused");
          // TODO: document.activeElement && document.activeElement.blur()?
          $eventTarget.triggerHandler("blur");

          window.focusedWindow = null;
        };

        $w.on("focusin pointerdown", function(e) {
          $w.focus();
        });
        $G.on("pointerdown", (e) => {
          if (
            e.target.closest(".os-window") !== $w[0] &&
            !e.target.closest(".taskbar")
          ) {
            $w.blur();
          }
        });

        $w.attr("touch-action", "none");

        $w.$x.on("click", function() {
          $w.close();
        });

        $w.minimize = function() {
          if ($w.is(":visible")) {
            const $task = this.task.$task;
            const before_rect = $w.$titlebar[0].getBoundingClientRect();
            const after_rect = $task[0].getBoundingClientRect();
            $w.animateTitlebar(before_rect, after_rect, () => {
              $w.hide();
              $w.blur();
            });
          }
        };
        $w.unminimize = function() {
          if ($w.is(":hidden")) {
            const $task = this.task.$task;
            const before_rect = $task[0].getBoundingClientRect();
            $w.show();
            const after_rect = $w.$titlebar[0].getBoundingClientRect();
            $w.hide();
            $w.animateTitlebar(before_rect, after_rect, () => {
              $w.show();
              $w.bringToFront();
              $w.focus();
            });
          }
        };

        let before_maximize;
        $w.$maximize.on("click", function() {

          const instantly_maximize = () => {
            before_maximize = {
              position: $w.css("position"),
              left: $w.css("left"),
              top: $w.css("top"),
              width: $w.css("width"),
              height: $w.css("height"),
            };

            $w.addClass("maximized");
            const $taskbar = $(".taskbar");
            const scrollbar_width = window.innerWidth - $(window).width();
            const scrollbar_height = window.innerHeight - $(window).height();
            const taskbar_height = $taskbar.length ? $taskbar.height() + 1 : 0;
            $w.css({
              position: "fixed",
              top: 0,
              left: 0,
              width: `calc(100vw - ${scrollbar_width}px)`,
              height: `calc(100vh - ${scrollbar_height}px - ${taskbar_height}px)`,
            });
          };
          const instantly_unmaximize = () => {
            $w.removeClass("maximized");
            $w.css({
              width: "",
              height: ""
            });
            if (before_maximize) {
              $w.css({
                position: before_maximize.position,
                left: before_maximize.left,
                top: before_maximize.top,
                width: before_maximize.width,
                height: before_maximize.height,
              });
            }
          };

          const before_rect = $w.$titlebar[0].getBoundingClientRect();
          let after_rect;
          $w.css("transform", "");
          if ($w.hasClass("maximized")) {
            instantly_unmaximize();
            after_rect = $w.$titlebar[0].getBoundingClientRect();
            instantly_maximize();
          } else {
            instantly_maximize();
            after_rect = $w.$titlebar[0].getBoundingClientRect();
            instantly_unmaximize();
          }
          $w.animateTitlebar(before_rect, after_rect, () => {
            if ($w.hasClass("maximized")) {
              instantly_unmaximize();
            } else {
              instantly_maximize();
            }
          });
        });
        $w.$minimize.on("click", function() {
          $w.minimize();
        });
        $w.$title_area.on("mousedown selectstart", ".window-button", function(e) {
          e.preventDefault();
        });
        $w.$title_area.on("dblclick", () => {
          $w.$maximize.triggerHandler("click");
        });

        $w.css({
          position: "absolute",
          zIndex: $Window.Z_INDEX++
        });
        $w.bringToFront = function() {
          $w.css({
            zIndex: $Window.Z_INDEX++
          });
        };
        $w.on("pointerdown", function() {
          $w.bringToFront();
        });

        $w.on("keydown", function(e) {
          if (e.ctrlKey || e.altKey || e.shiftKey) {
            return;
          }
          var $buttons = $w.$content.find("button");
          var $focused = $(document.activeElement);
          var focused_index = $buttons.index($focused);
          // console.log(e.keyCode);
          switch (e.keyCode) {
            case 40: // Down
            case 39: // Right
              if ($focused.is("button")) {
                if (focused_index < $buttons.length - 1) {
                  $buttons.get(focused_index + 1).focus();
                  e.preventDefault();
                }
              }
              break;
            case 38: // Up
            case 37: // Left
              if ($focused.is("button")) {
                if (focused_index > 0) {
                  $buttons.get(focused_index - 1).focus();
                  e.preventDefault();
                }
              }
              break;
            case 32: // Space
            case 13: // Enter (doesn't actually work in chrome because the button gets clicked immediately)
              if ($focused.is("button")) {
                $focused.addClass("pressed");
                var release = function() {
                  $focused.removeClass("pressed");
                  $focused.off("focusout", release);
                  $(window).off("keyup", keyup);
                };
                var keyup = function(e) {
                  if (e.keyCode === 32 || e.keyCode === 13) {
                    release();
                  }
                };
                $focused.on("focusout", release);
                $(window).on("keyup", keyup);
              }
              break;
            case 9: // Tab
              // wrap around when tabbing through controls in a window
              var $controls = $w.$content.find("input, textarea, select, button, a");
              var focused_control_index = $controls.index($focused);
              if (focused_control_index === $controls.length - 1) {
                e.preventDefault();
                $controls[0].focus();
              }
              break;
            case 27: // Esc
              $w.close();
              break;
          }
        });
        // @TODO: restore last focused controls when clicking/mousing down on the window

        $w.applyBounds = function() {
          $w.css({
            left: Math.max(0, Math.min(document.body.scrollWidth - $w.width(), $w.position().left)),
            top: Math.max(0, Math.min(document.body.scrollHeight - $w.height(), $w.position().top)),
          });
        };

        $w.center = function() {
          $w.css({
            left: (innerWidth - $w.width()) / 2 + window.scrollX,
            top: (innerHeight - $w.height()) / 2 + window.scrollY,
          });
          $w.applyBounds();
        };


        $G.on("resize", $w.applyBounds);

        var drag_offset_x, drag_offset_y;
        var mouse_x, mouse_y;
        var update_drag = function(e) {
          mouse_x = e.clientX != null ? e.clientX : mouse_x;
          mouse_y = e.clientY != null ? e.clientY : mouse_y;
          $w.css({
            left: mouse_x + scrollX - drag_offset_x,
            top: mouse_y + scrollY - drag_offset_y,
          });
        };
        $w.$titlebar.attr("touch-action", "none");
        $w.$titlebar.on("mousedown selectstart", function(e) {
          e.preventDefault();
        });
        $w.$titlebar.on("pointerdown", function(e) {
          if ($(e.target).is("button")) {
            return;
          }
          if ($w.hasClass("maximized")) {
            return;
          }
          drag_offset_x = e.clientX + scrollX - $w.position().left;
          drag_offset_y = e.clientY + scrollY - $w.position().top;
          $G.on("pointermove", update_drag);
          $G.on("scroll", update_drag);
          $("body").addClass("dragging"); // for when mouse goes over an iframe
        });
        $G.on("pointerup", function(e) {
          $G.off("pointermove", update_drag);
          $G.off("scroll", update_drag);
          $("body").removeClass("dragging");
          $w.applyBounds();
        });
        $w.$titlebar.on("dblclick", function(e) {
          if ($component) {
            $component.dock();
          }
        });

        $w.$Button = function(text, handler) {
          var $b = $(E("button"))
            .appendTo($w.$content)
            .text(text)
            .on("click", function() {
              if (handler) {
                handler();
              }
              $w.close();
            });
          return $b;
        };
        $w.title = function(title) {
          if (title !== undefined) {
            $w.$title.text(title);
            if ($w.task) {
              $w.task.updateTitle();
            }
            return $w;
          } else {
            return $w.$title.text();
          }
        };
        $w.getTitle = function() {
          return $w.title();
        };
        $w.getIconName = function() {
          return $w.icon_name;
        };
        $w.setIconByID = function(icon_name) {
          // $w.$icon.attr("src", getIconPath(icon_name));
          var old_$icon = $w.$icon;
          $w.$icon = $Icon(icon_name, TITLEBAR_ICON_SIZE);
          old_$icon.replaceWith($w.$icon);
          $w.icon_name = icon_name;
          $w.task.updateIcon();
          return $w;
        };
        $w.animateTitlebar = function(from, to, callback = () => {}) {
          const $eye_leader = $w.$titlebar.clone(true);
          $eye_leader.find("button").remove();
          $eye_leader.appendTo("body");
          const durationMS = 200; // TODO: how long?
          const duration = `${durationMS}ms`;
          $eye_leader.css({
            transition: `left ${duration} linear, top ${duration} linear, width ${duration} linear, height ${duration} linear`,
            position: "fixed",
            zIndex: 10000000,
            pointerEvents: "none",
            left: from.left,
            top: from.top,
            width: from.width,
            height: from.height,
          });
          setTimeout(() => {
            $eye_leader.css({
              left: to.left,
              top: to.top,
              width: to.width,
              height: to.height,
            });
          }, 5);
          const tid = setTimeout(() => {
            $eye_leader.remove();
            callback();
          }, durationMS * 1.2);
          $eye_leader.on("transitionend animationcancel", () => {
            $eye_leader.remove();
            clearTimeout(tid);
            callback();
          });
        };
        $w.close = function(force) {
          if (!force) {
            var e = $.Event("close");
            $w.trigger(e);
            if (e.isDefaultPrevented()) {
              return;
            }
          }
          if ($component) {
            $component.detach();
          }
          $w.remove();
          $w.closed = true;
          $eventTarget.triggerHandler("closed");
          // $w.trigger("closed");
          // TODO: change usages of "close" to "closed" where appropriate
          // and probably rename the "close" event
        };
        $w.closed = false;

        if (options.title) {
          $w.title(options.title);
        }

        if (!$component) {
          $w.center();
        }

        // mustHaveMethods($w, windowInterfaceMethods);

        return $w;
      }

      function $FormWindow(title) {
        var $w = new $Window();

        $w.title(title);
        $w.$form = $(E("form")).appendTo($w.$content);
        $w.$main = $(E("div")).appendTo($w.$form);
        $w.$buttons = $(E("div")).appendTo($w.$form).addClass("button-group");

        $w.$Button = function(label, action) {
          var $b = $(E("button")).appendTo($w.$buttons).text(label);
          $b.on("click", function(e) {
            // prevent the form from submitting
            // @TODO: instead, prevent the form's submit event
            e.preventDefault();

            action();
          });

          $b.on("pointerdown", function() {
            $b.focus();
          });

          return $b;
        };

        return $w;
      }

      exports.$Window = $Window;
      exports.$FormWindow = $FormWindow;

    })(window);
  </script>
  <script>
    (function(exports) {

      // TODO: E\("([a-z]+)"\) -> "<$1>" or get rid of jQuery as a dependency
      function E(t) {
        return document.createElement(t);
      }

      // @TODO: make menus not take focus so we can support copy/pasting text in the text tool textarea from the menus

      const MENU_DIVIDER = "MENU_DIVIDER";

      function $MenuBar(menus) {

        const $ = jQuery;
        const $G = $(self);

        const $menus = $(E("div")).addClass("menus");

        $menus.attr("touch-action", "none");
        let selecting_menus = false;

        const _html = menus_key => menus_key.replace(/&(.)/, m => `<span class='menu-hotkey'>${m[1]}</span>`);
        const _hotkey = menus_key => menus_key[menus_key.indexOf("&") + 1].toUpperCase();

        const close_menus = () => {
          $menus.find(".menu-button").trigger("release");
          // Close any rogue floating submenus
          $(".menu-popup").hide();
        };

        const is_disabled = item => {
          if (typeof item.enabled === "function") {
            return !item.enabled();
          } else if (typeof item.enabled === "boolean") {
            return !item.enabled;
          } else {
            return false;
          }
        };

        // @TODO: API for context menus (i.e. floating menu popups)
        function $MenuPopup(menu_items) {
          const $menu_popup = $(E("div")).addClass("menu-popup");
          const $menu_popup_table = $(E("table")).addClass("menu-popup-table").appendTo($menu_popup);

          $.map(menu_items, item => {
            const $row = $(E("tr")).addClass("menu-row").appendTo($menu_popup_table);
            if (item === MENU_DIVIDER) {
              const $td = $(E("td")).attr({
                colspan: 4
              }).appendTo($row);
              const $hr = $(E("hr")).addClass("menu-hr").appendTo($td);
            } else {
              const $item = $row.addClass("menu-item");
              const $checkbox_area = $(E("td")).addClass("menu-item-checkbox-area");
              const $label = $(E("td")).addClass("menu-item-label");
              const $shortcut = $(E("td")).addClass("menu-item-shortcut");
              const $submenu_area = $(E("td")).addClass("menu-item-submenu-area");

              $item.append($checkbox_area, $label, $shortcut, $submenu_area);

              $item.attr("tabIndex", -1);

              $label.html(_html(item.item));
              $shortcut.text(item.shortcut);

              $menu_popup.on("update", () => {
                $item.attr("disabled", is_disabled(item));
                if (item.checkbox && item.checkbox.check) {
                  $checkbox_area.text(item.checkbox.check() ? "✓" : "");
                }
              });
              $item.on("pointerover", () => {
                $menu_popup.triggerHandler("update");
                $item[0].focus();
              });

              if (item.checkbox) {
                $checkbox_area.text("✓");
              }

              if (item.submenu) {
                $submenu_area.html('<svg xmlns="http://www.w3.org/2000/svg" width="10" height="11" viewBox="0 0 10 11" style="fill:currentColor;display:inline-block;vertical-align:middle"><path d="M7.5 4.33L0 8.66L0 0z"/></svg>');

                const $submenu_popup = $MenuPopup(item.submenu).appendTo("body");
                $submenu_popup.hide();

                const open_submenu = () => {
                  $submenu_popup.show();
                  $submenu_popup.triggerHandler("update");
                  const rect = $item[0].getBoundingClientRect();
                  $submenu_popup.css({
                    position: "absolute",
                    left: rect.right + window.scrollX,
                    top: rect.top + window.scrollY,
                  });
                  let submenu_popup_rect = $submenu_popup[0].getBoundingClientRect();
                  if (submenu_popup_rect.right > innerWidth) {
                    $submenu_popup.css({
                      left: rect.left - submenu_popup_rect.width,
                    });
                    submenu_popup_rect = $submenu_popup[0].getBoundingClientRect();
                    if (submenu_popup_rect.left < 0) {
                      $submenu_popup.css({
                        left: 0,
                      });
                    }
                  }
                };
                let open_tid, close_tid;
                $item.add($submenu_popup).on("pointerover", () => {
                  if (open_tid) {
                    clearTimeout(open_tid);
                  }
                  if (close_tid) {
                    clearTimeout(close_tid);
                  }
                });
                $item.on("pointerover", () => {
                  if (open_tid) {
                    clearTimeout(open_tid);
                  }
                  if (close_tid) {
                    clearTimeout(close_tid);
                  }
                  open_tid = setTimeout(open_submenu, 200);
                });
                $item.add($submenu_popup).on("pointerout", () => {
                  $menu_popup.closest(".menu-container").find(".menu-button")[0].focus();
                  if (open_tid) {
                    clearTimeout(open_tid);
                  }
                  if (close_tid) {
                    clearTimeout(close_tid);
                  }
                  close_tid = setTimeout(() => {
                    $submenu_popup.hide();
                  }, 200);
                });
                $item.on("click pointerdown", open_submenu);
              }

              const item_action = () => {
                if (item.checkbox) {
                  if (item.checkbox.toggle) {
                    item.checkbox.toggle();
                  }
                  $menu_popup.triggerHandler("update");
                } else if (item.action) {
                  close_menus();
                  item.action();
                }
              };
              $item.on("pointerup", e => {
                if (e.pointerType === "mouse" && e.button !== 0) {
                  return;
                }
                item_action();
              });
              $item.on("pointerover", () => {
                if (item.submenu) {
                  $menus.triggerHandler("info", "");
                } else {
                  $menus.triggerHandler("info", item.description || "");
                }
              });
              $item.on("pointerout", () => {
                if ($item.is(":visible")) {
                  $menus.triggerHandler("info", "");
                  // may not exist for submenu popups
                  const menu_button = $menu_popup.closest(".menu-container").find(".menu-button")[0];
                  if (menu_button) {
                    menu_button.focus();
                  }
                }
              });

              $item.on("keydown", e => {
                if (e.ctrlKey || e.shiftKey || e.altKey || e.metaKey) {
                  return;
                }
                if (e.keyCode === 13) { // Enter
                  e.preventDefault();
                  item_action();
                }
              });

              $menu_popup.on("keydown", e => {
                if (e.ctrlKey || e.shiftKey || e.altKey || e.metaKey) {
                  return;
                }
                if (String.fromCharCode(e.keyCode) === _hotkey(item.item)) {
                  e.preventDefault();
                  $item.trogger("click");
                }
              });
            }
          });

          return $menu_popup;
        }

        let this_click_opened_the_menu = false;
        const make_menu = (menus_key, menu_items) => {
          const $menu_container = $(E("div")).addClass("menu-container").appendTo($menus);
          const $menu_button = $(E("div")).addClass("menu-button").appendTo($menu_container);
          const $menu_popup = $MenuPopup(menu_items).appendTo($menu_container);

          const update_position_from_containing_bounds = () => {
            $menu_popup.css("left", "");
            const uncorrected_rect = $menu_popup[0].getBoundingClientRect();
            if (uncorrected_rect.right > innerWidth) {
              $menu_popup.css("left", innerWidth - uncorrected_rect.width - uncorrected_rect.left);
            }
          };
          $G.on("resize", update_position_from_containing_bounds);
          $menu_popup.on("update", update_position_from_containing_bounds);
          update_position_from_containing_bounds();

          const menu_id = menus_key.replace("&", "").replace(/ /g, "-").toLowerCase();
          $menu_button.addClass(`${menu_id}-menu-button`);

          $menu_popup.hide();
          $menu_button.html(_html(menus_key));
          $menu_button.attr("tabIndex", -1)
          $menu_container.on("keydown", e => {
            const $focused_item = $menu_popup.find(".menu-item:focus");
            switch (e.keyCode) {
              case 37: // Left
                $menu_container.prev().find(".menu-button").trigger("pointerdown");
                break;
              case 39: // Right
                if ($focused_item.find(".menu-item-submenu-area:not(:empty)").length) {
                  $focused_item.trigger("click");
                  $(".menu-popup .menu-item")[0].focus(); // first item
                  e.preventDefault();
                } else {
                  $menu_container.next().find(".menu-button").trigger("pointerdown");
                }
                break;
              case 40: // Down
                if ($menu_popup.is(":visible") && $focused_item.length) {
                  let $next = $focused_item.next();
                  while ($next.length && !$next.is(".menu-item")) {
                    $next = $next.next();
                  }
                  $next[0].focus();
                } else {
                  $menu_button.trigger("pointerdown");
                  $menu_popup.find(".menu-item")[0].focus(); // first item
                }
                break;
              case 38: // Up
                if ($menu_popup.is(":visible") && $focused_item.length) {
                  let $prev = $focused_item.prev();
                  while ($prev.length && !$prev.is(".menu-item")) {
                    $prev = $prev.prev();
                  }
                  $prev[0].focus();
                } else {
                  $menu_button.trigger("pointerdown"); // or maybe do nothing?
                  $menu_popup.find(".menu-item").last()[0].focus();
                }
                break;
            }
          });
          $G.on("keydown", e => {
            if (e.ctrlKey || e.metaKey) { // Ctrl or Command held
              if (e.keyCode !== 17 && e.keyCode !== 91 && e.keyCode !== 93 && e.keyCode !== 224) { // anything but Ctrl or Command pressed
                close_menus();
              }
              return;
            }
            if (e.altKey) {
              if (String.fromCharCode(e.keyCode) === _hotkey(menus_key)) {
                e.preventDefault();
                $menu_button.trigger("pointerdown");
              }
            }
          });
          $menu_container.on("pointerdown pointerover", e => {
            if (e.type === "pointerover" && !selecting_menus) {
              return;
            }
            if (e.type !== "pointerover") {
              if (!$menu_button.hasClass("active")) {
                this_click_opened_the_menu = true;
              }
            }

            close_menus();

            $menu_button[0].focus();
            $menu_button.addClass("active");
            $menu_popup.show();
            $menu_popup.triggerHandler("update");

            selecting_menus = true;

            $menus.triggerHandler("info", "");
          });
          $menu_container.on("pointerup", () => {
            if (this_click_opened_the_menu) {
              this_click_opened_the_menu = false;
              return;
            }
            if ($menu_button.hasClass("active")) {
              close_menus();
            }
          });
          $menu_container.on("release", () => {
            selecting_menus = false;

            $menu_button.removeClass("active");
            $menu_popup.hide();

            $menus.triggerHandler("default-info");
          });
        };
        for (const menu_key in menus) {
          make_menu(menu_key, menus[menu_key]);
        }

        $G.on("keypress", e => {
          if (e.keyCode === 27) { // Esc
            close_menus();
          }
        });
        $G.on("blur", () => {
          // window.console && console.log("blur", e.target, document.activeElement);
          close_menus();
        });
        $G.on("pointerdown pointerup", e => {
          if ($(e.target).closest(".menus, .menu-popup").length === 0) {
            // window.console && console.log(e.type, "occurred outside of menus (on ", e.target, ") so...");
            close_menus();
          }
        });

        return $menus;

      }

      exports.$MenuBar = $MenuBar;
      exports.MENU_DIVIDER = MENU_DIVIDER;

    })(window);
  </script>
  <script>
    /*
	imagetracer.js version 1.2.5
	Simple raster image tracer and vectorizer written in JavaScript.
	andras@jankovics.net
*/

    /*

    The Unlicense / PUBLIC DOMAIN

    This is free and unencumbered software released into the public domain.

    Anyone is free to copy, modify, publish, use, compile, sell, or
    distribute this software, either in source code form or as a compiled
    binary, for any purpose, commercial or non-commercial, and by any
    means.

    In jurisdictions that recognize copyright laws, the author or authors
    of this software dedicate any and all copyright interest in the
    software to the public domain. We make this dedication for the benefit
    of the public at large and to the detriment of our heirs and
    successors. We intend this dedication to be an overt act of
    relinquishment in perpetuity of all present and future rights to this
    software under copyright law.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
    OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.

    For more information, please refer to http://unlicense.org/

    */

    (function() {
      'use strict';

      function ImageTracer() {
        var _this = this;

        this.versionnumber = '1.2.5',

          ////////////////////////////////////////////////////////////
          //
          //  User friendly functions
          //
          ////////////////////////////////////////////////////////////

          // Loading an image from a URL, tracing when loaded,
          // then executing callback with the scaled svg string as argument
          this.imageToSVG = function(url, callback, options) {
            options = _this.checkoptions(options);
            // loading image, tracing and callback
            _this.loadImage(
              url,
              function(canvas) {
                callback(
                  _this.imagedataToSVG(_this.getImgdata(canvas), options)
                );
              },
              options
            );
          }, // End of imageToSVG()

          // Tracing imagedata, then returning the scaled svg string
          this.imagedataToSVG = function(imgd, options) {
            options = _this.checkoptions(options);
            // tracing imagedata
            var td = _this.imagedataToTracedata(imgd, options);
            // returning SVG string
            return _this.getsvgstring(td, options);
          }, // End of imagedataToSVG()

          // Loading an image from a URL, tracing when loaded,
          // then executing callback with tracedata as argument
          this.imageToTracedata = function(url, callback, options) {
            options = _this.checkoptions(options);
            // loading image, tracing and callback
            _this.loadImage(
              url,
              function(canvas) {
                callback(
                  _this.imagedataToTracedata(_this.getImgdata(canvas), options)
                );
              },
              options
            );
          }, // End of imageToTracedata()

          // Tracing imagedata, then returning tracedata (layers with paths, palette, image size)
          this.imagedataToTracedata = function(imgd, options) {
            options = _this.checkoptions(options);

            // 1. Color quantization
            var ii = _this.colorquantization(imgd, options);

            if (options.layering === 0) { // Sequential layering

              // create tracedata object
              var tracedata = {
                layers: [],
                palette: ii.palette,
                width: ii.array[0].length - 2,
                height: ii.array.length - 2
              };

              // Loop to trace each color layer
              for (var colornum = 0; colornum < ii.palette.length; colornum++) {

                // layeringstep -> pathscan -> internodes -> batchtracepaths
                var tracedlayer =
                  _this.batchtracepaths(

                    _this.internodes(

                      _this.pathscan(
                        _this.layeringstep(ii, colornum),
                        options.pathomit
                      ),

                      options

                    ),

                    options.ltres,
                    options.qtres

                  );

                // adding traced layer
                tracedata.layers.push(tracedlayer);

              } // End of color loop

            } else { // Parallel layering
              // 2. Layer separation and edge detection
              var ls = _this.layering(ii);

              // Optional edge node visualization
              if (options.layercontainerid) {
                _this.drawLayers(ls, _this.specpalette, options.scale, options.layercontainerid);
              }

              // 3. Batch pathscan
              var bps = _this.batchpathscan(ls, options.pathomit);

              // 4. Batch interpollation
              var bis = _this.batchinternodes(bps, options);

              // 5. Batch tracing and creating tracedata object
              var tracedata = {
                layers: _this.batchtracelayers(bis, options.ltres, options.qtres),
                palette: ii.palette,
                width: imgd.width,
                height: imgd.height
              };

            } // End of parallel layering

            // return tracedata
            return tracedata;

          }, // End of imagedataToTracedata()

          this.optionpresets = {
            'default': {

              // Tracing
              corsenabled: false,
              ltres: 1,
              qtres: 1,
              pathomit: 8,
              rightangleenhance: true,

              // Color quantization
              colorsampling: 2,
              numberofcolors: 16,
              mincolorratio: 0,
              colorquantcycles: 3,

              // Layering method
              layering: 0,

              // SVG rendering
              strokewidth: 1,
              linefilter: false,
              scale: 1,
              roundcoords: 1,
              viewbox: false,
              desc: false,
              lcpr: 0,
              qcpr: 0,

              // Blur
              blurradius: 0,
              blurdelta: 20

            },
            'posterized1': {
              colorsampling: 0,
              numberofcolors: 2
            },
            'posterized2': {
              numberofcolors: 4,
              blurradius: 5
            },
            'curvy': {
              ltres: 0.01,
              linefilter: true,
              rightangleenhance: false
            },
            'sharp': {
              qtres: 0.01,
              linefilter: false
            },
            'detailed': {
              pathomit: 0,
              roundcoords: 2,
              ltres: 0.5,
              qtres: 0.5,
              numberofcolors: 64
            },
            'smoothed': {
              blurradius: 5,
              blurdelta: 64
            },
            'grayscale': {
              colorsampling: 0,
              colorquantcycles: 1,
              numberofcolors: 7
            },
            'fixedpalette': {
              colorsampling: 0,
              colorquantcycles: 1,
              numberofcolors: 27
            },
            'randomsampling1': {
              colorsampling: 1,
              numberofcolors: 8
            },
            'randomsampling2': {
              colorsampling: 1,
              numberofcolors: 64
            },
            'artistic1': {
              colorsampling: 0,
              colorquantcycles: 1,
              pathomit: 0,
              blurradius: 5,
              blurdelta: 64,
              ltres: 0.01,
              linefilter: true,
              numberofcolors: 16,
              strokewidth: 2
            },
            'artistic2': {
              qtres: 0.01,
              colorsampling: 0,
              colorquantcycles: 1,
              numberofcolors: 4,
              strokewidth: 0
            },
            'artistic3': {
              qtres: 10,
              ltres: 10,
              numberofcolors: 8
            },
            'artistic4': {
              qtres: 10,
              ltres: 10,
              numberofcolors: 64,
              blurradius: 5,
              blurdelta: 256,
              strokewidth: 2
            },
            'posterized3': {
              ltres: 1,
              qtres: 1,
              pathomit: 20,
              rightangleenhance: true,
              colorsampling: 0,
              numberofcolors: 3,
              mincolorratio: 0,
              colorquantcycles: 3,
              blurradius: 3,
              blurdelta: 20,
              strokewidth: 0,
              linefilter: false,
              roundcoords: 1,
              pal: [{
                r: 0,
                g: 0,
                b: 100,
                a: 255
              }, {
                r: 255,
                g: 255,
                b: 255,
                a: 255
              }]
            }
          }, // End of optionpresets

          // creating options object, setting defaults for missing values
          this.checkoptions = function(options) {
            options = options || {};
            // Option preset
            if (typeof options === 'string') {
              options = options.toLowerCase();
              if (_this.optionpresets[options]) {
                options = _this.optionpresets[options];
              } else {
                options = {};
              }
            }
            // Defaults
            var ok = Object.keys(_this.optionpresets['default']);
            for (var k = 0; k < ok.length; k++) {
              if (!options.hasOwnProperty(ok[k])) {
                options[ok[k]] = _this.optionpresets['default'][ok[k]];
              }
            }
            // options.pal is not defined here, the custom palette should be added externally: options.pal = [ { 'r':0, 'g':0, 'b':0, 'a':255 }, {...}, ... ];
            // options.layercontainerid is not defined here, can be added externally: options.layercontainerid = 'mydiv'; ... <div id="mydiv"></div>
            return options;
          }, // End of checkoptions()

          ////////////////////////////////////////////////////////////
          //
          //  Vectorizing functions
          //
          ////////////////////////////////////////////////////////////

          // 1. Color quantization
          // Using a form of k-means clustering repeatead options.colorquantcycles times. http://en.wikipedia.org/wiki/Color_quantization
          this.colorquantization = function(imgd, options) {
            var arr = [],
              idx = 0,
              cd, cdl, ci, paletteacc = [],
              pixelnum = imgd.width * imgd.height,
              i, j, k, cnt, palette;

            // imgd.data must be RGBA, not just RGB
            if (imgd.data.length < pixelnum * 4) {
              var newimgddata = new Uint8ClampedArray(pixelnum * 4);
              for (var pxcnt = 0; pxcnt < pixelnum; pxcnt++) {
                newimgddata[pxcnt * 4] = imgd.data[pxcnt * 3];
                newimgddata[pxcnt * 4 + 1] = imgd.data[pxcnt * 3 + 1];
                newimgddata[pxcnt * 4 + 2] = imgd.data[pxcnt * 3 + 2];
                newimgddata[pxcnt * 4 + 3] = 255;
              }
              imgd.data = newimgddata;
            } // End of RGBA imgd.data check

            // Filling arr (color index array) with -1
            for (j = 0; j < imgd.height + 2; j++) {
              arr[j] = [];
              for (i = 0; i < imgd.width + 2; i++) {
                arr[j][i] = -1;
              }
            }

            // Use custom palette if pal is defined or sample / generate custom length palette
            if (options.pal) {
              palette = options.pal;
            } else if (options.colorsampling === 0) {
              palette = _this.generatepalette(options.numberofcolors);
            } else if (options.colorsampling === 1) {
              palette = _this.samplepalette(options.numberofcolors, imgd);
            } else {
              palette = _this.samplepalette2(options.numberofcolors, imgd);
            }

            // Selective Gaussian blur preprocessing
            if (options.blurradius > 0) {
              imgd = _this.blur(imgd, options.blurradius, options.blurdelta);
            }

            // Repeat clustering step options.colorquantcycles times
            for (cnt = 0; cnt < options.colorquantcycles; cnt++) {

              // Average colors from the second iteration
              if (cnt > 0) {
                // averaging paletteacc for palette
                for (k = 0; k < palette.length; k++) {

                  // averaging
                  if (paletteacc[k].n > 0) {
                    palette[k] = {
                      r: Math.floor(paletteacc[k].r / paletteacc[k].n),
                      g: Math.floor(paletteacc[k].g / paletteacc[k].n),
                      b: Math.floor(paletteacc[k].b / paletteacc[k].n),
                      a: Math.floor(paletteacc[k].a / paletteacc[k].n)
                    };
                  }

                  // Randomizing a color, if there are too few pixels and there will be a new cycle
                  if ((paletteacc[k].n / pixelnum < options.mincolorratio) && (cnt < options.colorquantcycles - 1)) {
                    palette[k] = {
                      r: Math.floor(Math.random() * 255),
                      g: Math.floor(Math.random() * 255),
                      b: Math.floor(Math.random() * 255),
                      a: Math.floor(Math.random() * 255)
                    };
                  }

                } // End of palette loop
              } // End of Average colors from the second iteration

              // Reseting palette accumulator for averaging
              for (i = 0; i < palette.length; i++) {
                paletteacc[i] = {
                  r: 0,
                  g: 0,
                  b: 0,
                  a: 0,
                  n: 0
                };
              }

              // loop through all pixels
              for (j = 0; j < imgd.height; j++) {
                for (i = 0; i < imgd.width; i++) {

                  // pixel index
                  idx = (j * imgd.width + i) * 4;

                  // find closest color from palette by measuring (rectilinear) color distance between this pixel and all palette colors
                  ci = 0;
                  cdl = 1024; // 4 * 256 is the maximum RGBA distance
                  for (k = 0; k < palette.length; k++) {

                    // In my experience, https://en.wikipedia.org/wiki/Rectilinear_distance works better than https://en.wikipedia.org/wiki/Euclidean_distance
                    cd = Math.abs(palette[k].r - imgd.data[idx]) + Math.abs(palette[k].g - imgd.data[idx + 1]) + Math.abs(palette[k].b - imgd.data[idx + 2]) + Math.abs(palette[k].a - imgd.data[idx + 3]);

                    // Remember this color if this is the closest yet
                    if (cd < cdl) {
                      cdl = cd;
                      ci = k;
                    }

                  } // End of palette loop

                  // add to palettacc
                  paletteacc[ci].r += imgd.data[idx];
                  paletteacc[ci].g += imgd.data[idx + 1];
                  paletteacc[ci].b += imgd.data[idx + 2];
                  paletteacc[ci].a += imgd.data[idx + 3];
                  paletteacc[ci].n++;

                  // update the indexed color array
                  arr[j + 1][i + 1] = ci;

                } // End of i loop
              } // End of j loop

            } // End of Repeat clustering step options.colorquantcycles times

            return {
              array: arr,
              palette: palette
            };

          }, // End of colorquantization()

          // Sampling a palette from imagedata
          this.samplepalette = function(numberofcolors, imgd) {
            var idx, palette = [];
            for (var i = 0; i < numberofcolors; i++) {
              idx = Math.floor(Math.random() * imgd.data.length / 4) * 4;
              palette.push({
                r: imgd.data[idx],
                g: imgd.data[idx + 1],
                b: imgd.data[idx + 2],
                a: imgd.data[idx + 3]
              });
            }
            return palette;
          }, // End of samplepalette()

          // Deterministic sampling a palette from imagedata: rectangular grid
          this.samplepalette2 = function(numberofcolors, imgd) {
            var idx, palette = [],
              ni = Math.ceil(Math.sqrt(numberofcolors)),
              nj = Math.ceil(numberofcolors / ni),
              vx = imgd.width / (ni + 1),
              vy = imgd.height / (nj + 1);
            for (var j = 0; j < nj; j++) {
              for (var i = 0; i < ni; i++) {
                if (palette.length === numberofcolors) {
                  break;
                } else {
                  idx = Math.floor(((j + 1) * vy) * imgd.width + ((i + 1) * vx)) * 4;
                  palette.push({
                    r: imgd.data[idx],
                    g: imgd.data[idx + 1],
                    b: imgd.data[idx + 2],
                    a: imgd.data[idx + 3]
                  });
                }
              }
            }
            return palette;
          }, // End of samplepalette2()

          // Generating a palette with numberofcolors
          this.generatepalette = function(numberofcolors) {
            var palette = [],
              rcnt, gcnt, bcnt;
            if (numberofcolors < 8) {

              // Grayscale
              var graystep = Math.floor(255 / (numberofcolors - 1));
              for (var i = 0; i < numberofcolors; i++) {
                palette.push({
                  r: i * graystep,
                  g: i * graystep,
                  b: i * graystep,
                  a: 255
                });
              }

            } else {

              // RGB color cube
              var colorqnum = Math.floor(Math.pow(numberofcolors, 1 / 3)), // Number of points on each edge on the RGB color cube
                colorstep = Math.floor(255 / (colorqnum - 1)), // distance between points
                rndnum = numberofcolors - colorqnum * colorqnum * colorqnum; // number of random colors

              for (rcnt = 0; rcnt < colorqnum; rcnt++) {
                for (gcnt = 0; gcnt < colorqnum; gcnt++) {
                  for (bcnt = 0; bcnt < colorqnum; bcnt++) {
                    palette.push({
                      r: rcnt * colorstep,
                      g: gcnt * colorstep,
                      b: bcnt * colorstep,
                      a: 255
                    });
                  } // End of blue loop
                } // End of green loop
              } // End of red loop

              // Rest is random
              for (rcnt = 0; rcnt < rndnum; rcnt++) {
                palette.push({
                  r: Math.floor(Math.random() * 255),
                  g: Math.floor(Math.random() * 255),
                  b: Math.floor(Math.random() * 255),
                  a: Math.floor(Math.random() * 255)
                });
              }

            } // End of numberofcolors check

            return palette;
          }, // End of generatepalette()

          // 2. Layer separation and edge detection
          // Edge node types ( ▓: this layer or 1; ░: not this layer or 0 )
          // 12  ░░  ▓░  ░▓  ▓▓  ░░  ▓░  ░▓  ▓▓  ░░  ▓░  ░▓  ▓▓  ░░  ▓░  ░▓  ▓▓
          // 48  ░░  ░░  ░░  ░░  ░▓  ░▓  ░▓  ░▓  ▓░  ▓░  ▓░  ▓░  ▓▓  ▓▓  ▓▓  ▓▓
          //     0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15
          this.layering = function(ii) {
            // Creating layers for each indexed color in arr
            var layers = [],
              val = 0,
              ah = ii.array.length,
              aw = ii.array[0].length,
              n1, n2, n3, n4, n5, n6, n7, n8, i, j, k;

            // Create layers
            for (k = 0; k < ii.palette.length; k++) {
              layers[k] = [];
              for (j = 0; j < ah; j++) {
                layers[k][j] = [];
                for (i = 0; i < aw; i++) {
                  layers[k][j][i] = 0;
                }
              }
            }

            // Looping through all pixels and calculating edge node type
            for (j = 1; j < ah - 1; j++) {
              for (i = 1; i < aw - 1; i++) {

                // This pixel's indexed color
                val = ii.array[j][i];

                // Are neighbor pixel colors the same?
                n1 = ii.array[j - 1][i - 1] === val ? 1 : 0;
                n2 = ii.array[j - 1][i] === val ? 1 : 0;
                n3 = ii.array[j - 1][i + 1] === val ? 1 : 0;
                n4 = ii.array[j][i - 1] === val ? 1 : 0;
                n5 = ii.array[j][i + 1] === val ? 1 : 0;
                n6 = ii.array[j + 1][i - 1] === val ? 1 : 0;
                n7 = ii.array[j + 1][i] === val ? 1 : 0;
                n8 = ii.array[j + 1][i + 1] === val ? 1 : 0;

                // this pixel's type and looking back on previous pixels
                layers[val][j + 1][i + 1] = 1 + n5 * 2 + n8 * 4 + n7 * 8;
                if (!n4) {
                  layers[val][j + 1][i] = 0 + 2 + n7 * 4 + n6 * 8;
                }
                if (!n2) {
                  layers[val][j][i + 1] = 0 + n3 * 2 + n5 * 4 + 8;
                }
                if (!n1) {
                  layers[val][j][i] = 0 + n2 * 2 + 4 + n4 * 8;
                }

              } // End of i loop
            } // End of j loop

            return layers;
          }, // End of layering()

          // 2. Layer separation and edge detection
          // Edge node types ( ▓: this layer or 1; ░: not this layer or 0 )
          // 12  ░░  ▓░  ░▓  ▓▓  ░░  ▓░  ░▓  ▓▓  ░░  ▓░  ░▓  ▓▓  ░░  ▓░  ░▓  ▓▓
          // 48  ░░  ░░  ░░  ░░  ░▓  ░▓  ░▓  ░▓  ▓░  ▓░  ▓░  ▓░  ▓▓  ▓▓  ▓▓  ▓▓
          //     0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15
          this.layeringstep = function(ii, cnum) {
            // Creating layers for each indexed color in arr
            var layer = [],
              val = 0,
              ah = ii.array.length,
              aw = ii.array[0].length,
              n1, n2, n3, n4, n5, n6, n7, n8, i, j, k;

            // Create layer
            for (j = 0; j < ah; j++) {
              layer[j] = [];
              for (i = 0; i < aw; i++) {
                layer[j][i] = 0;
              }
            }

            // Looping through all pixels and calculating edge node type
            for (j = 1; j < ah; j++) {
              for (i = 1; i < aw; i++) {
                layer[j][i] =
                  (ii.array[j - 1][i - 1] === cnum ? 1 : 0) +
                  (ii.array[j - 1][i] === cnum ? 2 : 0) +
                  (ii.array[j][i - 1] === cnum ? 8 : 0) +
                  (ii.array[j][i] === cnum ? 4 : 0);
              } // End of i loop
            } // End of j loop

            return layer;
          }, // End of layeringstep()

          // Lookup tables for pathscan
          // pathscan_combined_lookup[ arr[py][px] ][ dir ] = [nextarrpypx, nextdir, deltapx, deltapy];
          this.pathscan_combined_lookup = [
            [
              [-1, -1, -1, -1],
              [-1, -1, -1, -1],
              [-1, -1, -1, -1],
              [-1, -1, -1, -1]
            ], // arr[py][px]===0 is invalid
            [
              [0, 1, 0, -1],
              [-1, -1, -1, -1],
              [-1, -1, -1, -1],
              [0, 2, -1, 0]
            ],
            [
              [-1, -1, -1, -1],
              [-1, -1, -1, -1],
              [0, 1, 0, -1],
              [0, 0, 1, 0]
            ],
            [
              [0, 0, 1, 0],
              [-1, -1, -1, -1],
              [0, 2, -1, 0],
              [-1, -1, -1, -1]
            ],

            [
              [-1, -1, -1, -1],
              [0, 0, 1, 0],
              [0, 3, 0, 1],
              [-1, -1, -1, -1]
            ],
            [
              [13, 3, 0, 1],
              [13, 2, -1, 0],
              [7, 1, 0, -1],
              [7, 0, 1, 0]
            ],
            [
              [-1, -1, -1, -1],
              [0, 1, 0, -1],
              [-1, -1, -1, -1],
              [0, 3, 0, 1]
            ],
            [
              [0, 3, 0, 1],
              [0, 2, -1, 0],
              [-1, -1, -1, -1],
              [-1, -1, -1, -1]
            ],

            [
              [0, 3, 0, 1],
              [0, 2, -1, 0],
              [-1, -1, -1, -1],
              [-1, -1, -1, -1]
            ],
            [
              [-1, -1, -1, -1],
              [0, 1, 0, -1],
              [-1, -1, -1, -1],
              [0, 3, 0, 1]
            ],
            [
              [11, 1, 0, -1],
              [14, 0, 1, 0],
              [14, 3, 0, 1],
              [11, 2, -1, 0]
            ],
            [
              [-1, -1, -1, -1],
              [0, 0, 1, 0],
              [0, 3, 0, 1],
              [-1, -1, -1, -1]
            ],

            [
              [0, 0, 1, 0],
              [-1, -1, -1, -1],
              [0, 2, -1, 0],
              [-1, -1, -1, -1]
            ],
            [
              [-1, -1, -1, -1],
              [-1, -1, -1, -1],
              [0, 1, 0, -1],
              [0, 0, 1, 0]
            ],
            [
              [0, 1, 0, -1],
              [-1, -1, -1, -1],
              [-1, -1, -1, -1],
              [0, 2, -1, 0]
            ],
            [
              [-1, -1, -1, -1],
              [-1, -1, -1, -1],
              [-1, -1, -1, -1],
              [-1, -1, -1, -1]
            ] // arr[py][px]===15 is invalid
          ],

          // 3. Walking through an edge node array, discarding edge node types 0 and 15 and creating paths from the rest.
          // Walk directions (dir): 0 > ; 1 ^ ; 2 < ; 3 v 
          this.pathscan = function(arr, pathomit) {
            var paths = [],
              pacnt = 0,
              pcnt = 0,
              px = 0,
              py = 0,
              w = arr[0].length,
              h = arr.length,
              dir = 0,
              pathfinished = true,
              holepath = false,
              lookuprow;

            for (var j = 0; j < h; j++) {
              for (var i = 0; i < w; i++) {
                if ((arr[j][i] == 4) || (arr[j][i] == 11)) { // Other values are not valid

                  // Init
                  px = i;
                  py = j;
                  paths[pacnt] = {};
                  paths[pacnt].points = [];
                  paths[pacnt].boundingbox = [px, py, px, py];
                  paths[pacnt].holechildren = [];
                  pathfinished = false;
                  pcnt = 0;
                  holepath = (arr[j][i] == 11);
                  dir = 1;

                  // Path points loop
                  while (!pathfinished) {

                    // New path point
                    paths[pacnt].points[pcnt] = {};
                    paths[pacnt].points[pcnt].x = px - 1;
                    paths[pacnt].points[pcnt].y = py - 1;
                    paths[pacnt].points[pcnt].t = arr[py][px];

                    // Bounding box
                    if ((px - 1) < paths[pacnt].boundingbox[0]) {
                      paths[pacnt].boundingbox[0] = px - 1;
                    }
                    if ((px - 1) > paths[pacnt].boundingbox[2]) {
                      paths[pacnt].boundingbox[2] = px - 1;
                    }
                    if ((py - 1) < paths[pacnt].boundingbox[1]) {
                      paths[pacnt].boundingbox[1] = py - 1;
                    }
                    if ((py - 1) > paths[pacnt].boundingbox[3]) {
                      paths[pacnt].boundingbox[3] = py - 1;
                    }

                    // Next: look up the replacement, direction and coordinate changes = clear this cell, turn if required, walk forward
                    lookuprow = _this.pathscan_combined_lookup[arr[py][px]][dir];
                    arr[py][px] = lookuprow[0];
                    dir = lookuprow[1];
                    px += lookuprow[2];
                    py += lookuprow[3];

                    // Close path
                    if ((px - 1 === paths[pacnt].points[0].x) && (py - 1 === paths[pacnt].points[0].y)) {
                      pathfinished = true;

                      // Discarding paths shorter than pathomit
                      if (paths[pacnt].points.length < pathomit) {
                        paths.pop();
                      } else {

                        paths[pacnt].isholepath = holepath ? true : false;

                        // Finding the parent shape for this hole
                        if (holepath) {

                          var parentidx = 0,
                            parentbbox = [-1, -1, w + 1, h + 1];
                          for (var parentcnt = 0; parentcnt < pacnt; parentcnt++) {
                            if ((!paths[parentcnt].isholepath) &&
                              _this.boundingboxincludes(paths[parentcnt].boundingbox, paths[pacnt].boundingbox) &&
                              _this.boundingboxincludes(parentbbox, paths[parentcnt].boundingbox)
                            ) {
                              parentidx = parentcnt;
                              parentbbox = paths[parentcnt].boundingbox;
                            }
                          }

                          paths[parentidx].holechildren.push(pacnt);

                        } // End of holepath parent finding

                        pacnt++;

                      }

                    } // End of Close path

                    pcnt++;

                  } // End of Path points loop

                } // End of Follow path

              } // End of i loop
            } // End of j loop

            return paths;
          }, // End of pathscan()

          this.boundingboxincludes = function(parentbbox, childbbox) {
            return ((parentbbox[0] < childbbox[0]) && (parentbbox[1] < childbbox[1]) && (parentbbox[2] > childbbox[2]) && (parentbbox[3] > childbbox[3]));
          }, // End of boundingboxincludes()

          // 3. Batch pathscan
          this.batchpathscan = function(layers, pathomit) {
            var bpaths = [];
            for (var k in layers) {
              if (!layers.hasOwnProperty(k)) {
                continue;
              }
              bpaths[k] = _this.pathscan(layers[k], pathomit);
            }
            return bpaths;
          },

          // 4. interpollating between path points for nodes with 8 directions ( East, SouthEast, S, SW, W, NW, N, NE )
          this.internodes = function(paths, options) {
            var ins = [],
              palen = 0,
              nextidx = 0,
              nextidx2 = 0,
              previdx = 0,
              previdx2 = 0,
              pacnt, pcnt;

            // paths loop
            for (pacnt = 0; pacnt < paths.length; pacnt++) {

              ins[pacnt] = {};
              ins[pacnt].points = [];
              ins[pacnt].boundingbox = paths[pacnt].boundingbox;
              ins[pacnt].holechildren = paths[pacnt].holechildren;
              ins[pacnt].isholepath = paths[pacnt].isholepath;
              palen = paths[pacnt].points.length;

              // pathpoints loop
              for (pcnt = 0; pcnt < palen; pcnt++) {

                // next and previous point indexes
                nextidx = (pcnt + 1) % palen;
                nextidx2 = (pcnt + 2) % palen;
                previdx = (pcnt - 1 + palen) % palen;
                previdx2 = (pcnt - 2 + palen) % palen;

                // right angle enhance
                if (options.rightangleenhance && _this.testrightangle(paths[pacnt], previdx2, previdx, pcnt, nextidx, nextidx2)) {

                  // Fix previous direction
                  if (ins[pacnt].points.length > 0) {
                    ins[pacnt].points[ins[pacnt].points.length - 1].linesegment = _this.getdirection(
                      ins[pacnt].points[ins[pacnt].points.length - 1].x,
                      ins[pacnt].points[ins[pacnt].points.length - 1].y,
                      paths[pacnt].points[pcnt].x,
                      paths[pacnt].points[pcnt].y
                    );
                  }

                  // This corner point
                  ins[pacnt].points.push({
                    x: paths[pacnt].points[pcnt].x,
                    y: paths[pacnt].points[pcnt].y,
                    linesegment: _this.getdirection(
                      paths[pacnt].points[pcnt].x,
                      paths[pacnt].points[pcnt].y,
                      ((paths[pacnt].points[pcnt].x + paths[pacnt].points[nextidx].x) / 2),
                      ((paths[pacnt].points[pcnt].y + paths[pacnt].points[nextidx].y) / 2)
                    )
                  });

                } // End of right angle enhance

                // interpolate between two path points
                ins[pacnt].points.push({
                  x: ((paths[pacnt].points[pcnt].x + paths[pacnt].points[nextidx].x) / 2),
                  y: ((paths[pacnt].points[pcnt].y + paths[pacnt].points[nextidx].y) / 2),
                  linesegment: _this.getdirection(
                    ((paths[pacnt].points[pcnt].x + paths[pacnt].points[nextidx].x) / 2),
                    ((paths[pacnt].points[pcnt].y + paths[pacnt].points[nextidx].y) / 2),
                    ((paths[pacnt].points[nextidx].x + paths[pacnt].points[nextidx2].x) / 2),
                    ((paths[pacnt].points[nextidx].y + paths[pacnt].points[nextidx2].y) / 2)
                  )
                });

              } // End of pathpoints loop

            } // End of paths loop

            return ins;
          }, // End of internodes()

          this.testrightangle = function(path, idx1, idx2, idx3, idx4, idx5) {
            return (((path.points[idx3].x === path.points[idx1].x) &&
                (path.points[idx3].x === path.points[idx2].x) &&
                (path.points[idx3].y === path.points[idx4].y) &&
                (path.points[idx3].y === path.points[idx5].y)
              ) ||
              ((path.points[idx3].y === path.points[idx1].y) &&
                (path.points[idx3].y === path.points[idx2].y) &&
                (path.points[idx3].x === path.points[idx4].x) &&
                (path.points[idx3].x === path.points[idx5].x)
              )
            );
          }, // End of testrightangle()

          this.getdirection = function(x1, y1, x2, y2) {
            var val = 8;
            if (x1 < x2) {
              if (y1 < y2) {
                val = 1;
              } // SouthEast
              else if (y1 > y2) {
                val = 7;
              } // NE
              else {
                val = 0;
              } // E
            } else if (x1 > x2) {
              if (y1 < y2) {
                val = 3;
              } // SW
              else if (y1 > y2) {
                val = 5;
              } // NW
              else {
                val = 4;
              } // W
            } else {
              if (y1 < y2) {
                val = 2;
              } // S
              else if (y1 > y2) {
                val = 6;
              } // N
              else {
                val = 8;
              } // center, this should not happen
            }
            return val;
          }, // End of getdirection()

          // 4. Batch interpollation
          this.batchinternodes = function(bpaths, options) {
            var binternodes = [];
            for (var k in bpaths) {
              if (!bpaths.hasOwnProperty(k)) {
                continue;
              }
              binternodes[k] = _this.internodes(bpaths[k], options);
            }
            return binternodes;
          },

          // 5. tracepath() : recursively trying to fit straight and quadratic spline segments on the 8 direction internode path

          // 5.1. Find sequences of points with only 2 segment types
          // 5.2. Fit a straight line on the sequence
          // 5.3. If the straight line fails (distance error > ltres), find the point with the biggest error
          // 5.4. Fit a quadratic spline through errorpoint (project this to get controlpoint), then measure errors on every point in the sequence
          // 5.5. If the spline fails (distance error > qtres), find the point with the biggest error, set splitpoint = fitting point
          // 5.6. Split sequence and recursively apply 5.2. - 5.6. to startpoint-splitpoint and splitpoint-endpoint sequences

          this.tracepath = function(path, ltres, qtres) {
            var pcnt = 0,
              segtype1, segtype2, seqend, smp = {};
            smp.segments = [];
            smp.boundingbox = path.boundingbox;
            smp.holechildren = path.holechildren;
            smp.isholepath = path.isholepath;

            while (pcnt < path.points.length) {
              // 5.1. Find sequences of points with only 2 segment types
              segtype1 = path.points[pcnt].linesegment;
              segtype2 = -1;
              seqend = pcnt + 1;
              while (
                ((path.points[seqend].linesegment === segtype1) || (path.points[seqend].linesegment === segtype2) || (segtype2 === -1)) &&
                (seqend < path.points.length - 1)) {

                if ((path.points[seqend].linesegment !== segtype1) && (segtype2 === -1)) {
                  segtype2 = path.points[seqend].linesegment;
                }
                seqend++;

              }
              if (seqend === path.points.length - 1) {
                seqend = 0;
              }

              // 5.2. - 5.6. Split sequence and recursively apply 5.2. - 5.6. to startpoint-splitpoint and splitpoint-endpoint sequences
              smp.segments = smp.segments.concat(_this.fitseq(path, ltres, qtres, pcnt, seqend));

              // forward pcnt;
              if (seqend > 0) {
                pcnt = seqend;
              } else {
                pcnt = path.points.length;
              }

            } // End of pcnt loop

            return smp;
          }, // End of tracepath()

          // 5.2. - 5.6. recursively fitting a straight or quadratic line segment on this sequence of path nodes,
          // called from tracepath()
          this.fitseq = function(path, ltres, qtres, seqstart, seqend) {
            // return if invalid seqend
            if ((seqend > path.points.length) || (seqend < 0)) {
              return [];
            }
            // variables
            var errorpoint = seqstart,
              errorval = 0,
              curvepass = true,
              px, py, dist2;
            var tl = (seqend - seqstart);
            if (tl < 0) {
              tl += path.points.length;
            }
            var vx = (path.points[seqend].x - path.points[seqstart].x) / tl,
              vy = (path.points[seqend].y - path.points[seqstart].y) / tl;

            // 5.2. Fit a straight line on the sequence
            var pcnt = (seqstart + 1) % path.points.length,
              pl;
            while (pcnt != seqend) {
              pl = pcnt - seqstart;
              if (pl < 0) {
                pl += path.points.length;
              }
              px = path.points[seqstart].x + vx * pl;
              py = path.points[seqstart].y + vy * pl;
              dist2 = (path.points[pcnt].x - px) * (path.points[pcnt].x - px) + (path.points[pcnt].y - py) * (path.points[pcnt].y - py);
              if (dist2 > ltres) {
                curvepass = false;
              }
              if (dist2 > errorval) {
                errorpoint = pcnt;
                errorval = dist2;
              }
              pcnt = (pcnt + 1) % path.points.length;
            }
            // return straight line if fits
            if (curvepass) {
              return [{
                type: 'L',
                x1: path.points[seqstart].x,
                y1: path.points[seqstart].y,
                x2: path.points[seqend].x,
                y2: path.points[seqend].y
              }];
            }

            // 5.3. If the straight line fails (distance error>ltres), find the point with the biggest error
            var fitpoint = errorpoint;
            curvepass = true;
            errorval = 0;

            // 5.4. Fit a quadratic spline through this point, measure errors on every point in the sequence
            // helpers and projecting to get control point
            var t = (fitpoint - seqstart) / tl,
              t1 = (1 - t) * (1 - t),
              t2 = 2 * (1 - t) * t,
              t3 = t * t;
            var cpx = (t1 * path.points[seqstart].x + t3 * path.points[seqend].x - path.points[fitpoint].x) / -t2,
              cpy = (t1 * path.points[seqstart].y + t3 * path.points[seqend].y - path.points[fitpoint].y) / -t2;

            // Check every point
            pcnt = seqstart + 1;
            while (pcnt != seqend) {
              t = (pcnt - seqstart) / tl;
              t1 = (1 - t) * (1 - t);
              t2 = 2 * (1 - t) * t;
              t3 = t * t;
              px = t1 * path.points[seqstart].x + t2 * cpx + t3 * path.points[seqend].x;
              py = t1 * path.points[seqstart].y + t2 * cpy + t3 * path.points[seqend].y;

              dist2 = (path.points[pcnt].x - px) * (path.points[pcnt].x - px) + (path.points[pcnt].y - py) * (path.points[pcnt].y - py);

              if (dist2 > qtres) {
                curvepass = false;
              }
              if (dist2 > errorval) {
                errorpoint = pcnt;
                errorval = dist2;
              }
              pcnt = (pcnt + 1) % path.points.length;
            }
            // return spline if fits
            if (curvepass) {
              return [{
                type: 'Q',
                x1: path.points[seqstart].x,
                y1: path.points[seqstart].y,
                x2: cpx,
                y2: cpy,
                x3: path.points[seqend].x,
                y3: path.points[seqend].y
              }];
            }
            // 5.5. If the spline fails (distance error>qtres), find the point with the biggest error
            var splitpoint = fitpoint; // Earlier: Math.floor((fitpoint + errorpoint)/2);

            // 5.6. Split sequence and recursively apply 5.2. - 5.6. to startpoint-splitpoint and splitpoint-endpoint sequences
            return _this.fitseq(path, ltres, qtres, seqstart, splitpoint).concat(
              _this.fitseq(path, ltres, qtres, splitpoint, seqend));

          }, // End of fitseq()

          // 5. Batch tracing paths
          this.batchtracepaths = function(internodepaths, ltres, qtres) {
            var btracedpaths = [];
            for (var k in internodepaths) {
              if (!internodepaths.hasOwnProperty(k)) {
                continue;
              }
              btracedpaths.push(_this.tracepath(internodepaths[k], ltres, qtres));
            }
            return btracedpaths;
          },

          // 5. Batch tracing layers
          this.batchtracelayers = function(binternodes, ltres, qtres) {
            var btbis = [];
            for (var k in binternodes) {
              if (!binternodes.hasOwnProperty(k)) {
                continue;
              }
              btbis[k] = _this.batchtracepaths(binternodes[k], ltres, qtres);
            }
            return btbis;
          },

          ////////////////////////////////////////////////////////////
          //
          //  SVG Drawing functions
          //
          ////////////////////////////////////////////////////////////

          // Rounding to given decimals https://stackoverflow.com/questions/11832914/round-to-at-most-2-decimal-places-in-javascript
          this.roundtodec = function(val, places) {
            return +val.toFixed(places);
          },

          // Getting SVG path element string from a traced path
          this.svgpathstring = function(tracedata, lnum, pathnum, options) {

            var layer = tracedata.layers[lnum],
              smp = layer[pathnum],
              str = '',
              pcnt;

            // Line filter
            if (options.linefilter && (smp.segments.length < 3)) {
              return str;
            }

            // Starting path element, desc contains layer and path number
            str = '<path ' +
              (options.desc ? ('desc="l ' + lnum + ' p ' + pathnum + '" ') : '') +
              _this.tosvgcolorstr(tracedata.palette[lnum], options) +
              'd="';

            // Creating non-hole path string
            if (options.roundcoords === -1) {
              str += 'M ' + smp.segments[0].x1 * options.scale + ' ' + smp.segments[0].y1 * options.scale + ' ';
              for (pcnt = 0; pcnt < smp.segments.length; pcnt++) {
                str += smp.segments[pcnt].type + ' ' + smp.segments[pcnt].x2 * options.scale + ' ' + smp.segments[pcnt].y2 * options.scale + ' ';
                if (smp.segments[pcnt].hasOwnProperty('x3')) {
                  str += smp.segments[pcnt].x3 * options.scale + ' ' + smp.segments[pcnt].y3 * options.scale + ' ';
                }
              }
              str += 'Z ';
            } else {
              str += 'M ' + _this.roundtodec(smp.segments[0].x1 * options.scale, options.roundcoords) + ' ' + _this.roundtodec(smp.segments[0].y1 * options.scale, options.roundcoords) + ' ';
              for (pcnt = 0; pcnt < smp.segments.length; pcnt++) {
                str += smp.segments[pcnt].type + ' ' + _this.roundtodec(smp.segments[pcnt].x2 * options.scale, options.roundcoords) + ' ' + _this.roundtodec(smp.segments[pcnt].y2 * options.scale, options.roundcoords) + ' ';
                if (smp.segments[pcnt].hasOwnProperty('x3')) {
                  str += _this.roundtodec(smp.segments[pcnt].x3 * options.scale, options.roundcoords) + ' ' + _this.roundtodec(smp.segments[pcnt].y3 * options.scale, options.roundcoords) + ' ';
                }
              }
              str += 'Z ';
            } // End of creating non-hole path string

            // Hole children
            for (var hcnt = 0; hcnt < smp.holechildren.length; hcnt++) {
              var hsmp = layer[smp.holechildren[hcnt]];
              // Creating hole path string
              if (options.roundcoords === -1) {

                if (hsmp.segments[hsmp.segments.length - 1].hasOwnProperty('x3')) {
                  str += 'M ' + hsmp.segments[hsmp.segments.length - 1].x3 * options.scale + ' ' + hsmp.segments[hsmp.segments.length - 1].y3 * options.scale + ' ';
                } else {
                  str += 'M ' + hsmp.segments[hsmp.segments.length - 1].x2 * options.scale + ' ' + hsmp.segments[hsmp.segments.length - 1].y2 * options.scale + ' ';
                }

                for (pcnt = hsmp.segments.length - 1; pcnt >= 0; pcnt--) {
                  str += hsmp.segments[pcnt].type + ' ';
                  if (hsmp.segments[pcnt].hasOwnProperty('x3')) {
                    str += hsmp.segments[pcnt].x2 * options.scale + ' ' + hsmp.segments[pcnt].y2 * options.scale + ' ';
                  }

                  str += hsmp.segments[pcnt].x1 * options.scale + ' ' + hsmp.segments[pcnt].y1 * options.scale + ' ';
                }

              } else {

                if (hsmp.segments[hsmp.segments.length - 1].hasOwnProperty('x3')) {
                  str += 'M ' + _this.roundtodec(hsmp.segments[hsmp.segments.length - 1].x3 * options.scale) + ' ' + _this.roundtodec(hsmp.segments[hsmp.segments.length - 1].y3 * options.scale) + ' ';
                } else {
                  str += 'M ' + _this.roundtodec(hsmp.segments[hsmp.segments.length - 1].x2 * options.scale) + ' ' + _this.roundtodec(hsmp.segments[hsmp.segments.length - 1].y2 * options.scale) + ' ';
                }

                for (pcnt = hsmp.segments.length - 1; pcnt >= 0; pcnt--) {
                  str += hsmp.segments[pcnt].type + ' ';
                  if (hsmp.segments[pcnt].hasOwnProperty('x3')) {
                    str += _this.roundtodec(hsmp.segments[pcnt].x2 * options.scale) + ' ' + _this.roundtodec(hsmp.segments[pcnt].y2 * options.scale) + ' ';
                  }
                  str += _this.roundtodec(hsmp.segments[pcnt].x1 * options.scale) + ' ' + _this.roundtodec(hsmp.segments[pcnt].y1 * options.scale) + ' ';
                }


              } // End of creating hole path string

              str += 'Z '; // Close path

            } // End of holepath check

            // Closing path element
            str += '" />';

            // Rendering control points
            if (options.lcpr || options.qcpr) {
              for (pcnt = 0; pcnt < smp.segments.length; pcnt++) {
                if (smp.segments[pcnt].hasOwnProperty('x3') && options.qcpr) {
                  str += '<circle cx="' + smp.segments[pcnt].x2 * options.scale + '" cy="' + smp.segments[pcnt].y2 * options.scale + '" r="' + options.qcpr + '" fill="cyan" stroke-width="' + options.qcpr * 0.2 + '" stroke="black" />';
                  str += '<circle cx="' + smp.segments[pcnt].x3 * options.scale + '" cy="' + smp.segments[pcnt].y3 * options.scale + '" r="' + options.qcpr + '" fill="white" stroke-width="' + options.qcpr * 0.2 + '" stroke="black" />';
                  str += '<line x1="' + smp.segments[pcnt].x1 * options.scale + '" y1="' + smp.segments[pcnt].y1 * options.scale + '" x2="' + smp.segments[pcnt].x2 * options.scale + '" y2="' + smp.segments[pcnt].y2 * options.scale + '" stroke-width="' + options.qcpr * 0.2 + '" stroke="cyan" />';
                  str += '<line x1="' + smp.segments[pcnt].x2 * options.scale + '" y1="' + smp.segments[pcnt].y2 * options.scale + '" x2="' + smp.segments[pcnt].x3 * options.scale + '" y2="' + smp.segments[pcnt].y3 * options.scale + '" stroke-width="' + options.qcpr * 0.2 + '" stroke="cyan" />';
                }
                if ((!smp.segments[pcnt].hasOwnProperty('x3')) && options.lcpr) {
                  str += '<circle cx="' + smp.segments[pcnt].x2 * options.scale + '" cy="' + smp.segments[pcnt].y2 * options.scale + '" r="' + options.lcpr + '" fill="white" stroke-width="' + options.lcpr * 0.2 + '" stroke="black" />';
                }
              }

              // Hole children control points
              for (var hcnt = 0; hcnt < smp.holechildren.length; hcnt++) {
                var hsmp = layer[smp.holechildren[hcnt]];
                for (pcnt = 0; pcnt < hsmp.segments.length; pcnt++) {
                  if (hsmp.segments[pcnt].hasOwnProperty('x3') && options.qcpr) {
                    str += '<circle cx="' + hsmp.segments[pcnt].x2 * options.scale + '" cy="' + hsmp.segments[pcnt].y2 * options.scale + '" r="' + options.qcpr + '" fill="cyan" stroke-width="' + options.qcpr * 0.2 + '" stroke="black" />';
                    str += '<circle cx="' + hsmp.segments[pcnt].x3 * options.scale + '" cy="' + hsmp.segments[pcnt].y3 * options.scale + '" r="' + options.qcpr + '" fill="white" stroke-width="' + options.qcpr * 0.2 + '" stroke="black" />';
                    str += '<line x1="' + hsmp.segments[pcnt].x1 * options.scale + '" y1="' + hsmp.segments[pcnt].y1 * options.scale + '" x2="' + hsmp.segments[pcnt].x2 * options.scale + '" y2="' + hsmp.segments[pcnt].y2 * options.scale + '" stroke-width="' + options.qcpr * 0.2 + '" stroke="cyan" />';
                    str += '<line x1="' + hsmp.segments[pcnt].x2 * options.scale + '" y1="' + hsmp.segments[pcnt].y2 * options.scale + '" x2="' + hsmp.segments[pcnt].x3 * options.scale + '" y2="' + hsmp.segments[pcnt].y3 * options.scale + '" stroke-width="' + options.qcpr * 0.2 + '" stroke="cyan" />';
                  }
                  if ((!hsmp.segments[pcnt].hasOwnProperty('x3')) && options.lcpr) {
                    str += '<circle cx="' + hsmp.segments[pcnt].x2 * options.scale + '" cy="' + hsmp.segments[pcnt].y2 * options.scale + '" r="' + options.lcpr + '" fill="white" stroke-width="' + options.lcpr * 0.2 + '" stroke="black" />';
                  }
                }
              }
            } // End of Rendering control points

            return str;

          }, // End of svgpathstring()

          // Converting tracedata to an SVG string
          this.getsvgstring = function(tracedata, options) {

            options = _this.checkoptions(options);

            var w = tracedata.width * options.scale,
              h = tracedata.height * options.scale;

            // SVG start
            var svgstr = '<svg ' + (options.viewbox ? ('viewBox="0 0 ' + w + ' ' + h + '" ') : ('width="' + w + '" height="' + h + '" ')) +
              'version="1.1" xmlns="http://www.w3.org/2000/svg" desc="Created with imagetracer.js version ' + _this.versionnumber + '" >';

            // Drawing: Layers and Paths loops
            for (var lcnt = 0; lcnt < tracedata.layers.length; lcnt++) {
              for (var pcnt = 0; pcnt < tracedata.layers[lcnt].length; pcnt++) {

                // Adding SVG <path> string
                if (!tracedata.layers[lcnt][pcnt].isholepath) {
                  svgstr += _this.svgpathstring(tracedata, lcnt, pcnt, options);
                }

              } // End of paths loop
            } // End of layers loop

            // SVG End
            svgstr += '</svg>';

            return svgstr;

          }, // End of getsvgstring()

          // Comparator for numeric Array.sort
          this.compareNumbers = function(a, b) {
            return a - b;
          },

          // Convert color object to rgba string
          this.torgbastr = function(c) {
            return 'rgba(' + c.r + ',' + c.g + ',' + c.b + ',' + c.a + ')';
          },

          // Convert color object to SVG color string
          this.tosvgcolorstr = function(c, options) {
            return 'fill="rgb(' + c.r + ',' + c.g + ',' + c.b + ')" stroke="rgb(' + c.r + ',' + c.g + ',' + c.b + ')" stroke-width="' + options.strokewidth + '" opacity="' + c.a / 255.0 + '" ';
          },

          // Helper function: Appending an <svg> element to a container from an svgstring
          this.appendSVGString = function(svgstr, parentid) {
            var div;
            if (parentid) {
              div = document.getElementById(parentid);
              if (!div) {
                div = document.createElement('div');
                div.id = parentid;
                document.body.appendChild(div);
              }
            } else {
              div = document.createElement('div');
              document.body.appendChild(div);
            }
            div.innerHTML += svgstr;
          },

          ////////////////////////////////////////////////////////////
          //
          //  Canvas functions
          //
          ////////////////////////////////////////////////////////////

          // Gaussian kernels for blur
          this.gks = [
            [0.27901, 0.44198, 0.27901],
            [0.135336, 0.228569, 0.272192, 0.228569, 0.135336],
            [0.086776, 0.136394, 0.178908, 0.195843, 0.178908, 0.136394, 0.086776],
            [0.063327, 0.093095, 0.122589, 0.144599, 0.152781, 0.144599, 0.122589, 0.093095, 0.063327],
            [0.049692, 0.069304, 0.089767, 0.107988, 0.120651, 0.125194, 0.120651, 0.107988, 0.089767, 0.069304, 0.049692]
          ],

          // Selective Gaussian blur for preprocessing
          this.blur = function(imgd, radius, delta) {
            var i, j, k, d, idx, racc, gacc, bacc, aacc, wacc;

            // new ImageData
            var imgd2 = {
              width: imgd.width,
              height: imgd.height,
              data: []
            };

            // radius and delta limits, this kernel
            radius = Math.floor(radius);
            if (radius < 1) {
              return imgd;
            }
            if (radius > 5) {
              radius = 5;
            }
            delta = Math.abs(delta);
            if (delta > 1024) {
              delta = 1024;
            }
            var thisgk = _this.gks[radius - 1];

            // loop through all pixels, horizontal blur
            for (j = 0; j < imgd.height; j++) {
              for (i = 0; i < imgd.width; i++) {

                racc = 0;
                gacc = 0;
                bacc = 0;
                aacc = 0;
                wacc = 0;
                // gauss kernel loop
                for (k = -radius; k < radius + 1; k++) {
                  // add weighted color values
                  if ((i + k > 0) && (i + k < imgd.width)) {
                    idx = (j * imgd.width + i + k) * 4;
                    racc += imgd.data[idx] * thisgk[k + radius];
                    gacc += imgd.data[idx + 1] * thisgk[k + radius];
                    bacc += imgd.data[idx + 2] * thisgk[k + radius];
                    aacc += imgd.data[idx + 3] * thisgk[k + radius];
                    wacc += thisgk[k + radius];
                  }
                }
                // The new pixel
                idx = (j * imgd.width + i) * 4;
                imgd2.data[idx] = Math.floor(racc / wacc);
                imgd2.data[idx + 1] = Math.floor(gacc / wacc);
                imgd2.data[idx + 2] = Math.floor(bacc / wacc);
                imgd2.data[idx + 3] = Math.floor(aacc / wacc);

              } // End of width loop
            } // End of horizontal blur

            // copying the half blurred imgd2
            var himgd = new Uint8ClampedArray(imgd2.data);

            // loop through all pixels, vertical blur
            for (j = 0; j < imgd.height; j++) {
              for (i = 0; i < imgd.width; i++) {

                racc = 0;
                gacc = 0;
                bacc = 0;
                aacc = 0;
                wacc = 0;
                // gauss kernel loop
                for (k = -radius; k < radius + 1; k++) {
                  // add weighted color values
                  if ((j + k > 0) && (j + k < imgd.height)) {
                    idx = ((j + k) * imgd.width + i) * 4;
                    racc += himgd[idx] * thisgk[k + radius];
                    gacc += himgd[idx + 1] * thisgk[k + radius];
                    bacc += himgd[idx + 2] * thisgk[k + radius];
                    aacc += himgd[idx + 3] * thisgk[k + radius];
                    wacc += thisgk[k + radius];
                  }
                }
                // The new pixel
                idx = (j * imgd.width + i) * 4;
                imgd2.data[idx] = Math.floor(racc / wacc);
                imgd2.data[idx + 1] = Math.floor(gacc / wacc);
                imgd2.data[idx + 2] = Math.floor(bacc / wacc);
                imgd2.data[idx + 3] = Math.floor(aacc / wacc);

              } // End of width loop
            } // End of vertical blur

            // Selective blur: loop through all pixels
            for (j = 0; j < imgd.height; j++) {
              for (i = 0; i < imgd.width; i++) {

                idx = (j * imgd.width + i) * 4;
                // d is the difference between the blurred and the original pixel
                d = Math.abs(imgd2.data[idx] - imgd.data[idx]) + Math.abs(imgd2.data[idx + 1] - imgd.data[idx + 1]) +
                  Math.abs(imgd2.data[idx + 2] - imgd.data[idx + 2]) + Math.abs(imgd2.data[idx + 3] - imgd.data[idx + 3]);
                // selective blur: if d>delta, put the original pixel back
                if (d > delta) {
                  imgd2.data[idx] = imgd.data[idx];
                  imgd2.data[idx + 1] = imgd.data[idx + 1];
                  imgd2.data[idx + 2] = imgd.data[idx + 2];
                  imgd2.data[idx + 3] = imgd.data[idx + 3];
                }
              }
            } // End of Selective blur

            return imgd2;

          }, // End of blur()

          // Helper function: loading an image from a URL, then executing callback with canvas as argument
          this.loadImage = function(url, callback, options) {
            var img = new Image();
            if (options && options.corsenabled) {
              img.crossOrigin = 'Anonymous';
            }
            img.onload = function() {
              var canvas = document.createElement('canvas');
              canvas.width = img.width;
              canvas.height = img.height;
              var context = canvas.getContext('2d');
              context.drawImage(img, 0, 0);
              callback(canvas);
            };
            img.src = url;
          },

          // Helper function: getting ImageData from a canvas
          this.getImgdata = function(canvas) {
            var context = canvas.getContext('2d');
            return context.getImageData(0, 0, canvas.width, canvas.height);
          },

          // Special palette to use with drawlayers()
          this.specpalette = [{
              r: 0,
              g: 0,
              b: 0,
              a: 255
            }, {
              r: 128,
              g: 128,
              b: 128,
              a: 255
            }, {
              r: 0,
              g: 0,
              b: 128,
              a: 255
            }, {
              r: 64,
              g: 64,
              b: 128,
              a: 255
            },
            {
              r: 192,
              g: 192,
              b: 192,
              a: 255
            }, {
              r: 255,
              g: 255,
              b: 255,
              a: 255
            }, {
              r: 128,
              g: 128,
              b: 192,
              a: 255
            }, {
              r: 0,
              g: 0,
              b: 192,
              a: 255
            },
            {
              r: 128,
              g: 0,
              b: 0,
              a: 255
            }, {
              r: 128,
              g: 64,
              b: 64,
              a: 255
            }, {
              r: 128,
              g: 0,
              b: 128,
              a: 255
            }, {
              r: 168,
              g: 168,
              b: 168,
              a: 255
            },
            {
              r: 192,
              g: 128,
              b: 128,
              a: 255
            }, {
              r: 192,
              g: 0,
              b: 0,
              a: 255
            }, {
              r: 255,
              g: 255,
              b: 255,
              a: 255
            }, {
              r: 0,
              g: 128,
              b: 0,
              a: 255
            }
          ],

          // Helper function: Drawing all edge node layers into a container
          this.drawLayers = function(layers, palette, scale, parentid) {
            scale = scale || 1;
            var w, h, i, j, k;

            // Preparing container
            var div;
            if (parentid) {
              div = document.getElementById(parentid);
              if (!div) {
                div = document.createElement('div');
                div.id = parentid;
                document.body.appendChild(div);
              }
            } else {
              div = document.createElement('div');
              document.body.appendChild(div);
            }

            // Layers loop
            for (k in layers) {
              if (!layers.hasOwnProperty(k)) {
                continue;
              }

              // width, height
              w = layers[k][0].length;
              h = layers[k].length;

              // Creating new canvas for every layer
              var canvas = document.createElement('canvas');
              canvas.width = w * scale;
              canvas.height = h * scale;
              var context = canvas.getContext('2d');

              // Drawing
              for (j = 0; j < h; j++) {
                for (i = 0; i < w; i++) {
                  context.fillStyle = _this.torgbastr(palette[layers[k][j][i] % palette.length]);
                  context.fillRect(i * scale, j * scale, scale, scale);
                }
              }

              // Appending canvas to container
              div.appendChild(canvas);
            } // End of Layers loop
          } // End of drawlayers

        ; // End of function list

      } // End of ImageTracer object

      // export as AMD module / Node module / browser or worker variable
      if (typeof define === 'function' && define.amd) {
        define(function() {
          return new ImageTracer();
        });
      } else if (typeof module !== 'undefined') {
        module.exports = new ImageTracer();
      } else if (typeof self !== 'undefined') {
        self.ImageTracer = new ImageTracer();
      } else window.ImageTracer = new ImageTracer();

    })();
  </script>
  <script>
    const tabs = document.querySelectorAll("section.xp-tabs > menu[role=tablist]");

    for (let i = 0; i < tabs.length; i++) {
      const tab = tabs[i];

      const tabButtons = tab.querySelectorAll("menu[role=tablist] > button");

      tabButtons.forEach((btn) =>
        btn.addEventListener("click", (e) => {
          e.preventDefault();

          tabButtons.forEach((button) => {
            if (
              button.getAttribute("aria-controls") ===
              e.target.getAttribute("aria-controls")
            ) {
              button.setAttribute("aria-selected", true);
              openTab(e, tab);
            } else {
              button.setAttribute("aria-selected", false);
            }
          });
        })
      );
    }

    function openTab(event, tab) {
      const articles = tab.parentNode.querySelectorAll('[role="tabpanel"]');
      articles.forEach((p) => {
        p.setAttribute("hidden", true);
      });
      const article = tab.parentNode.querySelector(
        `[role="tabpanel"]#${event.target.getAttribute("aria-controls")}`
      );
      article.removeAttribute("hidden");
    }
  </script>

  <script>
    const AIRBRUSH = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAEZ0FNQQAAsY58+1GTAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAACySURBVHja7JVLDsMwCERnLsH9z4cPQReVW0KJo6pYVSuyyUeC9zIxDs0M3zzYAi3QAi3wEwIiYqrKeXbPno1IZrVX/S8FIlxEHgVjjAMok/hIIIOrKiZn1vr7KFGeAAAjeYDHay9RmsDs6UAvkCixLYHw7U8ldiSAdyQAsCSBbMJWEiUCiwSWEn4iytZAWnx/S4vjX7YIV/Aw/3a2F2xPwIEs25K3JtC/4xZogRb4C4HbAO4FMdAaEd3JAAAAAElFTkSuQmCC";
    const DEFAULT = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAATCAMAAABx9wfiAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAwBQTFRFAAAAAQEB9vb2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1UuVOAAAAQB0Uk5T////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////AFP3ByUAAAAZdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41Ljg3O4BdAAAAQUlEQVQI123OMRIAMQjDQIn//9lXkBCKo1oVngEzBzxbLk9gTWBNtDuOy+VyubwGEKt8W3MCyNjkRn+53fHjaPIBe1VoNGgfpQkAAAAASUVORK5CYII=";
    const EW_RESIZE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAdUlEQVR42u3UQQ6AIAxEUbn/oYUaSEhjSsFIWfyuWIzjg4jpCp4EAAAAAABmwneZ56EyXzJLACmWTukfATy5KUArrWsXwJN1AfrCVjrclcpbCBOgX746FuLsE3hDbP8GdHHILejL6xHv/w/8NQAAAAAAIByQAcHUYyEouqD8AAAAAElFTkSuQmCC";
    const EYE_DROPPER = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAj0lEQVR42u3S4QqAMAhG0fb+D10bzCGB6Ge6Qei/qHYPVrsOTytAAQrwK8DdZx3cZytgxHlzWCyIEADFZxRCfALQyqVGKuC98u0ADZH+D0jfHYm7ATy+Dpo9JO4CSHHaRCpAibd5HzrT/LAWRzcJAbLiJkBm3AWIjEMAdh0WNwEIsV4IjJsBmVOAAhTgOOABF9yMIbrIumgAAAAASUVORK5CYII=";
    const FILL_BUCKET = "data:image/png;base64,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";
    const MAGNIFIER = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAkUlEQVR42u3W0QqAIAwFUP3/jy4LL6zlwzamSdw9RczdQxlWy8dVCSCAgMiio9VjSKslAATrPHgiEPOCKxzz1QMo8r4XYWpGuA5+Des9HsT+AGt4FEHA/gAP4p9fgUb062G46M19BRKhw1SoG5FyGAEVQaQdx3KfeBCp/wMjxFKARFjCpwCAuIfP2oSZRQABBJzq7KIhVD+0cwAAAABJRU5ErkJggg==";
    const MOVE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAoElEQVR42u2WSw7AIAhEy/0P3WqjZkpATVXYMBsTQphnwA9dA91JeaWkUe4fdYtm8+qbOU5AqAXRHGLbIcRikvkpCBWgJUALIHYGgA+cNgM7B7MVqGbcSAPguUsA3OiTMBFfgaDewM1qBcIfoBTwawHswm8IEaLszv4YSiBaC0xuQterWIMwe4wkCPPnGCHeRI8PiYUCIAACIAACIADcAR5o8rAhPFrPbwAAAABJRU5ErkJggg==";
    const NESW_RESIZE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAdklEQVR42u3TwQrAIAwDUPv/Hz0dOBBpD9osvaQnBWmeUq0VlwkggAACZBs8o8LmoygAL+d1UQARggrwECUvMEO5gC3c9j0M8E372jQK885CAJmbwgBz3RDh14AFkZ6hawAKkQIgEMe/wG3CAPxVAggggADlgA7e2HEhSEEUUAAAAABJRU5ErkJggg==";
    const NS_RESIZE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAeUlEQVR42u3W0QqAIAwFUPf/H50LDHS0YC69D969hMFlh5imFHAJAQQQkAlfWqIFAbTm97NkEFPBp3m3nkaEQ7Z5FhEKeM0ziDBgCLcZMO/WAd6+BmQICTgXAN8F8HPgC7HlJPQQW/8FFgHbBR0Ccx/4qwgggAA4oAKbBnEhV7iENgAAAABJRU5ErkJggg==";
    const NWSE_RESIZE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAdElEQVR42u3SywpAIQgE0Nv/f/TtQYGIQmSNm3GXSHOwypdchQACCCBgZ+hv5V7QCgKwcrorDXAj/BhwK/wIMMNzNrBC9RkCGMMizENYs2HAy82E31CFrh4OIBHijN+A6mH/gNHHAdyLkX8gUgQQQAAB6YAKovZxIcvQ8F4AAAAASUVORK5CYII=";
    const PENCIL = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAhElEQVR42u3WwQ6AIAwDUPj/j1ZInOkR24KBbDc52Ndx0Fp+npqABCTgGMDV5n1pm6WAHo6Z3TKKkAERDgso8TyC2BuAqw/Al3Ab4AnE8/kAdfV2AF7FdICrvQ3AtqcAzvYSABrT7WUAnFHhFoASLgPUcAngCKcAgLB8ys/5I0pAArYF3BnMjyGREgE3AAAAAElFTkSuQmCC";
    const PRECISE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAYUlEQVR42u3TQQ7AIAhEUef+h24lXbYlEDXU9LPRheCDqFpxCACArQFHD0m2NtkGAAAAvwOYYbTWa5J15yZeDSuR8jglT+1Xu+dnz39/ApFY9wZCt1f/AgAAAJQDZgQAACep+IQhsONPEQAAAABJRU5ErkJggg==";
    const PRECISE2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAfElEQVR42u3USw6AIAwE0Pb+h0YaPxmrxQVYFkxXCMQ+JqhKo0qtc6y15IdqvtQA1tccBKwFcJdP4HE4JARAHxuUY348AE97W9j7YLNoaxdK3Wm/0nkIelOZn8DbZOodiACYRPpX4JNY70dEAAKujTMAGUUAAQQQQAABBGz0e3YhJX56ngAAAABJRU5ErkJggg==";
    const PRECISE_DOTTED = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAVUlEQVR42u2TQQoAIAgE9f+PNr11MSEEC2YvXkRmh1IZjgIAwM8A1lHg+oB51IMBDGBg0kBLMoAoKFEwmbovHvbKks8aKPPCG+AXYAADswa6AgAAACyfOUIhYlXMsQAAAABJRU5ErkJggg==";
  </script>
  <script>
    function getHelpIconByName(iconName) {
      switch (iconName) {
        case 'p_blank.png':
          return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAALCAYAAACgR9dcAAAARUlEQVQoU2M8cODAfwYyASNM844dO4gyoqOjg+HAgQNgtSia29vbCRrAyMg4qhkUSqDQHpgAc3BwIBhNMAUY8Uy0TiSFAKZ/VsGhSQJXAAAAAElFTkSuQmCC';
        case 'p_cut.png':
          return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAALCAYAAACgR9dcAAAAZUlEQVQoU2M8cODAfwYocHBwYDhw4ACMi0Jjk2OkmmaQVdhswOUiFJsp1oxuAL5wwLAZOfBAbFwBCJKjnmYvhx3w6Nl2wAPMxiYGUwS3GaQIWQMhNoqzKdKM7ESYrTDnwZyOLg4Aw0RrwalBiDoAAAAASUVORK5CYII=';
        case 'p_database.png':
          return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAALCAYAAACgR9dcAAAAVElEQVQoU2M8cODAfwYyASOyZgcHB4LGHDhwAK4Grhmu8T83AwPjVwYGXDQDAwPMAOpo3rFjB0NHRwdBZ1dUVDB4eHiA1VHHZor8PESdDQo9UhMJAJDGd8HREq0CAAAAAElFTkSuQmCC';
        case 'p_delete.png':
          return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAALCAYAAACgR9dcAAAAZ0lEQVQoU2M8cODA/53ODgwg4L73AJjGBdDVMSJrhmnCZgg2C8CaYZpgCtBdgctlKJrRDQG5AJ+XsGoGGYLLFcjhgddmfGEAksPQjG4j0c4mO8AI+RFvVBHSjByIsHSAEc/EpDKYGgBLS1/BdOKnvgAAAABJRU5ErkJggg==';
        case 'p_fliph.png':
          return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAALCAYAAABPhbxiAAAAaklEQVQoU6WSQQ7AIAgEd32ZT+dlpYGEFtE2jfViVIaJrhQRxcZgBXvv3kZEfK7rcAygFakqSI7goUC79wz+D4bNu62MdpCsl3ELzNCrMVnduAUC9pBjlI93jCwaQQNX+dcca830Ab5+ohMsuHJBMuzatQAAAABJRU5ErkJggg==';
        case 'p_flipv.png':
          return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAALCAYAAACgR9dcAAAAYklEQVQoU5WSUQ7AIAhDrSfj6D3ZWLaocQNB/dGYvNekAJJa2hGR90Wyf4U3/rCqFgBbEhfucZkkhDPJFjxL5j4MnDUVw9co33oqPpOwyR5c/fZjeAGNDsySPMkJtIYPNuwGWoBYwVUb2zoAAAAASUVORK5CYII=';
        case 'p_invert.png':
          return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAALCAYAAABPhbxiAAAAUklEQVQoU83SywkAMQgEUKcyW5/OXEIQZCJs8BSPwSfxA5Jhg8CC7t5SAO07SWthgoj9GS3QwpqUUPEBtXKFFT8AtZfrHnP2o6nWxf3ucXA49gGnL1PBCvT0xAAAAABJRU5ErkJggg==';
        case 'p_make_opaque.png':
          return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAALCAYAAACgR9dcAAAAfUlEQVQoU2M8cODAfwYyASNIs729PYp2jkYhDOMqGfIZ6uvr4eIHDx5kwNCMTeNOh/UMDg4ODP//IxyJoRmk8Uf9OwxbQeI/G94Tp1mKQR/FgHeNj4ey5oaGBrB3QKGOM8DQ/fyc8RIDskaQARiaGRkZsSYXdI0omslMYAwAaUeHwVEQSZ4AAAAASUVORK5CYII=';
        case 'p_monochrome.png':
          return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAALCAYAAABPhbxiAAAAK0lEQVQoU2M8cODAfwYyACNIo729PVatjIyMWMUPHDjAMKpxGAUOGQmHAQANuD7BTKbtDwAAAABJRU5ErkJggg==';
        case 'p_monochrome_undo.png':
          return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAALCAYAAABPhbxiAAAAP0lEQVQoU2M8cODAfwYyACNIo72fA0RrvhnD76ZLYCYbAzMDQ9V3MJurvQxMFzJA7HA94MkwqnEYBQ4ZCYcBAOe2dMHCuE3cAAAAAElFTkSuQmCC';
        case 'p_paste.png':
          return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAALCAYAAACgR9dcAAAAjUlEQVQoU52SOxKAIAxEk8I7WXIqCw9A4alSeicLnGVmNWB0GNNAIG+zfNTMirhIKflUzKzJfaKEPXSUtdZMmq/aSKTCAJd1li3vApAQ59zrBULYW4PQEPx6OJHq6rOzh1EchRdobPdwKfdDqKogx0iBYRjCABG/YAo0MBb7z4E1b5tHetiOLiYSYx07n+XLesEeENAlAAAAAElFTkSuQmCC';
        case 'p_rotate_ccw.png':
          return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAALCAYAAACgR9dcAAAAaUlEQVQoU52S2wnAMAhF42TpBB22E5jJWiwI18ctofkK6jmKiajqPX4eYfA8j6Jcl4ZYC3egUygoMIJY2MUpnEe0zi7w3AvvjtnCaMWN5O4UzgIGWl0YG7uZnS0KQbvTd3Yh2/4W/PX5Hj2RUMEYjL2KAAAAAElFTkSuQmCC';
        case 'p_rotate_ccw_thin.png':
          return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAALCAYAAACgR9dcAAAAXklEQVQoU2M8cODAfwYyASMuzfZ+DhhGHtx0AEUMq2aQRnSFIF3o4hiacWmEWYksT7lmbP6D2YTufKw2ExNA6P5GcTayAdgCDK9mbCGKHDcEQxs9cvG5BmciISbRAQBJQ1PBcGdLDQAAAABJRU5ErkJggg==';
        case 'p_rotate_cw.png':
          return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAALCAYAAACgR9dcAAAAYElEQVQoU2M8cODAfwYyASO6Zns/BwyjDm46gNV4FM3YNMJ0YTMArhlZI7JCXOIgQzE0Y7MBZgC6HF7NhLxB0GZ8AUjQzyC/4fI33tBGDzicfoZFCb7QRY9sjERCSmIDAFGgUMFdh6GeAAAAAElFTkSuQmCC';
        case 'p_rotate_cw_thin.png':
          return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAALCAYAAACgR9dcAAAAW0lEQVQoU2M8cODAfwYyASO6Zns/BwyjDm46gNV4FM0gjdgU4hKHa8alAGYlNnnaacbmf5hLQN4jaDO+ACSoGWQTsgHIAUpUaMMMQI8JvPGMK35h/sbQTEpiAwDJUlPBmPM/9wAAAABJRU5ErkJggg==';
        case 'p_skew_h.png':
          return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAALCAYAAACgR9dcAAAAdklEQVQoU6WSQQ6AIAwE25fJs/DEUZ7EcX2ZpoaSFCuB2AuBZbrbAAO4qNYWAp2Abs3qaaywiFIjuNcfWEHX0jlUg//OXzOXUprvkTPtMZoczblPB4BSSp+TMDO58Awod17wLCiRDLwCGngVbHCoH2T0ztK8rxsI3F+pRiMa+AAAAABJRU5ErkJggg==';
        case 'p_skew_v.png':
          return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAAKCAYAAABrGwT5AAAAgklEQVQoU7WSwRWAIAxD0wVcCSZwJTqTE5SVXEBfeRYrVj2ZC5f+pARIRDYEEhEwM/R8Eo2wDZdSQEQXOM0ZdTnNOuwhS/KwglgBTOgGxMxtbU0aZXAHbeAwaHAE6txt7ZxRXQf/wJqq8m2nr+QQsrKe7hxBvsCwbQCt7bfPYCbjO+98L2OB1Tjj7gAAAABJRU5ErkJggg==';
        case 'p_stretch_both.png':
          return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAALCAYAAACgR9dcAAAAcUlEQVQoU9VRQQ6AIAxrXyY/2/zZfJmmJJhBSNB4sqdlo2tZGREnAGyl4IhQeWPWy3OKrEfCjDzrtwU8gaq8Qluc3bxSbg6bG7p7VTZ37O6dgdxTPaKSzWzlGiQREd1hf0AG+e3POVNFp3WPcpbseLALbmZdP2pGMNkAAAAASUVORK5CYII=';
        case 'p_stretch_h.png':
          return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAALCAYAAACgR9dcAAAAY0lEQVQoU+WS0QnAMAhEdbK6mdfNrpO1KE2QJoVAP+uXXHyeEZXkKSU2MznIKmU+07XCURDxBj/fOtzAwXIitObfnVn+6IDswOBXdQASTDpH4u4rE2eNqv4btvs4ljcmkgu7AN0AZcGAsiPdAAAAAElFTkSuQmCC';
        case 'p_stretch_v.png':
          return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAALCAYAAACgR9dcAAAAaUlEQVQoU+2S0Q2AMAhEjwVcqUzgSmUmJ6AruYCmTUGiMTKAfALvIHCkqgeSUVZG29S7qcOqVyLqiAis1kHsABa4gMO11sd8Ihqwg9YxBVKwMYUZLWz5w7d7p67NzK82+fxz0mDj39FhJ5vTe8FZ//UEAAAAAElFTkSuQmCC';
        case 'p_airb.gif':
          return 'data:image/gif;base64,R0lGODdhDwAKAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwAKAAAISAARICAwsKDAgwcJKiQAoCHChAIBHHjwwCFChQgAUATAgAGAhwQzHgBAoKNHiCFJejT5UWDIiCU5njSIUKVFlw8zMryYMyLCgAA7';
        case 'p_brush.gif':
          return 'data:image/gif;base64,R0lGODdhDwALAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwALAAAIOQARCByIAADBgwQBDDCI8KBChg0HPowo8SFEhAoHaFwYEYDHjxcTOuz44EDJByElnjSZsiDIjwQDAgA7';
        case 'p_curve.gif':
          return 'data:image/gif;base64,R0lGODdhDwALAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwALAAAIKAARCBxIsKBBAAAMKkSAcOHBAw4JAoAYkWHCig0rHriokSNGjxUVBgQAOw==';
        case 'p_erase.gif':
          return 'data:image/gif;base64,R0lGODdhDwALAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwALAAAIPgARCBxIsKBBBAASJjwoEMCDBQ8XADjoEOICiRMLVowIYEDGgRsvdvRIMKTEASRLlkT5EeTKliUVLmRIc2BAADs=';
        case 'p_eye.gif':
          return 'data:image/gif;base64,R0lGODdhDwALAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwALAAAIOgARCBxIEIBBgggFHjyYEIHBhwwbQgTQUOGDAxETAnjwgCJFiRw/VtzYsaLFkhUNGHioUmXDli0bBgQAOw==';
        case 'p_free.gif':
          return 'data:image/gif;base64,R0lGODdhDwALAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwALAAAIMwARCBQIYKDBgwIPFCSIcGDBhwcaHnwoEcHCigwNXtTYcKNFhQ4RHACJkCJGkR4lphwYEAA7';
        case 'p_line.gif':
          return 'data:image/gif;base64,R0lGODdhDwALAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwALAAAIJgARCBxIsKBAAAAMKkSAcKHBhg4JQox4MCHFihcxZpxIkWNGBAEBADs=';
        case 'p_opaq.gif':
          return 'data:image/gif;base64,R0lGODdhGgAQAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAGgAQAAAIwgABCBxIsGBBAggTAljAsKHDhw0BJFTY8ADCAw8FLtAI4IHABxYXLkBAgAEDAhgZdnzAsqVLiSIJIDCJQORGlwJyCkDQkkBMBEB9Omypc+dKmAxlmhSqkqUAnCsfMFV60uZKAQqyKhBwdOrMqkCBOn2glWvPn0sRNEjw8QHWsgAOHEC6gKraBHivks0aV65UkRYRIsBLmGVBuQc8Ml0gF8DdvC4jn4UIdK3jmgszD1Rs0yECxANCI4g4EaHB06dLEwgIADs=';
        case 'p_oval.gif':
          return 'data:image/gif;base64,R0lGODdhDwALAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwALAAAIMAARCBxIsGBBAAgRGhSokGDDgQAWMoQokSKCiBUvTsyIUaPEjgxBXhQJMSHJjAQDAgA7';
        case 'p_paint.gif':
          return 'data:image/gif;base64,R0lGODdhDwALAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwALAAAIRgARCByIAAAAgggNFnxwEKFAhQAeMARwAOGBgxEZSlQ40KBHAyA9NizYEEDIjyVLGhAZ8uFIlis7jiTZkuDMghcd3iyIMCAAOw==';
        case 'p_pencil.gif':
          return 'data:image/gif;base64,R0lGODdhDwALAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwALAAAINQARCBw4EAAAgggLBnhwMCFBAAEaOhQIYAECiRMrYnRY8eLEggw/UrS4MSGAAyVNpkx44GNAADs=';
        case 'p_poly.gif':
          return 'data:image/gif;base64,R0lGODdhDwALAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwALAAAILQARCBxIsGBBAAgTGhwIgGDDhQ8FRjQYceJBhgsxSkxo0aLGjxcdchyZsSSCgAA7';
        case 'p_rect.gif':
          return 'data:image/gif;base64,R0lGODdhDwALAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwALAAAILQARCBxIsKBAAAgTKgRAkKHBgw0fQhzo8GFFBBcLXswYkaJEjB0tNly48KPEgAA7';
        case 'p_rrect.gif':
          return 'data:image/gif;base64,R0lGODdhDwALAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwALAAAINQARCBxIsODAAwASKgRwoOCBhgYfEgRgcCBFixUFXtSYEcFGjx0/fiz4UWJEiAcXKkTZ0WBAADs=';
        case 'p_sel.gif':
          return 'data:image/gif;base64,R0lGODdhDwALAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwALAAAIKgARCBxIsKBAAAgQKkzIcCBCgwchSiT4EGLFiRYnXsRYcCPFjwtDcjQYEAA7';
        case 'p_trans.gif':
          return 'data:image/gif;base64,R0lGODdhGgAQAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAGgAQAAAItwABCBxIsGBBAggTAljAsKHDhw0BJFTY8ADCAw8FLtAoUSCBjgwREGDAgABGhgszTgS5gAACkghSbnQooKYAkRRbItj5EeICmzctfuypkyTRmT8fKH0gQCjClC6NykwpQIFVBU2fEo1aUmJChgIeXM2ak6vLBgkkgr2KVShLrgjQJkhLIOlVp08ZOkUwd67agwqPHjgAIG5ftQ69roR4dmjMhQSHsnw4ePCAywgiTnxqsLPBzQQCAgA7';
        case 'p_txt.gif':
          return 'data:image/gif;base64,R0lGODdhDwALAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwALAAAINQARCBxIsKBBBAAAHDSY8MDCgQkTPhSoUOJDAA4PWDyokGJHgxojRuRIMCTIjx5RhvwoUmFAADs=';
        case 'p_zoom.gif':
          return 'data:image/gif;base64,R0lGODlhDwALAPIEAAAAAAkHvICAgMDAwP///////wAAAAAAACH5BAEAAAUALAAAAAAPAAsAAAMkODrQvVABQmWUFYI7uf/axYALEIibQghBKwrO2Z7iIru1cg8JADs=';
        case 'p_airb.gif':
          return 'data:image/gif;base64,R0lGODdhDwAKAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwAKAAAISAARICAwsKDAgwcJKiQAoCHChAIBHHjwwCFChQgAUATAgAGAhwQzHgBAoKNHiCFJejT5UWDIiCU5njSIUKVFlw8zMryYMyLCgAA7';
        case 'p_brush.gif':
          return 'data:image/gif;base64,R0lGODdhDwALAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwALAAAIOQARCByIAADBgwQBDDCI8KBChg0HPowo8SFEhAoHaFwYEYDHjxcTOuz44EDJByElnjSZsiDIjwQDAgA7';
        case 'p_curve.gif':
          return 'data:image/gif;base64,R0lGODdhDwALAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwALAAAIKAARCBxIsKBBAAAMKkSAcOHBAw4JAoAYkWHCig0rHriokSNGjxUVBgQAOw==';
        case 'p_erase.gif':
          return 'data:image/gif;base64,R0lGODdhDwALAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwALAAAIPgARCBxIsKBBBAASJjwoEMCDBQ8XADjoEOICiRMLVowIYEDGgRsvdvRIMKTEASRLlkT5EeTKliUVLmRIc2BAADs=';
        case 'p_eye.gif':
          return 'data:image/gif;base64,R0lGODdhDwALAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwALAAAIOgARCBxIEIBBgggFHjyYEIHBhwwbQgTQUOGDAxETAnjwgCJFiRw/VtzYsaLFkhUNGHioUmXDli0bBgQAOw==';
        case 'p_free.gif':
          return 'data:image/gif;base64,R0lGODdhDwALAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwALAAAIMwARCBQIYKDBgwIPFCSIcGDBhwcaHnwoEcHCigwNXtTYcKNFhQ4RHACJkCJGkR4lphwYEAA7';
        case 'p_line.gif':
          return 'data:image/gif;base64,R0lGODdhDwALAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwALAAAIJgARCBxIsKBAAAAMKkSAcKHBhg4JQox4MCHFihcxZpxIkWNGBAEBADs=';
        case 'p_opaq.gif':
          return 'data:image/gif;base64,R0lGODdhGgAQAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAGgAQAAAIwgABCBxIsGBBAggTAljAsKHDhw0BJFTY8ADCAw8FLtAI4IHABxYXLkBAgAEDAhgZdnzAsqVLiSIJIDCJQORGlwJyCkDQkkBMBEB9Omypc+dKmAxlmhSqkqUAnCsfMFV60uZKAQqyKhBwdOrMqkCBOn2glWvPn0sRNEjw8QHWsgAOHEC6gKraBHivks0aV65UkRYRIsBLmGVBuQc8Ml0gF8DdvC4jn4UIdK3jmgszD1Rs0yECxANCI4g4EaHB06dLEwgIADs=';
        case 'p_oval.gif':
          return 'data:image/gif;base64,R0lGODdhDwALAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwALAAAIMAARCBxIsGBBAAgRGhSokGDDgQAWMoQokSKCiBUvTsyIUaPEjgxBXhQJMSHJjAQDAgA7';
        case 'p_paint.gif':
          return 'data:image/gif;base64,R0lGODdhDwALAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwALAAAIRgARCByIAAAAgggNFnxwEKFAhQAeMARwAOGBgxEZSlQ40KBHAyA9NizYEEDIjyVLGhAZ8uFIlis7jiTZkuDMghcd3iyIMCAAOw==';
        case 'p_pencil.gif':
          return 'data:image/gif;base64,R0lGODdhDwALAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwALAAAINQARCBw4EAAAgggLBnhwMCFBAAEaOhQIYAECiRMrYnRY8eLEggw/UrS4MSGAAyVNpkx44GNAADs=';
        case 'p_poly.gif':
          return 'data:image/gif;base64,R0lGODdhDwALAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwALAAAILQARCBxIsGBBAAgTGhwIgGDDhQ8FRjQYceJBhgsxSkxo0aLGjxcdchyZsSSCgAA7';
        case 'p_rect.gif':
          return 'data:image/gif;base64,R0lGODdhDwALAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwALAAAILQARCBxIsKBAAAgTKgRAkKHBgw0fQhzo8GFFBBcLXswYkaJEjB0tNly48KPEgAA7';
        case 'p_rrect.gif':
          return 'data:image/gif;base64,R0lGODdhDwALAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwALAAAINQARCBxIsODAAwASKgRwoOCBhgYfEgRgcCBFixUFXtSYEcFGjx0/fiz4UWJEiAcXKkTZ0WBAADs=';
        case 'p_sel.gif':
          return 'data:image/gif;base64,R0lGODdhDwALAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwALAAAIKgARCBxIsKBAAAgQKkzIcCBCgwchSiT4EGLFiRYnXsRYcCPFjwtDcjQYEAA7';
        case 'p_trans.gif':
          return 'data:image/gif;base64,R0lGODdhGgAQAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAGgAQAAAItwABCBxIsGBBAggTAljAsKHDhw0BJFTY8ADCAw8FLtAoUSCBjgwREGDAgABGhgszTgS5gAACkghSbnQooKYAkRRbItj5EeICmzctfuypkyTRmT8fKH0gQCjClC6NykwpQIFVBU2fEo1aUmJChgIeXM2ak6vLBgkkgr2KVShLrgjQJkhLIOlVp08ZOkUwd67agwqPHjgAIG5ftQ69roR4dmjMhQSHsnw4ePCAywgiTnxqsLPBzQQCAgA7';
        case 'p_txt.gif':
          return 'data:image/gif;base64,R0lGODdhDwALAPcAAAAAAIAAAACAAICAAAAAgIAAgACAgICAgMDAwP8AAAD/AP//AAAA//8A/wD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADwALAAAINQARCBxIsKBBBAAAHDSY8MDCgQkTPhSoUOJDAA4PWDyokGJHgxojRuRIMCTIjx5RhvwoUmFAADs=';
        case 'p_zoom.gif':
          return 'data:image/gif;base64,R0lGODlhDwALAPIEAAAAAAkHvICAgMDAwP///////wAAAAAAACH5BAEAAAUALAAAAAAPAAsAAAMkODrQvVABQmWUFYI7uf/axYALEIibQghBKwrO2Z7iIru1cg8JADs=';
      }
    }
  </script>
  <script>
    const TAU = //////|//////
      /////     |     /////
      ///         tau         ///
      ///     ...--> | <--...     ///
      ///     -'   one | turn  '-     ///
      //     .'         |         '.     //
      //     /           |           \     //
      //     |            | <-..       |     //
      //    |          .->|     \       |    //
      //    |         /   |      |      |    //
      - - - - - -Math.PI + Math.PI - - - - -0;
    //    |         \   |      |      |    //
    //    |          '->|     /       |    //
    //     |            | <-''       |     //
    //     \           |           /     //
    //     '.         |         .'     //
    ///     -.       |       .-     ///
    ///     '''----|----'''     ///
    ///          |          ///
    //////     |     /////
    //////|//////          C/r;

    const $G = $(window);

    function make_css_cursor(name, coords, fallback) {
      return `url(${name}) ${coords.join(" ")}, ${fallback}`;
    }

    function E(t) {
      return document.createElement(t);
    }

    /** Returns a function, that, as long as it continues to be invoked, will not
    be triggered. The function will be called after it stops being called for
    N milliseconds. If `immediate` is passed, trigger the function on the
    leading edge, instead of the trailing. */
    function debounce(func, wait_ms, immediate) {
      let timeout;

      return function() {
        const context = this;
        const args = arguments;

        const later = () => {
          timeout = null;
          if (!immediate) {
            func.apply(context, args);
          }
        };

        const callNow = immediate && !timeout;

        clearTimeout(timeout);

        timeout = setTimeout(later, wait_ms);

        if (callNow) {
          func.apply(context, args);
        }
      };
    }

    function memoize_synchronous_function(func, max_entries = 50000) {
      const cache = {};
      const keys = [];
      const memoized_func = (...args) => {
        const key = JSON.stringify(args);
        if (cache[key]) {
          return cache[key];
        } else {
          const val = func.apply(null, args);
          cache[key] = val;
          keys.push(key);
          if (keys.length > max_entries) {
            const oldest_key = keys.shift();
            delete cache[oldest_key];
          }
          return val;
        }
      }
      memoized_func.clear_memo_cache = () => {
        for (const key of keys) {
          delete cache[key];
        }
        keys.length = 0;
      };
      return memoized_func;
    }

    window.get_rgba_from_color = memoize_synchronous_function((color) => {
      const single_pixel_canvas = make_canvas(1, 1);

      single_pixel_canvas.ctx.fillStyle = color;
      single_pixel_canvas.ctx.fillRect(0, 0, 1, 1);

      const image_data = single_pixel_canvas.ctx.getImageData(0, 0, 1, 1);

      // We could just return image_data.data, but let's return an Array instead
      // I'm not totally sure image_data.data wouldn't keep the ImageData object around in memory
      return Array.from(image_data.data);
    });

    /**
     * Compare two ImageData.
     * Note: putImageData is lossy, due to premultiplied alpha.
     * @returns {boolean} whether all pixels match within the specified threshold
     */
    function image_data_match(a, b, threshold) {
      const a_data = a.data;
      const b_data = b.data;
      if (a_data.length !== b_data.length) {
        return false;
      }
      for (let len = a_data.length, i = 0; i < len; i++) {
        if (a_data[i] !== b_data[i]) {
          if (Math.abs(a_data[i] - b_data[i]) > threshold) {
            return false;
          }
        }
      }
      return true;
    }

    function make_canvas(width, height) {
      const image = width;

      const new_canvas = E("canvas");
      const new_ctx = new_canvas.getContext("2d");

      new_canvas.ctx = new_ctx;

      new_ctx.disable_image_smoothing = () => {
        new_ctx.imageSmoothingEnabled = false;
        // condition is to avoid a deprecation warning in Firefox
        if (new_ctx.imageSmoothingEnabled !== false) {
          new_ctx.mozImageSmoothingEnabled = false;
          new_ctx.webkitImageSmoothingEnabled = false;
          new_ctx.msImageSmoothingEnabled = false;
        }
      };
      new_ctx.enable_image_smoothing = () => {
        new_ctx.imageSmoothingEnabled = true;
        if (new_ctx.imageSmoothingEnabled !== true) {
          new_ctx.mozImageSmoothingEnabled = true;
          new_ctx.webkitImageSmoothingEnabled = true;
          new_ctx.msImageSmoothingEnabled = true;
        }
      };

      // @TODO: simplify the abstraction by defining setters for width/height
      // that reset the image smoothing to disabled
      // and make image smoothing a parameter to make_canvas

      new_ctx.copy = image => {
        new_canvas.width = image.naturalWidth || image.width;
        new_canvas.height = image.naturalHeight || image.height;

        // setting width/height resets image smoothing (along with everything)
        new_ctx.disable_image_smoothing();

        if (image instanceof ImageData) {
          new_ctx.putImageData(image, 0, 0);
        } else {
          new_ctx.drawImage(image, 0, 0);
        }
      };

      if (width && height) {
        // make_canvas(width, height)
        new_canvas.width = width;
        new_canvas.height = height;
        // setting width/height resets image smoothing (along with everything)
        new_ctx.disable_image_smoothing();
      } else if (image) {
        // make_canvas(image)
        new_ctx.copy(image);
      }

      return new_canvas;
    }

    function get_help_folder_icon(file_name) {
      const icon_img = new Image();
      icon_img.src = getHelpIconByName(file_name);
      return icon_img;
    }

    function get_icon_for_tool(tool) {
      return get_help_folder_icon(tool.help_icon);
    }

    function load_image(path) {
      return new Promise((resolve, reject) => {
        const img = new Image();

        img.onload = () => {
          resolve(img);
        };
        img.onerror = () => {
          reject();
        };

        img.src = path;
      });
    }

    function get_icon_for_tools(tools) {
      if (tools.length === 1) {
        return get_icon_for_tool(tools[0]);
      }
      const icon_canvas = make_canvas(16, 16);

      Promise.all(tools.map((tool) => load_image(`help/${tool.help_icon}`)))
        .then((icons) => {
          icons.forEach((icon, i) => {
            const w = icon_canvas.width / icons.length;
            const x = i * w;
            const h = icon_canvas.height;
            const y = 0;
            icon_canvas.ctx.drawImage(icon, x, y, w, h, x, y, w, h);
          });
        })
      return icon_canvas;
    }
  </script>
  <script>
    // @TODO: remove remaining cruft from being compiled from CoffeeScript
    // or maybe replace this module with localforage actually
    // (but need to address asynchronous concerns if doing that)

    ((() => {
      let localStore = {
        get(key, callback) {
          let i, item, len, obj, keys, keys_obj;
          try {
            if (typeof key === "string") {
              item = localStorage.getItem(key);
              if (item) {
                obj = JSON.parse(item);
              }
            } else {
              obj = {};
              if (Array.isArray(key)) {
                keys = key;
                for (i = 0, len = keys.length; i < len; i++) {
                  key = keys[i];
                  item = localStorage.getItem(key);
                  if (item) {
                    obj[key] = JSON.parse(item);
                  }
                }
              } else {
                keys_obj = key;
                for (key in keys_obj) {
                  let defaultValue = keys_obj[key];
                  item = localStorage.getItem(key);
                  if (item) {
                    obj[key] = JSON.parse(item);
                  } else {
                    obj[key] = defaultValue;
                  }
                }
              }
            }
          } catch (error) {
            callback(error);
            return;
          }
          callback(null, obj);
        },
        set(key, value, callback) {
          let to_set = {};
          if (typeof key === "string") {
            to_set = {
              [key]: value
            };
          } else if (Array.isArray(key)) {
            throw new TypeError("Cannot set an array of keys (to what?)");
          } else {
            to_set = key, callback = value;
          }
          for (key in to_set) {
            value = to_set[key];
            try {
              localStorage.setItem(key, JSON.stringify(value));
            } catch (error) {
              error.quotaExceeded = error.code === 22 || error.name === "NS_ERROR_DOM_QUOTA_REACHED" || error.number === -2147024882;
              callback(error);
              return;
            }
          }
          return callback(null);
        }
      };

      window.storage = localStore;

    })).call(this);
  </script>
  <script>
    // Segments here represent UI components as far as a layout algorithm is concerned,
    // line segments in one dimension (regardless of whether that dimension is vertical or horizontal),
    // with a reference to the UI component DOM element so it can be updated.

    function get_segments(component_area_el, pos_axis, exclude_component_el) {
      const $other_components = $(component_area_el).find(".component").not(exclude_component_el);
      return $other_components.toArray().map((component_el) => {
        return {
          element: component_el,
          pos: component_el[pos_axis === "top" ? "offsetTop" : "offsetLeft"],
          length: component_el[pos_axis === "top" ? "clientHeight" : "clientWidth"],
        };
      });
    }

    function adjust_segments(segments, total_available_length) {
      segments.sort((a, b) => a.pos - b.pos);

      // Clamp
      for (const segment of segments) {
        segment.pos = Math.max(segment.pos, 0);
        segment.pos = Math.min(segment.pos, total_available_length - segment.length);
      }

      // Shove things downwards to prevent overlap
      for (let i = 1; i < segments.length; i++) {
        const segment = segments[i];
        const prev_segment = segments[i - 1];
        const overlap = prev_segment.pos + prev_segment.length - segment.pos;
        if (overlap > 0) {
          segment.pos += overlap;
        }
      }

      // Clamp
      for (const segment of segments) {
        segment.pos = Math.max(segment.pos, 0);
        segment.pos = Math.min(segment.pos, total_available_length - segment.length);
      }

      // Shove things upwards to get things back on screen
      for (let i = segments.length - 2; i >= 0; i--) {
        const segment = segments[i];
        const prev_segment = segments[i + 1];
        const overlap = segment.pos + segment.length - prev_segment.pos;
        if (overlap > 0) {
          segment.pos -= overlap;
        }
      }
    }

    function apply_segments(component_area_el, pos_axis, segments) {
      // Since things aren't positioned absolutely, calculate space between
      let length_before = 0;
      for (const segment of segments) {
        segment.margin_before = segment.pos - length_before;
        length_before = segment.length + segment.pos;
      }

      // Apply to the DOM
      for (const segment of segments) {
        component_area_el.appendChild(segment.element);
        $(segment.element).css(`margin-${pos_axis}`, segment.margin_before);
      }
    }

    function $Component(name, orientation, $el) {
      // A draggable widget that can be undocked into a window
      const $c = $(E("div")).addClass("component");
      $c.addClass(`${name}-component`);
      $c.addClass(orientation);
      $c.append($el);
      $c.attr("touch-action", "none");

      const $w = new $ToolWindow($c);
      $w.title(name);
      $w.hide();
      $w.$content.addClass({
        tall: "vertical",
        wide: "horizontal",
      } [orientation]);

      // Nudge the Colors component over a tiny bit
      if (name === "Colors" && orientation === "wide") {
        $c.css("position", "relative");
        $c.css("left", "3px");
      }

      let iid;
      if ($("body").hasClass("eye-gaze-mode")) {
        // @TODO: don't use an interval for this!
        iid = setInterval(() => {
          const scale = 3;
          $c.css({
            transform: `scale(${scale})`,
            transformOrigin: "0 0",
            marginRight: $c[0].scrollWidth * (scale - 1),
            marginBottom: $c[0].scrollHeight * (scale - 1),
          });
        }, 200);
      }

      let ox, oy;
      let w, h;
      let pos = 0;
      let pos_axis;
      let last_docked_to_pos;
      let $last_docked_to;
      let $dock_to;
      let $ghost;

      if (orientation === "tall") {
        pos_axis = "top";
      } else {
        pos_axis = "left";
      }

      const dock_to = $dock_to => {
        $w.hide();

        // must get layout state *before* changing it
        const segments = get_segments($dock_to[0], pos_axis, $c[0]);

        // so we can measure clientWidth/clientHeight
        $dock_to.append($c);

        segments.push({
          element: $c[0],
          pos: pos,
          length: $c[0][pos_axis === "top" ? "clientHeight" : "clientWidth"],
        });

        const total_available_length = pos_axis === "top" ? $dock_to.height() : $dock_to.width();
        // console.log("before adjustment", JSON.stringify(segments, (_key,val)=> (val instanceof Element) ? val.className : val));
        adjust_segments(segments, total_available_length);
        // console.log("after adjustment", JSON.stringify(segments, (_key,val)=> (val instanceof Element) ? val.className : val));

        apply_segments($dock_to[0], pos_axis, segments);

        // Save where it's now docked to
        $last_docked_to = $dock_to;
        last_docked_to_pos = pos;
      };

      $c.on("pointerdown", e => {
        // Only start a drag via a left click directly on the component element
        if (e.button !== 0) {
          return;
        }
        if (!$c.is(e.target)) {
          return;
        }
        // Don't allow dragging in eye gaze mode
        if ($("body").hasClass("eye-gaze-mode")) {
          return;
        }

        $G.on("pointermove", drag_update_position);
        $G.one("pointerup", e => {
          $G.off("pointermove", drag_update_position);
          drag_onpointerup(e);
        });

        const rect = $c[0].getBoundingClientRect();
        // Make sure these dimensions are odd numbers
        // so the alternating pattern of the border is unbroken
        w = (~~(rect.width / 2)) * 2 + 1;
        h = (~~(rect.height / 2)) * 2 + 1;
        ox = rect.left - e.clientX;
        oy = rect.top - e.clientY;

        if (!$ghost) {
          $ghost = $(E("div")).addClass("component-ghost dock");
          $ghost.css({
            position: "absolute",
            display: "block",
            width: w,
            height: h,
            left: e.clientX + ox,
            top: e.clientY + oy
          });
          $ghost.appendTo("body");
        }

        drag_update_position(e);

        // Prevent text selection anywhere within the component
        e.preventDefault();
      });
      const drag_update_position = e => {

        $ghost.css({
          left: e.clientX + ox,
          top: e.clientY + oy,
        });

        $dock_to = null;

        const ghost_rect = $ghost[0].getBoundingClientRect();
        const q = 5;
        if (orientation === "tall") {
          pos_axis = "top";
          if (ghost_rect.left - q < $left[0].getBoundingClientRect().right) {
            $dock_to = $left;
          }
          if (ghost_rect.right + q > $right[0].getBoundingClientRect().left) {
            $dock_to = $right;
          }
        } else {
          pos_axis = "left";
          if (ghost_rect.top - q < $top[0].getBoundingClientRect().bottom) {
            $dock_to = $top;
          }
          if (ghost_rect.bottom + q > $bottom[0].getBoundingClientRect().top) {
            $dock_to = $bottom;
          }
        }

        if ($dock_to) {
          const dock_to_rect = $dock_to[0].getBoundingClientRect();
          pos = ghost_rect[pos_axis] - dock_to_rect[pos_axis];
          $ghost.addClass("dock");
        } else {
          $ghost.removeClass("dock");
        }

        e.preventDefault();
      };

      const drag_onpointerup = e => {

        $w.hide();

        // If the component is docked to a component area (a side)
        if ($c.parent().is(".component-area")) {
          // Save where it's docked so we can dock back later
          $last_docked_to = $c.parent();
          if ($dock_to) {
            last_docked_to_pos = pos;
          }
        }

        if ($dock_to) {
          // Dock component to $dock_to
          dock_to($dock_to);
        } else {
          const component_area_el = $c.closest(".component-area")[0];
          // must get layout state *before* changing it
          const segments = get_segments(component_area_el, pos_axis, $c[0]);

          $c.css("position", "relative");
          $c.css(`margin-${pos_axis}`, "");

          // Put the component in the window
          $w.$content.append($c);
          // Show and position the window
          $w.show();
          const window_rect = $w[0].getBoundingClientRect();
          const window_content_rect = $w.$content[0].getBoundingClientRect();
          const dx = window_content_rect.left - window_rect.left;
          const dy = window_content_rect.top - window_rect.top;
          $w.css({
            left: e.clientX + ox - dx,
            top: e.clientY + oy - dy,
          });

          const total_available_length = pos_axis === "top" ? $(component_area_el).height() : $(component_area_el).width();
          // console.log("before adjustment", JSON.stringify(segments, (_key,val)=> (val instanceof Element) ? val.className : val));
          adjust_segments(segments, total_available_length);
          // console.log("after adjustment", JSON.stringify(segments, (_key,val)=> (val instanceof Element) ? val.className : val));
          apply_segments(component_area_el, pos_axis, segments);
        }

        $ghost && $ghost.remove();
        $ghost = null;

        $G.trigger("resize");
      };

      $c.dock = () => {
        pos = last_docked_to_pos;
        dock_to($last_docked_to);
      };

      $c.show = () => {
        $($c[0]).show(); // avoid recursion
        if ($.contains($w[0], $c[0])) {
          $w.show();
        }
        return $c;
      };
      $c.hide = () => {
        $c.add($w).hide();
        return $c;
      };
      $c.toggle = () => {
        if ($c.is(":visible")) {
          $c.hide();
        } else {
          $c.show();
        }
        return $c;
      };
      $c.destroy = () => {
        $w.close();
        $c.remove();
        clearInterval(iid);
      };

      $w.on("close", e => {
        e.preventDefault();
        $w.hide();
      });

      return $c;
    }
  </script>
  <script>
    $Window.Z_INDEX = 50; // dynamically incrementing z-index

    function $ToolWindow($component) {
      const $w = $(E("div"))
        .addClass("xp-window")
        .attr("float", "")
        .appendTo("body");

      $w.$titlebar = $(E("div"))
        .addClass("xp-title-bar")
        .appendTo($w);

      $w.$title = $(E("div"))
        .addClass("xp-title-bar-text")
        .appendTo($w.$titlebar);

      $w.$titleBarControls = $(E("div"))
        .addClass("xp-title-bar-controls")
        .appendTo($w.$titlebar);

      $w.$x = $(E("button"))
        .attr("aria-label", "Close")
        .appendTo($w.$titleBarControls);

      $w.$content = $(E("div"))
        .addClass("xp-window-body")
        .appendTo($w);

      if ($component) {
        $w.addClass("component-window");
      }

      $w.attr("touch-action", "none");

      $w.$x.on("click", () => {
        $w.close();
      });
      $w.$x.on("mousedown selectstart", e => {
        e.preventDefault();
      });

      // @TODO: prevent selection *outside* of the window *via* the window

      // @TODO: keep track of last focused control in the window, and focus it when clicking on / focusing the window

      $w.css({
        position: "absolute",
        zIndex: $Window.Z_INDEX++
      });
      $w.on("pointerdown", () => {
        $w.css({
          zIndex: $Window.Z_INDEX++
        });
      });

      $w.on("keydown", e => {
        if (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey) {
          return;
        }
        const $buttons = $w.$content.find("button");
        const $focused = $(document.activeElement);
        const focused_index = $buttons.index($focused);
        switch (e.keyCode) {
          case 40: // Down
          case 39: // Right
            if ($focused.is("button")) {
              if (focused_index < $buttons.length - 1) {
                $buttons[focused_index + 1].focus();
                e.preventDefault();
              }
            }
            break;
          case 38: // Up
          case 37: // Left
            if ($focused.is("button")) {
              if (focused_index > 0) {
                $buttons[focused_index - 1].focus();
                e.preventDefault();
              }
            }
            break;
          case 32: // Space
          case 13: // Enter (doesn't actually work in chrome because the button gets clicked immediately)
            if ($focused.is("button")) {
              $focused.addClass("pressed");
              const release = () => {
                $focused.removeClass("pressed");
                $focused.off("focusout", release);
                $(window).off("keyup", keyup);
              };
              const keyup = e => {
                if (e.keyCode === 32 || e.keyCode === 13) {
                  release();
                }
              };
              $focused.on("focusout", release);
              $(window).on("keyup", keyup);
            }
            break;
          case 9: { // Tab

            // @TODO: handle shift+tab as well (note: early return at top of function)
            // wrap around when tabbing through controls in a window
            // @TODO: other element types? also [tabIndex]
            const $controls = $w.$content.find("input, textarea, select, button, a");
            const focused_control_index = $controls.index($focused);
            if (focused_control_index === $controls.length - 1) {
              e.preventDefault();
              $controls[0].focus();
            }
            break;
          }
          case 27: // Esc
            $w.close();
            break;
        }
      });

      $w.applyBounds = () => {
        $w.css({
          left: Math.max(0, Math.min(innerWidth - $w.width(), $w[0].getBoundingClientRect().left)),
          top: Math.max(0, Math.min(innerHeight - $w.height(), $w[0].getBoundingClientRect().top)),
        });
      };

      $w.center = () => {
        $w.css({
          left: (innerWidth - $w.width()) / 2,
          top: (innerHeight - $w.height()) / 2,
        });
        $w.applyBounds();
      };


      $G.on("resize", $w.applyBounds);

      let drag_offset_x, drag_offset_y;
      const drag = e => {
        $w.css({
          left: e.clientX - drag_offset_x,
          top: e.clientY - drag_offset_y,
        });
      };
      $w.$titlebar.attr("touch-action", "none");
      $w.$titlebar.on("mousedown selectstart", e => {
        e.preventDefault();
      });
      $w.$titlebar.on("pointerdown", e => {
        if ($(e.target).is("button")) {
          return;
        }
        drag_offset_x = e.clientX - $w[0].getBoundingClientRect().left;
        drag_offset_y = e.clientY - $w[0].getBoundingClientRect().top;
        $G.on("pointermove", drag);
        $("body").addClass("dragging");
        const stop_drag = () => {
          $w.applyBounds();
          $G.off("pointermove", drag);
          $G.off("pointerup pointercancel", stop_drag);
          $("body").removeClass("dragging");
        };
        $G.on("pointerup pointercancel", stop_drag);
      });
      $w.$titlebar.on("dblclick", () => {
        if ($component) {
          $component.dock();
        }
      });

      $w.$Button = (text, handler) => {
        const $b = $(E("button"))
          .appendTo($w.$content)
          .text(text)
          .on("click", () => {
            if (handler) {
              handler();
            }
            $w.close();
          });
        return $b;
      };
      $w.title = title => {
        if (title) {
          $w.$title.text(title);
          return $w;
        } else {
          return $w.$title.text();
        }
      };
      $w.close = () => {
        const e = $.Event("close");
        $w.trigger(e);
        if (e.isDefaultPrevented()) {
          return;
        }
        if ($component) {
          $component.detach();
        }
        $w.remove();
        $w.closed = true;
      };
      $w.closed = false;

      if (!$component) {
        $w.center();
      }

      return $w;
    }

    function $FormToolWindow(title) {
      const $w = new $ToolWindow();

      $w.title(title);
      $w.$form = $(E("form"))
        .appendTo($w.$content);

      $w.$main = $(E("div")).appendTo($w.$form);
      $w.$buttons = $(E("div")).appendTo($w.$form).addClass("button-group");

      $w.$Button = (label, action) => {
        const $b = $(E("button"))
          .appendTo($w.$buttons)
          .addClass("xp-button")
          .css({
            margin: 4,
          })
          .text(label);

        $b.on("click", e => {
          // prevent the form from submitting
          // @TODO: instead prevent submit event
          e.preventDefault();

          action();
        });

        $b.on("pointerdown", () => {
          $b[0].focus();
        });

        return $b;
      };

      return $w;
    }
  </script>
  <script>
    const TOOLS_PNG_BASE64 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAAQCAYAAAD506FJAAAFLElEQVR4Xu1aa5qrIAzFlbVd2XRWZrsy7gcCxpgn4Dy+O/3TVgmEkHNyQJdw/sQQwkJc/7tki0CKH/zMiCXs09NftfPY2Gb581v9z3M3rw6VGFrgfhtBaPMxB6s05MCYr79er0N/9/u9/u8FYVxBj4/tt6WvuBbDx2ak2KwxhMcSQv1OJvC3N0zBkyez16g6e1W/UjBwAaDaWtbPHfAeA44AOAepgNaFhvesv7VAcMHU7FoCxBjDsuTmVhtxcRPAAahrv/H5fIaPj49m+36/2+9kk+53+pAJ4B63UDjm4iCANb5eS7jfY6jfexAK5diJJ7XsUSxXgVXr1wJYLidI/OAiUI1L3szIQ8ofzzyaD5ozkMU5RvcwPXRcs4sJvBtuj98bnk+AxklX7EvmFqNOEOKkhvPIDm6+hgCBDxt1Ln7utBKAA/zZX5sCoMCflMAG4jqvMraVxHoIAMZYy0tvsZNyLXKAlQYR1pPtz5gDEpDZwuyZA/TDogBw8DTgeheHZDMF/DgRW9Bqha6JW6smSmRPgqnMmsa83W4s+AcqQHZ75y6S+Lh4GwkgU0xTANs2IH8aqe3gb8VUix+OmdYeFwYr0Vhz7asIYAT8OWYSkJnt5BCBWQgAB3kWIbCKQgJ/qmpoT3sCf6ilD3teDMvlnqTEPeZKeREBFM6KmViM1eMAJK8CAOBvBHAGf8OmtE1sCqIj1rOVgLoF8FRPhcx7CcAFYpQLLlvsvwcEbKXplNUUAYiyn0noxpw5MDbw17lY5p99AhIY25oXwAniFgugACz+Vv+GFcC+4HALdpi+VEBGVMAsEtDAn8eZRABfAn6CgIb8xwtokfeWNlZpdqhYWuVPjYkT7SMBZEVbZAJijINTu5SQQNVk8OfnZz3Iw/LUvAAOAmjgf7/boWMX+Ouc+ScBpPxvJOIkAUodesiWUps43tbcsoD/jwBAND3Ahm09dgfAA+XQU/mJJG0Hg7EpgaPs32yOxMBK2XpuAMAPTyQPc5GqSDof8B7gbWeKB+VhJYBW+TFSJBJA8h+vU/mPlcDp6YpEAFcDmfLZEjMzgcMBrDLcQPqj4w/ZtwOfDhkPs8ESaIrd2x6aovUUPMM+ljpx3ghgPvi56pMfA6LHg7ltAn8lkNTm+XxqsRre+yslEo0vKgBBCeRblIKUhtfmzsa33LDYWyt/m9uELQAJQiofwAQb9gbHHyYAGDAueFSbOhfLokhJIe6diEM/ikgoX86n987Kv6SXejYSsczxdIq7g/8GfG6n7GKyo9N/y/gEWMkhiL5ML/xoe3r2UBd54ZlLT1X3KtIhAFVp5AExoQpcPljVhwS62oflKYAWUO2+lOiqAjAwP6UAzmC4FvxUopZrK/VyjXjuMAiYw/sPsC96G2ICP46nJW+4mPQSQOrPUt29+egCX50UAKHbntkWnAoIBo7wVqnLB+09AIk4qHvUxpBTFfg63IJw41oSRkoMfB6g7vmdld8QLyiza3NWCUiEZhhre36fth3pzcT6nWUM+0akiwQkBYbV0lmF7daWdeXyTVJlFpIQCNsS4tZGLGBcT8q5QG/MJDvsSou9xOReJnVFbnJjbdHl++sas9SHKgE+Tnyost0wHTMJaHPRxnISwBD4NV+uuq/FSLs/0y8P8A6CbKYTvX1xBCAxbO9YV9v1EVYCf/rAA0PqXYJLSIAklr557NF1EsDVy/Jt/X8lCXzbJEcH9u7lRsf7mfaVBCjvpgAfdlwIZ3/ldmZMLNWoV3rP9POvrx8SgX+tMt8v1elb4wAAAABJRU5ErkJggg==";
    const OPTIONS_TRANSPARENCY_BASE64 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACMAAAAtCAMAAAATDSIbAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAAqUExURf//AAAAAP///wCAAAAA/wD/AMDAwAAAgIAAAP8AAICAgICAAP8A/////x9ECeEAAAAOdFJOU/////////////////8ARcDcyAAAAQlJREFUeNrUk8GOgzAMRGPCGpMu//+7tZ2EHdMEqT11Rzkg8RgHeSbRjY6qRGmq9xneVKW/ovMcfpzhbVU1iJaLKrOxMSshk11Fn47GGMTtaoAwgc/CzBv4NCQHxu7zx+Q+j2AWMMmZH1O+95kzonphwiwR/t1JAlNKCT6G7Dv6GBKYiiDjSJ+1ArPbNascWfq+TOAz2Fdi+2rGYH6KQ6R//xhko0lcRA/VNIfFL6oEf5DVr+/F1WfUiwq0XpyzYi8AYQIf7AUgOTCQZ0POXsAs7IUzPat3PnPG935lRr2QO5/WCyknQ8eF6VnVab0XsK/YC6EUsjHqheaZX/cVeyE0z/O/6cVTgAEADvgWrhraI38AAAAASUVORK5CYII=";
    const OPTIONS_AIRBRUSH_SIZE_BASE64 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAAAYCAMAAABuvUuCAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAAGUExURQAAAP///6XZn90AAAACdFJOU/8A5bcwSgAAANxJREFUeNqslVEShDAIQ1/vf2lnFSgFqtUuX46WNISAtJ2gfHwLwgzzDcYPhX8won0AogEZCInzwBojwpWEWGKEcIoUHaMlINBExx5BFhirztddKyQiYeroaRTGpXIDJJWEntnbkFo2h4sODAbsr3sK4WaSWwSEkbsIaHK7zyZcAYWjSz9vF5AZVdMAebAuZFcCYX6I3VfHpBaIOUhOK3C002nOVTxFGcWOBjZG2biDd+DR2UwOMF5SbKfJlNCKUWtm6vV9VNYc1OHbVoM4UGytbG7nffuHsheHAAMA9fcFmg9OQIIAAAAASUVORK5CYII=";
    const OPTIONS_MAGNIFICATION_BASE64 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFwAAAAJCAMAAACIcrsuAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAAGUExURQAAAP///6XZn90AAAACdFJOU/8A5bcwSgAAAGxJREFUeNqkkkEOwCAIBGf//+mmbbCoS7SRA4eJjGQVScgUnGNKbi/dw0RVm9eWYePbsZBjXMyU6Bh5wxtyevoefSYmuXo8xZKS5+uZ5j2wsYCW8nwD9uV+ysdYxnA7+WnmbQjzoVc43JcAAwAdfgJgBHz3DQAAAABJRU5ErkJggg==";
  </script>
  <script>
    let theme_dev_blob_url;

    function $ToolBox(tools, is_extras) {
      const $tools = $(E("div")).addClass("tools");
      const $tool_options = $(E("div")).addClass("tool-options");

      let showing_tooltips = false;
      $tools.on("pointerleave", () => {
        showing_tooltips = false;
        $status_text.default();
      });

      const $buttons = $($.map(tools, (tool, i) => {
        const $b = $(E("div")).addClass("tool");
        $b.appendTo($tools);
        tool.$button = $b;

        $b.attr("title", tool.name);

        const $icon = $(E("span"));
        $icon.appendTo($b);
        const update_css = () => {
          const theme_folder = `images/${get_theme().replace(/\.css/, "")}`;
          const theme_has_svg = get_theme().match(/classic.css|dark.css/);
          const use_svg = !theme_dev_blob_url && (
            (theme_has_svg &&
              (window.devicePixelRatio >= 3 || (window.devicePixelRatio % 1) !== 0)
            ) ||
            $("body").hasClass("eye-gaze-mode")
          );
          const background_image = theme_dev_blob_url ? (
            `url(${theme_dev_blob_url})`
          ) : (
            use_svg ? `url(${TOOLS_PNG_BASE64})` : `url(${TOOLS_PNG_BASE64})`
          );
          $icon.css({
            display: "block",
            position: "absolute",
            left: 4,
            top: 4,
            width: 16,
            height: 16,
            backgroundImage: background_image,
            backgroundPosition: `${(-i)*16}px ${use_svg * -16}px`,
          });
        };
        update_css();
        $G.on("theme-load resize", update_css);

        $b.on("click", e => {
          if (e.shiftKey || e.ctrlKey) {
            select_tool(tool, true);
            return;
          }
          if (selected_tool === tool && tool.deselect) {
            select_tools(return_to_tools);
          } else {
            select_tool(tool);
          }
        });

        $b.on("pointerenter", () => {
          const show_tooltip = () => {
            showing_tooltips = true;
            $status_text.text(tool.description);
          };
          if (showing_tooltips) {
            show_tooltip();
          } else {
            const tid = setTimeout(show_tooltip, 300);
            $b.on("pointerleave", () => {
              clearTimeout(tid);
            });
          }
        });

        return $b[0];
      }));

      const $c = $Component(is_extras ? "Extra Tools" : "Tools", "tall", $tools.add($tool_options));
      $c.appendTo($left);
      $c.update_selected_tool = () => {
        $buttons.removeClass("selected");
        selected_tools.forEach((selected_tool) => {
          selected_tool.$button.addClass("selected");
        });
        $tool_options.children().detach();
        $tool_options.append(selected_tool.$options);
        $tool_options.children().trigger("update");
        $canvas.css({
          cursor: make_css_cursor(...selected_tool.cursor),
        });
      };
      $c.update_selected_tool();

      if (is_extras) {
        $c.height(80);
      }

      return $c;
    }

    if (localStorage.dev_theme_tool_icons === "true") {
      let last_update_id = 0;
      $G.on("session-update", () => {
        last_update_id += 1;
        const this_update_id = last_update_id;
        canvas.toBlob((blob) => {
          // avoid a race condition particularly when loading the document initially when the default canvas size is large, giving a larger PNG
          if (this_update_id !== last_update_id) {
            return;
          }
          URL.revokeObjectURL(theme_dev_blob_url);
          theme_dev_blob_url = URL.createObjectURL(blob);
          $G.triggerHandler("theme-load");
        });
      });
    }
  </script>
  <script>
    function $Swatch(color) {
      const $b = $(E("div")).addClass("swatch");
      const swatch_canvas = make_canvas();
      $(swatch_canvas).css({
        pointerEvents: "none"
      }).appendTo($b);

      $b.update = _color => {
        color = _color;
        if (color instanceof CanvasPattern) {
          $b.addClass("pattern");
        } else {
          $b.removeClass("pattern");
        }

        requestAnimationFrame(() => {
          swatch_canvas.width = $b.innerWidth();
          swatch_canvas.height = $b.innerHeight();
          // I don't think disable_image_smoothing() is needed here

          if (color) {
            swatch_canvas.ctx.fillStyle = color;
            swatch_canvas.ctx.fillRect(0, 0, swatch_canvas.width, swatch_canvas.height);
          }
        });
      };
      $G.on("theme-load", () => {
        $b.update(color);
      });
      $b.update(color);

      return $b;
    }

    function $ColorBox(vertical) {
      const $cb = $(E("div")).addClass("color-box");

      const $current_colors = $Swatch(colors.ternary).addClass("current-colors");
      const $palette = $(E("div")).addClass("palette");

      $cb.append($current_colors, $palette);

      const $foreground_color = $Swatch(colors.foreground).addClass("color-selection foreground-color");
      const $background_color = $Swatch(colors.background).addClass("color-selection background-color");
      $current_colors.append($background_color, $foreground_color);

      $G.on("option-changed", () => {
        $foreground_color.update(colors.foreground);
        $background_color.update(colors.background);
        $current_colors.update(colors.ternary);
      });

      $current_colors.on("pointerdown", () => {
        const new_bg = colors.foreground;
        colors.foreground = colors.background;
        colors.background = new_bg;
        $G.triggerHandler("option-changed");
      });

      // the one color editted by "Edit Colors..."
      let $last_fg_color_button;

      function set_color(col) {
        if (ctrl) {
          colors.ternary = col;
        } else if (button === 0) {
          colors.foreground = col;
        } else if (button === 2) {
          colors.background = col;
        }
        $G.trigger("option-changed");
      }

      function color_to_hex(col) {
        if (!col.match) { // i.e. CanvasPattern
          return "#000000";
        }
        const rgb_match = col.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
        const rgb = rgb_match ? rgb_match.slice(1) : get_rgba_from_color(col).slice(0, 3);

        function hex(x) {
          return (`0${parseInt(x).toString(16)}`).slice(-2);
        }
        return rgb ? (`#${hex(rgb[0])}${hex(rgb[1])}${hex(rgb[2])}`) : col;
      }

      const make_color_button = (color) => {

        const $b = $Swatch(color).addClass("color-button");
        $b.appendTo($palette);

        const $i = $(E("input")).attr({
          type: "color"
        });
        $i.appendTo($b);
        $i.on("change", () => {
          color = $i.val();
          $b.update(color);
          set_color(color);
        });

        $i.css("opacity", 0);
        $i.prop("enabled", false);

        $i.val(color_to_hex(color));

        $b.on("pointerdown", e => {
          // @TODO: how should the ternary color, and selection cropping, work on macOS?
          ctrl = e.ctrlKey;
          button = e.button;
          if (button === 0) {
            $last_fg_color_button = $b;
          }

          set_color(color);

          $i.val(color_to_hex(color));

          if (e.button === button && $i.prop("enabled")) {
            $i.trigger("click", "synthetic");
          }

          $i.prop("enabled", true);
          setTimeout(() => {
            $i.prop("enabled", false);
          }, 400);
        });
        $i.on("click", (e, synthetic) => {
          if (!synthetic) {
            e.preventDefault();
          }
        });
      };

      const build_palette = () => {
        $palette.empty();
        palette.forEach(make_color_button);

        // Note: this doesn't work until the colors box is in the DOM
        const $some_button = $palette.find(".color-button");
        if (vertical) {
          const height_per_button =
            $some_button.outerHeight() +
            parseFloat(getComputedStyle($some_button[0]).getPropertyValue("margin-top")) +
            parseFloat(getComputedStyle($some_button[0]).getPropertyValue("margin-bottom"));
          $palette.height(Math.ceil(palette.length / 2) * height_per_button);
        } else {
          const width_per_button =
            $some_button.outerWidth() +
            parseFloat(getComputedStyle($some_button[0]).getPropertyValue("margin-left")) +
            parseFloat(getComputedStyle($some_button[0]).getPropertyValue("margin-right"));
          $palette.width(Math.ceil(palette.length / 2) * width_per_button);
        }

        // the "last foreground color button" starts out as the first in the palette
        $last_fg_color_button = $palette.find(".color-button");
      };
      build_palette();
      $(window).on("theme-change", build_palette);

      let $c;
      if (vertical) {
        $c = $Component("Colors", "tall", $cb);
        $c.appendTo($right);
      } else {
        $c = $Component("Colors", "wide", $cb);
        $c.appendTo($bottom);
      }

      $c.edit_last_color = () => {
        // Edit the last color cell that's been selected as the foreground color.
        create_and_trigger_input({
            type: "color"
          }, input => {
            // window.console && console.log(input, input.value);
            // @FIXME
            $last_fg_color_button.trigger({
              type: "pointerdown",
              ctrlKey: false,
              button: 0
            });
            $last_fg_color_button.find("input").val(input.value).triggerHandler("change");
          })
          .show().css({
            width: 0,
            height: 0,
            padding: 0,
            border: 0,
            position: "absolute",
            pointerEvents: "none",
            overflow: "hidden"
          });
      };

      $c.rebuild_palette = build_palette;

      return $c;
    }
  </script>
  <script>
    const TEXT_TOOLS_BASE64 = "data:image/png;base64,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";
  </script>
  <script>
    function $FontBox() {
      const $fb = $(E("div")).addClass("font-box");

      const $family = $(E("select"));
      const $size = $(E("input")).attr({
        type: "number",
        min: 8,
        max: 72,
        value: text_tool_font.size,
      });
      const $button_group = $(E("span")).addClass("text-toolbar-button-group");
      const $bold = $Toggle(0, "bold");
      const $italic = $Toggle(1, "italic");
      const $underline = $Toggle(2, "underline");
      const $vertical = $Toggle(3, "vertical");
      $vertical.attr("disabled", true);
      $vertical.find("span").css({
        filter: "grayscale(1) contrast(0.3) brightness(1.3) drop-shadow(1px 1px 0px white)" // approximate
      });

      $button_group.append($bold, $italic, $underline, $vertical);
      $fb.append($family, $size, $button_group);

      const update_font = () => {
        text_tool_font.size = Number($size.val());
        text_tool_font.family = $family.val();
        $G.trigger("option-changed");
      };

      FontDetective.each(font => {
        const $option = $(E("option"));
        $option.val(font).text(font.name);
        $family.append($option);
        if (!text_tool_font.family) {
          update_font();
        }
      });

      if (text_tool_font.family) {
        $family.val(text_tool_font.family);
      }

      $family.on("change", update_font);
      $size.on("change", update_font);

      const $w = $ToolWindow();
      $w.title("Fonts");
      $w.$content.append($fb);
      $w.center();
      return $w;


      function $Toggle(xi, thing) {
        const $button = $(E("button"));
        const $image = $(E("span")).appendTo($button);
        $button.css({
          width: 23,
          height: 22
        });
        $image.css({
          display: "block",
          width: 16,
          height: 16,
          backgroundImage: `url(${TEXT_TOOLS_BASE64})`,
          backgroundPosition: `${xi*-16}px 0px`
        });
        $button.on("click", () => {
          $button.toggleClass("selected");
          text_tool_font[thing] = $button.hasClass("selected");
          update_font();
        });
        if (text_tool_font[thing]) {
          $button.addClass("selected");
        }
        return $button;
      }
    }
  </script>
  <script>
    function $Handles($container, getRect, options) {
      const outset = options.outset || 0;
      const get_offset_left = options.get_offset_left || (() => 0);
      const get_offset_top = options.get_offset_top || (() => 0);
      const size_only = options.size_only || false;

      const $resize_ghost = $(E("div")).addClass("resize-ghost");
      const handles = $.map([
        ["top", "right"], // ↗
        ["top", "middle"], // ↑
        ["top", "left"], // ↖
        ["middle", "left"], // ←
        ["bottom", "left"], // ↙
        ["bottom", "middle"], // ↓
        ["bottom", "right"], // ↘
        ["middle", "right"], // →
      ], pos => {
        const y_axis = pos[0];
        const x_axis = pos[1];

        const $h = $(E("div")).addClass("handle");
        $h.appendTo($container);

        $h.attr("touch-action", "none");

        let delta_x = 0,
          delta_y = 0,
          width, height;
        let dragged = false;
        const resizes_height = y_axis !== "middle";
        const resizes_width = x_axis !== "middle";
        if (size_only && (y_axis === "top" || x_axis === "left")) {
          $h.addClass("useless-handle");
        } else {

          let cursor_fname;
          if ((x_axis === "left" && y_axis === "top") || (x_axis === "right" && y_axis === "bottom")) {
            cursor_fname = "nwse-resize";
          } else if ((x_axis === "right" && y_axis === "top") || (x_axis === "left" && y_axis === "bottom")) {
            cursor_fname = "nesw-resize";
          } else if (resizes_width) {
            cursor_fname = "ew-resize";
          } else if (resizes_height) {
            cursor_fname = "ns-resize";
          }

          let fallback_cursor = "";
          if (y_axis === "top") {
            fallback_cursor += "n";
          }
          if (y_axis === "bottom") {
            fallback_cursor += "s";
          }
          if (x_axis === "left") {
            fallback_cursor += "w";
          }
          if (x_axis === "right") {
            fallback_cursor += "e";
          }

          fallback_cursor += "-resize";
          const cursor = make_css_cursor(cursor_fname, [16, 16], fallback_cursor);
          $h.css({
            cursor
          });

          const drag = (event) => {
            $resize_ghost.appendTo($container);
            dragged = true;

            const rect = getRect();
            const m = to_canvas_coords(event);
            // @TODO: decide between Math.floor/Math.ceil/Math.round for these values
            if (x_axis === "right") {
              delta_x = 0;
              width = ~~(m.x - rect.left);
            } else if (x_axis === "left") {
              delta_x = ~~(m.x - rect.left);
              width = ~~(rect.right - m.x);
            } else {
              width = ~~(rect.width);
            }
            if (y_axis === "bottom") {
              delta_y = 0;
              height = ~~(m.y - rect.top);
            } else if (y_axis === "top") {
              delta_y = ~~(m.y - rect.top);
              height = ~~(rect.bottom - m.y);
            } else {
              height = ~~(rect.height);
            }
            $resize_ghost.css({
              position: "absolute",
              left: magnification * delta_x + get_offset_left(),
              top: magnification * delta_y + get_offset_top(),
              width: magnification * width,
              height: magnification * height,
            });
          };
          $h.on("pointerdown", event => {
            dragged = false;
            if (event.button === 0) {
              $G.on("pointermove", drag);
              $("body").css({
                cursor
              }).addClass("cursor-bully");
            }
            $G.one("pointerup", () => {
              $G.off("pointermove", drag);
              $("body").css({
                cursor: ""
              }).removeClass("cursor-bully");

              $resize_ghost.remove();
              if (dragged) {
                // triggerHandler so it doesn't bubble
                $container.triggerHandler("user-resized", [delta_x, delta_y, width, height]);
              }
              $container.trigger("update");
            });
          });
          $h.on("mousedown selectstart", event => {
            event.preventDefault();
          });
        }

        const update_handle = () => {
          const rect = getRect();
          const hs = $h.width();
          if (x_axis === "middle") {
            $h.css({
              left: get_offset_left() + (rect.width * magnification - hs) / 2
            });
          } else if (x_axis === "left") {
            $h.css({
              left: get_offset_left() - outset
            });
          } else if (x_axis === "right") {
            $h.css({
              left: get_offset_left() + (rect.width * magnification - hs / 2)
            });
          }
          if (y_axis === "middle") {
            $h.css({
              top: get_offset_top() + (rect.height * magnification - hs) / 2
            });
          } else if (y_axis === "top") {
            $h.css({
              top: get_offset_top() - outset
            });
          } else if (y_axis === "bottom") {
            $h.css({
              top: get_offset_top() + (rect.height * magnification - hs / 2)
            });
          }
          $h.css({
            "max-width": rect.width * magnification / 2,
            "max-height": rect.height * magnification / 2,
          });
        };

        $container.on("update resize scroll", update_handle);
        $G.on("resize theme-load", update_handle);
        setTimeout(update_handle, 50);

        return $h[0];
      });
      return $(handles);
    }
  </script>
  <script>
    class OnCanvasObject {
      constructor(x, y, width, height, hideMainCanvasHandles) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.hideMainCanvasHandles = hideMainCanvasHandles;
        this.$el = $(E("div")).addClass("on-canvas-object").appendTo($canvas_area);
        if (this.hideMainCanvasHandles) {
          $canvas_handles.hide();
        }
        $G.on("resize theme-load", this._global_resize_handler = () => {
          this.position();
        });
      }
      position(updateStatus) {
        const offset_left = parseFloat($canvas_area.css("padding-left"));
        const offset_top = parseFloat($canvas_area.css("padding-top"));
        this.$el.css({
          position: "absolute",
          left: magnification * this.x + offset_left,
          top: magnification * this.y + offset_top,
          width: magnification * this.width,
          height: magnification * this.height,
        });
        if (updateStatus) {
          $status_position.text(`${this.x},${this.y}`);
          $status_size.text(`${this.width},${this.height}`);
        }
      }
      destroy() {
        this.$el.remove();
        if (this.hideMainCanvasHandles) {
          $canvas_handles.show();
        }
        $G.off("resize theme-load", this._global_resize_handler);
      }
    }
  </script>
  <script>
    class OnCanvasSelection extends OnCanvasObject {
      constructor(x, y, width, height, img) {
        super(x, y, width, height, true);

        this.$el.addClass("selection");
        let last_tool_transparent_mode = tool_transparent_mode;
        let last_background_color = colors.background;
        this._on_option_changed = () => {
          if (!this.source_canvas) {
            return;
          }
          if (last_tool_transparent_mode !== tool_transparent_mode ||
            last_background_color !== colors.background) {
            last_tool_transparent_mode = tool_transparent_mode;
            last_background_color = colors.background;
            this.update_tool_transparent_mode();
          }
        };
        $G.on("option-changed", this._on_option_changed);

        this.instantiate(img);
      }
      position() {
        super.position(true);
        update_helper_layer(); // @TODO: under-grid specific helper layer?
      }
      instantiate(img) {
        this.$el.css({
          cursor: make_css_cursor("move", [8, 8], "move")
        });
        this.$el.attr("touch-action", "none");
        this.position();

        const instantiate = () => {
          if (img) {
            // (this applies when pasting a selection)
            // NOTE: need to create a Canvas because something about imgs makes dragging not work with magnification
            // (width vs naturalWidth?)
            // and at least apply_image_transformation needs it to be a canvas now (and the property name says canvas anyways)
            this.source_canvas = make_canvas(img);
            // @TODO: is this width/height code needed? probably not! wouldn't it clear the canvas anyways?
            // but maybe we should assert in some way that the widths are the same, or resize the selection?
            if (this.source_canvas.width !== this.width) {
              this.source_canvas.width = this.width;
            }
            if (this.source_canvas.height !== this.height) {
              this.source_canvas.height = this.height;
            }
            this.canvas = make_canvas(this.source_canvas);
          } else {
            this.source_canvas = make_canvas(this.width, this.height);
            this.source_canvas.ctx.drawImage(canvas, this.x, this.y, this.width, this.height, 0, 0, this.width, this.height);
            this.canvas = make_canvas(this.source_canvas);
            this.cut_out_background();
          }
          this.$el.append(this.canvas);
          const getRect = () => ({
            left: this.x,
            top: this.y,
            width: this.width,
            height: this.height,
            right: this.x + this.width,
            bottom: this.y + this.height
          })
          this.$handles = $Handles(this.$el, getRect, {
            outset: 2
          });
          this.$el.on("user-resized", (e, delta_x, delta_y, width, height) => {
            undoable({
              name: "Resize Selection",
              icon: get_icon_for_tool(get_tool_by_name("Select")),
              soft: true,
            }, () => {
              this.x += delta_x;
              this.y += delta_y;
              this.width = width;
              this.height = height;
              this.position();
              this.resize();
            });
          });
          let mox, moy;
          const pointermove = e => {
            make_or_update_undoable({
              match: (history_node) =>
                (e.shiftKey && history_node.name.match(/^(Smear|Stamp|Move) Selection$/)) ||
                (!e.shiftKey && history_node.name.match(/^Move Selection$/)),
              name: e.shiftKey ? "Smear Selection" : "Move Selection",
              update_name: true,
              icon: get_icon_for_tool(get_tool_by_name("Select")),
              soft: true,
            }, () => {
              const m = to_canvas_coords(e);
              this.x = Math.max(Math.min(m.x - mox, canvas.width), -this.width);
              this.y = Math.max(Math.min(m.y - moy, canvas.height), -this.height);
              this.position();
              if (e.shiftKey) {
                // Smear selection
                this.draw();
              }
            });
          };
          this.canvas_pointerdown = e => {
            e.preventDefault();
            const rect = this.canvas.getBoundingClientRect();
            const cx = e.clientX - rect.left;
            const cy = e.clientY - rect.top;
            mox = ~~(cx / rect.width * this.canvas.width);
            moy = ~~(cy / rect.height * this.canvas.height);
            $G.on("pointermove", pointermove);
            $G.one("pointerup", () => {
              $G.off("pointermove", pointermove);
            });
            if (e.shiftKey) {
              // Stamp or start to smear selection
              undoable({
                name: "Stamp Selection",
                icon: get_icon_for_tool(get_tool_by_name("Select")),
                soft: true,
              }, () => {
                this.draw();
              });
            }
            // @TODO: how should this work for macOS? where ctrl+click = secondary click?
            else if (e.ctrlKey) {
              // Stamp selection
              undoable({
                name: "Stamp Selection",
                icon: get_icon_for_tool(get_tool_by_name("Select")),
                soft: true,
              }, () => {
                this.draw();
              });
            }
          };
          $(this.canvas).on("pointerdown", this.canvas_pointerdown);
          $canvas_area.trigger("resize");
          $status_position.text("");
          $status_size.text("");
        };

        instantiate();
      }
      cut_out_background() {
        const cutout = this.canvas;
        // doc/this or canvas/cutout, either of those pairs would result in variable names of equal length which is nice :)
        const canvasImageData = ctx.getImageData(this.x, this.y, this.width, this.height);
        const cutoutImageData = cutout.ctx.getImageData(0, 0, this.width, this.height);
        // cutoutImageData is initialzed with the shape to be cut out (whether rectangular or polygonal)
        // and should end up as the cut out image data for the selection
        // canvasImageData is initially the portion of image data on the canvas,
        // and should end up as... the portion of image data on the canvas that it should end up as.
        // @TODO: could simplify by making the later (shared) condition just if(colored_cutout){}
        // but might change how it works anyways so whatever
        // if(!transparency){ // now if !transparency or if tool_transparent_mode
        // this is mainly in order to support patterns as the background color
        // NOTE: must come before cutout canvas is modified
        const colored_cutout = make_canvas(cutout);
        replace_colors_with_swatch(colored_cutout.ctx, colors.background, this.x, this.y);
        // const colored_cutout_image_data = colored_cutout.ctx.getImageData(0, 0, this.width, this.height);
        // }
        for (let i = 0; i < cutoutImageData.data.length; i += 4) {
          const in_cutout = cutoutImageData.data[i + 3] > 0;
          if (in_cutout) {
            cutoutImageData.data[i + 0] = canvasImageData.data[i + 0];
            cutoutImageData.data[i + 1] = canvasImageData.data[i + 1];
            cutoutImageData.data[i + 2] = canvasImageData.data[i + 2];
            cutoutImageData.data[i + 3] = canvasImageData.data[i + 3];
            canvasImageData.data[i + 0] = 0;
            canvasImageData.data[i + 1] = 0;
            canvasImageData.data[i + 2] = 0;
            canvasImageData.data[i + 3] = 0;
          } else {
            cutoutImageData.data[i + 0] = 0;
            cutoutImageData.data[i + 1] = 0;
            cutoutImageData.data[i + 2] = 0;
            cutoutImageData.data[i + 3] = 0;
          }
        }
        ctx.putImageData(canvasImageData, this.x, this.y);
        cutout.ctx.putImageData(cutoutImageData, 0, 0);
        this.update_tool_transparent_mode();
        // NOTE: in case you want to use the tool_transparent_mode
        // in a document with transparency (for an operation in an area where there's a local background color)
        // (and since currently switching to the opaque document mode makes the image opaque)
        // (and it would be complicated to make it update the canvas when switching tool options (as opposed to just the selection))
        // I'm having it use the tool_transparent_mode option here, so you could at least choose beforehand
        // (and this might actually give you more options, although it could be confusingly inconsistent)
        // @FIXME: yeah, this is confusing; if you have both transparency modes on and you try to clear an area to transparency, it doesn't work
        // and there's no indication that you should try the other selection transparency mode,
        // and even if you do, if you do it after creating a selection, it still won't work,
        // because you will have already *not cut out* the selection from the canvas
        if (!transparency || tool_transparent_mode) {
          ctx.drawImage(colored_cutout, this.x, this.y);
        }

        $G.triggerHandler("session-update"); // autosave
        update_helper_layer();
      }
      update_tool_transparent_mode() {
        const sourceImageData = this.source_canvas.ctx.getImageData(0, 0, this.width, this.height);
        const cutoutImageData = this.canvas.ctx.createImageData(this.width, this.height);
        const background_color_rgba = get_rgba_from_color(colors.background);
        // NOTE: In b&w mode, mspaint treats the transparency color as white,
        // regardless of the pattern selected, even if the selected background color is pure black.
        // We allow any kind of image data while in our "b&w mode".
        // Our b&w mode is essentially 'patterns in the palette'.
        for (let i = 0; i < cutoutImageData.data.length; i += 4) {
          let in_cutout = sourceImageData.data[i + 3] > 0;
          if (tool_transparent_mode) {
            // @FIXME: work with transparent selected background color
            // (support treating partially transparent background colors as transparency)
            if (sourceImageData.data[i + 0] === background_color_rgba[0] &&
              sourceImageData.data[i + 1] === background_color_rgba[1] &&
              sourceImageData.data[i + 2] === background_color_rgba[2] &&
              sourceImageData.data[i + 3] === background_color_rgba[3]) {
              in_cutout = false;
            }
          }
          if (in_cutout) {
            cutoutImageData.data[i + 0] = sourceImageData.data[i + 0];
            cutoutImageData.data[i + 1] = sourceImageData.data[i + 1];
            cutoutImageData.data[i + 2] = sourceImageData.data[i + 2];
            cutoutImageData.data[i + 3] = sourceImageData.data[i + 3];
          } else {
            // cutoutImageData.data[i+0] = 0;
            // cutoutImageData.data[i+1] = 0;
            // cutoutImageData.data[i+2] = 0;
            // cutoutImageData.data[i+3] = 0;
          }
        }
        this.canvas.ctx.putImageData(cutoutImageData, 0, 0);

        update_helper_layer();
      }
      // @TODO: should Image > Invert apply to this.source_canvas or to this.canvas (replacing this.source_canvas with the result)?
      replace_source_canvas(new_source_canvas) {
        this.source_canvas = new_source_canvas;
        const new_canvas = make_canvas(new_source_canvas);
        $(this.canvas).replaceWith(new_canvas);
        this.canvas = new_canvas;
        const center_x = this.x + this.width / 2;
        const center_y = this.y + this.height / 2;
        const new_width = new_canvas.width;
        const new_height = new_canvas.height;
        // NOTE: flooring the coordinates to integers avoids blurring
        // but it introduces "inching", where the selection can move along by pixels if you rotate it repeatedly
        // could introduce an "error offset" just to avoid this but that seems overkill
        // and then that would be weird hidden behavior, probably not worth it
        // Math.round() might make it do it on fewer occasions(?),
        // but then it goes down *and* to the right, 2 directions vs One Direction
        // and Math.ceil() is the worst of both worlds
        this.x = ~~(center_x - new_width / 2);
        this.y = ~~(center_y - new_height / 2);
        this.width = new_width;
        this.height = new_height;
        this.position();
        $(this.canvas).on("pointerdown", this.canvas_pointerdown);
        this.$el.triggerHandler("resize"); //?
        this.update_tool_transparent_mode();
      }
      resize() {
        const new_source_canvas = make_canvas(this.width, this.height);
        new_source_canvas.ctx.drawImage(this.source_canvas, 0, 0, this.width, this.height);
        this.replace_source_canvas(new_source_canvas);
      }
      scale(factor) {
        const new_source_canvas = make_canvas(this.width * factor, this.height * factor);
        new_source_canvas.ctx.drawImage(this.source_canvas, 0, 0, new_source_canvas.width, new_source_canvas.height);
        this.replace_source_canvas(new_source_canvas);
      }
      draw() {
        try {
          ctx.drawImage(this.canvas, this.x, this.y);
        }
        // eslint-disable-next-line no-empty
        catch (e) {}
      }
      destroy() {
        super.destroy();
        $G.off("option-changed", this._on_option_changed);
        update_helper_layer(); // @TODO: under-grid specific helper layer?
      }
    }
  </script>
  <script>
    class OnCanvasTextBox extends OnCanvasObject {
      constructor(x, y, width, height, starting_text) {
        super(x, y, width, height, true);

        this.$el.addClass("textbox");
        this.$editor = $(E("textarea")).addClass("textbox-editor");

        var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("version", 1.1);
        var foreignObject = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
        foreignObject.setAttribute("x", 0);
        foreignObject.setAttribute("y", 0);
        svg.append(foreignObject);

        // inline styles so that they'll be serialized for the SVG
        this.$editor.css({
          "position": "absolute",
          "left": "0",
          "top": "0",
          "right": "0",
          "bottom": "0",
          "padding": "0",
          "margin": "0",
          "border": "0",
          "resize": "none",
          "overflow": "hidden",
        });
        var edit_textarea = this.$editor[0];
        var render_textarea = edit_textarea.cloneNode(false);
        foreignObject.append(render_textarea);

        edit_textarea.value = starting_text || "";

        this.canvas = make_canvas(width, height);
        this.canvas.style.pointerEvents = "none";
        this.$el.append(this.canvas);

        const update = () => {
          requestAnimationFrame(() => {
            edit_textarea.scrollTop = 0; // prevent scrolling edit textarea to keep in sync
          });

          svg.setAttribute("width", this.width);
          svg.setAttribute("height", this.height);
          foreignObject.setAttribute("width", this.width);
          foreignObject.setAttribute("height", this.height);

          const font = text_tool_font;
          font.color = colors.foreground;
          font.background = tool_transparent_mode ? "transparent" : colors.background;
          this.$editor.add(this.canvas).css({
            transform: `scale(${magnification})`,
            transformOrigin: "left top",
          });
          this.$editor.add(render_textarea).css({
            width: this.width,
            height: this.height,
            fontFamily: font.family,
            fontSize: `${font.size}px`,
            fontWeight: font.bold ? "bold" : "normal",
            fontStyle: font.italic ? "italic" : "normal",
            textDecoration: font.underline ? "underline" : "none",
            writingMode: font.vertical ? "vertical-lr" : "",
            MsWritingMode: font.vertical ? "vertical-lr" : "",
            WebkitWritingMode: font.vertical ? "vertical-lr" : "",
            lineHeight: `${font.size * font.line_scale}px`,
            color: font.color,
            background: font.background,
          });

          while (render_textarea.firstChild) {
            render_textarea.removeChild(render_textarea.firstChild);
          }
          render_textarea.appendChild(document.createTextNode(edit_textarea.value));

          var svg_source = new XMLSerializer().serializeToString(svg);
          var data_url = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svg_source)}`;

          var img = new Image();
          img.onload = () => {
            this.canvas.width = this.width;
            this.canvas.height = this.height;
            this.canvas.ctx.drawImage(img, 0, 0);
            update_helper_layer(); // @TODO: under-grid specific helper layer?
          };
          img.onerror = (e) => {
            window.console && console.log("Failed to load image", e);
          };
          img.src = data_url;
        };

        update();
        $G.on("option-changed", this._on_option_changed = update);
        this.$editor.on("input", this._on_input = update);
        this.$editor.on("scroll", this._on_scroll = () => {
          requestAnimationFrame(() => {
            edit_textarea.scrollTop = 0; // prevent scrolling edit textarea to keep in sync
          });
        });


        this.$el.css({
          cursor: make_css_cursor("move", [8, 8], "move")
        });
        this.$el.attr("touch-action", "none");
        this.position();

        this.$el.append(this.$editor);
        this.$editor[0].focus();
        const getRect = () => ({
          left: this.x,
          top: this.y,
          width: this.width,
          height: this.height,
          right: this.x + this.width,
          bottom: this.y + this.height
        })
        this.$handles = $Handles(this.$el, getRect, {
          outset: 2
        });
        this.$el.on("user-resized", (e, delta_x, delta_y, width, height) => {
          this.x += delta_x;
          this.y += delta_y;
          this.width = width;
          this.height = height;
          this.position();
          update();
        });
        let mox, moy; // mouse offset
        const pointermove = e => {
          const m = to_canvas_coords(e);
          this.x = Math.max(Math.min(m.x - mox, canvas.width), -this.width);
          this.y = Math.max(Math.min(m.y - moy, canvas.height), -this.height);
          this.position();
          if (e.shiftKey) {
            // @TODO: maybe re-enable but handle undoables well
            // this.draw();
          }
        };
        this.$el.on("pointerdown", e => {
          if (e.target instanceof HTMLInputElement ||
            e.target instanceof HTMLTextAreaElement ||
            e.target.classList.contains("handle")) {
            return;
          }
          e.preventDefault();
          const rect = this.$el[0].getBoundingClientRect();
          const cx = e.clientX - rect.left;
          const cy = e.clientY - rect.top;
          mox = ~~(cx / rect.width * this.canvas.width);
          moy = ~~(cy / rect.height * this.canvas.height);
          $G.on("pointermove", pointermove);
          $G.one("pointerup", () => {
            $G.off("pointermove", pointermove);
          });
        });
        $status_position.text("");
        $status_size.text("");
        $canvas_area.trigger("resize"); // to update handles, get them to hide?

        if (OnCanvasTextBox.$fontbox && OnCanvasTextBox.$fontbox.closed) {
          OnCanvasTextBox.$fontbox = null;
        }
        const $fb = OnCanvasTextBox.$fontbox = OnCanvasTextBox.$fontbox || new $FontBox();
        const displace_font_box = () => {
          // move the font box out of the way if it's overlapping the OnCanvasTextBox
          const fb_rect = $fb[0].getBoundingClientRect();
          const tb_rect = this.$el[0].getBoundingClientRect();
          if (
            // the fontbox overlaps textbox
            fb_rect.left <= tb_rect.right &&
            tb_rect.left <= fb_rect.right &&
            fb_rect.top <= tb_rect.bottom &&
            tb_rect.top <= fb_rect.bottom
          ) {
            // move the font box out of the way
            $fb.css({
              top: this.$el.position().top - $fb.height()
            });
          }
          $fb.applyBounds();
        };
        displace_font_box();

        // In case a software keyboard opens, like Optikey for eye gaze / head tracking users,
        // or perhaps a handwriting input for pen tablet users, or *partially* for mobile browsers.
        // Mobile browsers generally scroll the view for a textbox well enough, but
        // don't include the custom behavior of moving the font box out of the way.
        $(window).on("resize", this._on_window_resize = () => {
          this.$editor[0].scrollIntoView({
            block: 'nearest',
            inline: 'nearest'
          });
          displace_font_box();
        });
      }
      position() {
        super.position(true);
        update_helper_layer(); // @TODO: under-grid specific helper layer?
      }
      destroy() {
        super.destroy();
        if (OnCanvasTextBox.$fontbox && !OnCanvasTextBox.$fontbox.closed) {
          OnCanvasTextBox.$fontbox.close();
        }
        OnCanvasTextBox.$fontbox = null;
        $G.off("option-changed", this._on_option_changed);
        this.$editor.off("input", this._on_input);
        this.$editor.off("scroll", this._on_scroll);
        $(window).off("resize", this._on_window_resize);
        update_helper_layer(); // @TODO: under-grid specific helper layer?
      }
    }
  </script>
  <script>
    class OnCanvasHelperLayer extends OnCanvasObject {
      constructor(x, y, width, height, hideMainCanvasHandles, pixelRatio = 1) {
        super(x, y, width, height, hideMainCanvasHandles);

        this.$el.addClass("helper-layer");
        this.$el.css({
          pointerEvents: "none",
        });
        this.position();
        this.canvas = make_canvas(this.width * pixelRatio, this.height * pixelRatio);
        this.$el.append(this.canvas);
      }
    }
  </script>
  <script>
    function get_brush_canvas_size(brush_size, brush_shape) {
      // brush_shape optional, only matters if it's circle
      // @TODO: does it actually still matter? the ellipse drawing code has changed

      // round to nearest even number in order for the canvas to be drawn centered at a point reasonably
      return Math.ceil(brush_size * (brush_shape === "circle" ? 2.1 : 1) / 2) * 2;
    }

    function render_brush(ctx, shape, size) {
      // USAGE NOTE: must be called outside of any other usage of op_canvas (because of draw_ellipse)
      if (shape.match(/diagonal/)) {
        size -= 0.4;
      }

      const mid_x = Math.round(ctx.canvas.width / 2);
      const left = Math.round(mid_x - size / 2);
      const right = Math.round(mid_x + size / 2);
      const mid_y = Math.round(ctx.canvas.height / 2);
      const top = Math.round(mid_y - size / 2);
      const bottom = Math.round(mid_y + size / 2);

      if (shape === "circle") {
        // @TODO: ideally _without_pattern_support
        draw_ellipse(ctx, left, top, size, size, false, true);
        // was useful for testing:
        // ctx.fillStyle = "red";
        // ctx.fillRect(mid_x, mid_y, 1, 1);
      } else if (shape === "square") {
        ctx.fillRect(left, top, ~~size, ~~size);
      } else if (shape === "diagonal") {
        draw_line_without_pattern_support(ctx, left, top, right, bottom);
      } else if (shape === "reverse_diagonal") {
        draw_line_without_pattern_support(ctx, left, bottom, right, top);
      } else if (shape === "horizontal") {
        draw_line_without_pattern_support(ctx, left, mid_y, size, mid_y);
      } else if (shape === "vertical") {
        draw_line_without_pattern_support(ctx, mid_x, top, mid_x, size);
      }
    }

    function draw_ellipse(ctx, x, y, w, h, stroke, fill) {
      const center_x = x + w / 2;
      const center_y = y + h / 2;

      if (aliasing) {
        const points = [];
        const step = 0.05;
        for (let theta = 0; theta < TAU; theta += step) {
          points.push({
            x: center_x + Math.cos(theta) * w / 2,
            y: center_y + Math.sin(theta) * h / 2,
          });
        }
        draw_polygon(ctx, points, stroke, fill);
      } else {
        if (w < 0) {
          x += w;
          w = -w;
        }
        if (h < 0) {
          y += h;
          h = -h;
        }
        ctx.beginPath();
        ctx.ellipse(center_x, center_y, w / 2, h / 2, 0, TAU, false);
        ctx.stroke();
        ctx.fill();
      }
    }

    function draw_rounded_rectangle(ctx, x, y, width, height, radius_x, radius_y, stroke, fill) {

      if (aliasing) {
        const points = [];
        const lineTo = (x, y) => {
          points.push({
            x,
            y
          });
        };
        const arc = (x, y, radius_x, radius_y, startAngle, endAngle) => {
          const step = 0.05;
          for (let theta = startAngle; theta < endAngle; theta += step) {
            points.push({
              x: x + Math.cos(theta) * radius_x,
              y: y + Math.sin(theta) * radius_y,
            });
          }
          // not just doing `theta <= endAngle` above because that doesn't account for floating point rounding errors
          points.push({
            x: x + Math.cos(endAngle) * radius_x,
            y: y + Math.sin(endAngle) * radius_y,
          });
        };

        const x2 = x + width;
        const y2 = y + height;
        arc(x2 - radius_x, y + radius_y, radius_x, radius_y, TAU * 3 / 4, TAU, false);
        lineTo(x2, y2 - radius_y);
        arc(x2 - radius_x, y2 - radius_y, radius_x, radius_y, 0, TAU * 1 / 4, false);
        lineTo(x + radius_x, y2);
        arc(x + radius_x, y2 - radius_y, radius_x, radius_y, TAU * 1 / 4, TAU * 1 / 2, false);
        lineTo(x, y + radius_y);
        arc(x + radius_x, y + radius_y, radius_x, radius_y, TAU / 2, TAU * 3 / 4, false);

        draw_polygon(ctx, points, stroke, fill);
      } else {
        ctx.beginPath();
        ctx.moveTo(x + radius_x, y);
        ctx.lineTo(x + width - radius_x, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius_y);
        ctx.lineTo(x + width, y + height - radius_y);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius_x, y + height);
        ctx.lineTo(x + radius_x, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius_y);
        ctx.lineTo(x, y + radius_y);
        ctx.quadraticCurveTo(x, y, x + radius_x, y);
        ctx.closePath();
        if (stroke) {
          ctx.stroke();
        }
        if (fill) {
          ctx.fill();
        }
      }
    }

    // USAGE NOTE: must be called outside of any other usage of op_canvas (because of render_brush)
    // @TODO: protect against browser clearing canvases, invalidate cache
    const get_brush_canvas = memoize_synchronous_function((brush_shape, brush_size) => {
      const canvas_size = get_brush_canvas_size(brush_size, brush_shape);

      const brush_canvas = make_canvas(canvas_size, canvas_size);

      // brush_canvas.ctx.fillStyle = brush_canvas.ctx.strokeStyle = "black";
      render_brush(brush_canvas.ctx, brush_shape, brush_size);

      return brush_canvas;
    }, 20); // 12 brush tool options + current brush + current pencil + current eraser + current shape stroke + a few

    $G.on("invalidate-brush-canvases", () => {
      get_brush_canvas.clear_memo_cache();
    });


    // USAGE NOTE: must be called outside of any other usage of op_canvas (because of render_brush)
    const stamp_brush_canvas = (ctx, x, y, brush_shape, brush_size) => {
      const brush_canvas = get_brush_canvas(brush_shape, brush_size);

      const offset_x = -Math.ceil(brush_canvas.width / 2);
      const offset_y = -Math.ceil(brush_canvas.height / 2);

      ctx.drawImage(brush_canvas, x + offset_x, y + offset_y);
    };

    // USAGE NOTE: must be called outside of any other usage of op_canvas (because of render_brush)
    const get_circumference_points_for_brush = memoize_synchronous_function((brush_shape, brush_size) => {

      const brush_canvas = get_brush_canvas(brush_shape, brush_size);

      const image_data = brush_canvas.ctx.getImageData(0, 0, brush_canvas.width, brush_canvas.height);

      const at = (x, y) => image_data.data[(y * image_data.width + x) * 4 + 3] > 0;

      const offset_x = -Math.ceil(brush_canvas.width / 2);
      const offset_y = -Math.ceil(brush_canvas.height / 2);

      const points = [];

      for (let x = 0; x < image_data.width; x += 1) {
        for (let y = 0; y < image_data.height; y += 1) {
          if (at(x, y) && (
              !at(x, y - 1) ||
              !at(x, y + 1) ||
              !at(x - 1, y) ||
              !at(x + 1, y)
            )) {
            points.push({
              x: x + offset_x,
              y: y + offset_y,
            });
          }
        }
      }

      return points;
    });

    $G.on("invalidate-brush-canvases", () => {
      get_circumference_points_for_brush.clear_memo_cache();
    });


    let line_brush_canvas;
    // USAGE NOTE: must be called outside of any other usage of op_canvas (because of render_brush)
    function update_brush_for_drawing_lines(stroke_size) {
      if (aliasing && stroke_size > 1) {
        line_brush_canvas = get_brush_canvas("circle", stroke_size);
      }
    }

    function draw_line_without_pattern_support(ctx, x1, y1, x2, y2, stroke_size = 1) {
      if (aliasing) {
        if (stroke_size > 1) {
          bresenham_line(x1, y1, x2, y2, (x, y) => {
            ctx.drawImage(line_brush_canvas, ~~(x - line_brush_canvas.width / 2), ~~(y - line_brush_canvas.height / 2));
          });
        } else {
          bresenham_line(x1, y1, x2, y2, (x, y) => {
            ctx.fillRect(x, y, 1, 1);
          });
        }
      } else {
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);

        ctx.lineWidth = stroke_size;
        ctx.lineCap = "round";
        ctx.stroke();
        ctx.lineCap = "butt";
      }
    }

    function bresenham_line(x1, y1, x2, y2, callback) {
      // Bresenham's line algorithm
      x1 = ~~x1, x2 = ~~x2, y1 = ~~y1, y2 = ~~y2;

      const dx = Math.abs(x2 - x1);
      const dy = Math.abs(y2 - y1);
      const sx = (x1 < x2) ? 1 : -1;
      const sy = (y1 < y2) ? 1 : -1;
      let err = dx - dy;

      // eslint-disable-next-line no-constant-condition
      while (true) {
        callback(x1, y1);

        if (x1 === x2 && y1 === y2) break;
        const e2 = err * 2;
        if (e2 > -dy) {
          err -= dy;
          x1 += sx;
        }
        if (e2 < dx) {
          err += dx;
          y1 += sy;
        }
      }
    }

    function brosandham_line(x1, y1, x2, y2, callback) {
      // Bresenham's line argorithm with a callback between going horizontal and vertical
      x1 = ~~x1, x2 = ~~x2, y1 = ~~y1, y2 = ~~y2;

      const dx = Math.abs(x2 - x1);
      const dy = Math.abs(y2 - y1);
      const sx = (x1 < x2) ? 1 : -1;
      const sy = (y1 < y2) ? 1 : -1;
      let err = dx - dy;

      // eslint-disable-next-line no-constant-condition
      while (true) {
        callback(x1, y1);

        if (x1 === x2 && y1 === y2) break;
        const e2 = err * 2;
        if (e2 > -dy) {
          err -= dy;
          x1 += sx;
        }
        callback(x1, y1);
        if (e2 < dx) {
          err += dx;
          y1 += sy;
        }
      }
    }

    function draw_fill_without_pattern_support(ctx, start_x, start_y, fill_r, fill_g, fill_b, fill_a) {

      // @TODO: split up processing in case it takes too long?
      // progress bar and abort button (outside of image-manipulation.js)
      // or at least just free up the main thread every once in a while
      // @TODO: speed up with typed arrays? https://hacks.mozilla.org/2011/12/faster-canvas-pixel-manipulation-with-typed-arrays/
      // could avoid endianness issues if only copying colors
      // the jsperf only shows ~15% improvement
      // maybe do something fancier like special-casing large chunks of single-color image
      // (octree? or just have a higher level stack of chunks to fill and check at if a chunk is homogeneous)

      const stack = [
        [start_x, start_y]
      ];
      const c_width = canvas.width;
      const c_height = canvas.height;
      const id = ctx.getImageData(0, 0, c_width, c_height);
      let pixel_pos = (start_y * c_width + start_x) * 4;
      const start_r = id.data[pixel_pos + 0];
      const start_g = id.data[pixel_pos + 1];
      const start_b = id.data[pixel_pos + 2];
      const start_a = id.data[pixel_pos + 3];

      if (
        fill_r === start_r &&
        fill_g === start_g &&
        fill_b === start_b &&
        fill_a === start_a
      ) {
        return;
      }

      while (stack.length) {
        let new_pos;
        let x;
        let y;
        let reach_left;
        let reach_right;
        new_pos = stack.pop();
        x = new_pos[0];
        y = new_pos[1];

        pixel_pos = (y * c_width + x) * 4;
        while (should_fill_at(pixel_pos)) {
          y--;
          pixel_pos = (y * c_width + x) * 4;
        }
        reach_left = false;
        reach_right = false;
        // eslint-disable-next-line no-constant-condition
        while (true) {
          y++;
          pixel_pos = (y * c_width + x) * 4;

          if (!(y < c_height && should_fill_at(pixel_pos))) {
            break;
          }

          do_fill_at(pixel_pos);

          if (x > 0) {
            if (should_fill_at(pixel_pos - 4)) {
              if (!reach_left) {
                stack.push([x - 1, y]);
                reach_left = true;
              }
            } else if (reach_left) {
              reach_left = false;
            }
          }

          if (x < c_width - 1) {
            if (should_fill_at(pixel_pos + 4)) {
              if (!reach_right) {
                stack.push([x + 1, y]);
                reach_right = true;
              }
            } else if (reach_right) {
              reach_right = false;
            }
          }

          pixel_pos += c_width * 4;
        }
      }
      ctx.putImageData(id, 0, 0);

      function should_fill_at(pixel_pos) {
        return (
          // matches start color (i.e. region to fill)
          id.data[pixel_pos + 0] === start_r &&
          id.data[pixel_pos + 1] === start_g &&
          id.data[pixel_pos + 2] === start_b &&
          id.data[pixel_pos + 3] === start_a
        );
      }

      function do_fill_at(pixel_pos) {
        id.data[pixel_pos + 0] = fill_r;
        id.data[pixel_pos + 1] = fill_g;
        id.data[pixel_pos + 2] = fill_b;
        id.data[pixel_pos + 3] = fill_a;
      }
    }

    function draw_fill(ctx, start_x, start_y, swatch) {
      if (typeof swatch === "string") {
        const fill_rgba = get_rgba_from_color(swatch);
        draw_fill_without_pattern_support(ctx, start_x, start_y, fill_rgba[0], fill_rgba[1], fill_rgba[2], fill_rgba[3]);
      } else {
        const source_canvas = ctx.canvas;
        const fill_canvas = make_canvas(source_canvas.width, source_canvas.height);
        draw_fill_separately(source_canvas.ctx, fill_canvas.ctx, start_x, start_y, 255, 255, 255, 255);
        replace_colors_with_swatch(fill_canvas.ctx, swatch, 0, 0);
        ctx.drawImage(fill_canvas, 0, 0);
      }
    }

    function draw_fill_separately(source_ctx, dest_ctx, start_x, start_y, fill_r, fill_g, fill_b, fill_a) {
      const stack = [
        [start_x, start_y]
      ];
      const c_width = source_ctx.canvas.width;
      const c_height = source_ctx.canvas.height;
      const source_id = source_ctx.getImageData(0, 0, c_width, c_height);
      const dest_id = dest_ctx.getImageData(0, 0, c_width, c_height);
      let pixel_pos = (start_y * c_width + start_x) * 4;
      const start_r = source_id.data[pixel_pos + 0];
      const start_g = source_id.data[pixel_pos + 1];
      const start_b = source_id.data[pixel_pos + 2];
      const start_a = source_id.data[pixel_pos + 3];

      while (stack.length) {
        let new_pos;
        let x;
        let y;
        let reach_left;
        let reach_right;
        new_pos = stack.pop();
        x = new_pos[0];
        y = new_pos[1];

        pixel_pos = (y * c_width + x) * 4;
        while (should_fill_at(pixel_pos)) {
          y--;
          pixel_pos = (y * c_width + x) * 4;
        }
        reach_left = false;
        reach_right = false;
        // eslint-disable-next-line no-constant-condition
        while (true) {
          y++;
          pixel_pos = (y * c_width + x) * 4;

          if (!(y < c_height && should_fill_at(pixel_pos))) {
            break;
          }

          do_fill_at(pixel_pos);

          if (x > 0) {
            if (should_fill_at(pixel_pos - 4)) {
              if (!reach_left) {
                stack.push([x - 1, y]);
                reach_left = true;
              }
            } else if (reach_left) {
              reach_left = false;
            }
          }

          if (x < c_width - 1) {
            if (should_fill_at(pixel_pos + 4)) {
              if (!reach_right) {
                stack.push([x + 1, y]);
                reach_right = true;
              }
            } else if (reach_right) {
              reach_right = false;
            }
          }

          pixel_pos += c_width * 4;
        }
      }
      dest_ctx.putImageData(dest_id, 0, 0);

      function should_fill_at(pixel_pos) {
        return (
          // not reached yet
          dest_id.data[pixel_pos + 3] === 0 &&
          // and matches start color (i.e. region to fill)
          (
            source_id.data[pixel_pos + 0] === start_r &&
            source_id.data[pixel_pos + 1] === start_g &&
            source_id.data[pixel_pos + 2] === start_b &&
            source_id.data[pixel_pos + 3] === start_a
          )
        );
      }

      function do_fill_at(pixel_pos) {
        dest_id.data[pixel_pos + 0] = fill_r;
        dest_id.data[pixel_pos + 1] = fill_g;
        dest_id.data[pixel_pos + 2] = fill_b;
        dest_id.data[pixel_pos + 3] = fill_a;
      }
    }

    function replace_color_globally(image_data, from_r, from_g, from_b, from_a, to_r, to_g, to_b, to_a) {
      if (
        from_r === to_r &&
        from_g === to_g &&
        from_b === to_b &&
        from_a === to_a
      ) {
        return;
      }
      const {
        data
      } = image_data;
      for (let i = 0; i < data.length; i += 4) {
        if (
          data[i + 0] === from_r &&
          data[i + 1] === from_g &&
          data[i + 2] === from_b &&
          data[i + 3] === from_a
        ) {
          data[i + 0] = to_r;
          data[i + 1] = to_g;
          data[i + 2] = to_b;
          data[i + 3] = to_a;
        }
      }
    }

    function find_color_globally(source_image_data, dest_image_data, find_r, find_g, find_b, find_a) {
      const source_data = source_image_data.data;
      const dest_data = dest_image_data.data;
      for (let i = 0; i < source_data.length; i += 4) {
        if (
          source_data[i + 0] === find_r &&
          source_data[i + 1] === find_g &&
          source_data[i + 2] === find_b &&
          source_data[i + 3] === find_a
        ) {
          dest_data[i + 0] = 255;
          dest_data[i + 1] = 255;
          dest_data[i + 2] = 255;
          dest_data[i + 3] = 255;
        }
      }
    }

    function draw_noncontiguous_fill_without_pattern_support(ctx, x, y, fill_r, fill_g, fill_b, fill_a) {
      const image_data = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
      const start_index = (y * image_data.width + x) * 4;
      const start_r = image_data.data[start_index + 0];
      const start_g = image_data.data[start_index + 1];
      const start_b = image_data.data[start_index + 2];
      const start_a = image_data.data[start_index + 3];

      replace_color_globally(image_data, start_r, start_g, start_b, start_a, fill_r, fill_g, fill_b, fill_a);

      ctx.putImageData(image_data, 0, 0);
    }

    function draw_noncontiguous_fill(ctx, x, y, swatch) {
      if (typeof swatch === "string") {
        const fill_rgba = get_rgba_from_color(swatch);
        draw_noncontiguous_fill_without_pattern_support(ctx, x, y, fill_rgba[0], fill_rgba[1], fill_rgba[2], fill_rgba[3]);
      } else {
        const source_canvas = ctx.canvas;
        const fill_canvas = make_canvas(source_canvas.width, source_canvas.height);
        draw_noncontiguous_fill_separately(source_canvas.ctx, fill_canvas.ctx, x, y);
        replace_colors_with_swatch(fill_canvas.ctx, swatch, 0, 0);
        ctx.drawImage(fill_canvas, 0, 0);
      }
    }

    function draw_noncontiguous_fill_separately(source_ctx, dest_ctx, x, y) {
      const source_image_data = source_ctx.getImageData(0, 0, source_ctx.canvas.width, source_ctx.canvas.height);
      const dest_image_data = dest_ctx.getImageData(0, 0, dest_ctx.canvas.width, dest_ctx.canvas.height);
      const start_index = (y * source_image_data.width + x) * 4;
      const start_r = source_image_data.data[start_index + 0];
      const start_g = source_image_data.data[start_index + 1];
      const start_b = source_image_data.data[start_index + 2];
      const start_a = source_image_data.data[start_index + 3];

      find_color_globally(source_image_data, dest_image_data, start_r, start_g, start_b, start_a);

      dest_ctx.putImageData(dest_image_data, 0, 0);
    }

    function apply_image_transformation(meta, fn) {
      // Apply an image transformation function to either the selection or the entire canvas
      const original_canvas = selection ? selection.source_canvas : canvas;

      const new_canvas = make_canvas(original_canvas.width, original_canvas.height);

      const original_ctx = original_canvas.getContext("2d");
      const new_ctx = new_canvas.getContext("2d");

      fn(original_canvas, original_ctx, new_canvas, new_ctx);

      if (selection) {
        undoable({
          name: `${meta.name} (Selection)`,
          icon: meta.icon,
          soft: true,
        }, () => {
          selection.replace_source_canvas(new_canvas);
        });
      } else {
        deselect();
        cancel();
        undoable({
          name: meta.name,
          icon: meta.icon,
        }, () => {
          saved = false;

          ctx.copy(new_canvas);

          $canvas.trigger("update"); // update handles
        });
      }
    }

    function flip_horizontal() {
      apply_image_transformation({
        name: "Flip Horizontal",
        icon: get_help_folder_icon("p_fliph.png"),
      }, (original_canvas, original_ctx, new_canvas, new_ctx) => {
        new_ctx.translate(new_canvas.width, 0);
        new_ctx.scale(-1, 1);
        new_ctx.drawImage(original_canvas, 0, 0);
      });
    }

    function flip_vertical() {
      apply_image_transformation({
        name: "Flip Vertical",
        icon: get_help_folder_icon("p_flipv.png"),
      }, (original_canvas, original_ctx, new_canvas, new_ctx) => {
        new_ctx.translate(0, new_canvas.height);
        new_ctx.scale(1, -1);
        new_ctx.drawImage(original_canvas, 0, 0);
      });
    }

    function rotate(angle) {
      apply_image_transformation({
        name: `Rotate ${angle / TAU * 360} degrees`,
        icon: get_help_folder_icon(`p_rotate_${angle >= 0 ? "cw" : "ccw"}.png`),
      }, (original_canvas, original_ctx, new_canvas, new_ctx) => {
        new_ctx.save();
        switch (angle) {
          case TAU / 4:
          case TAU * -3 / 4:
            new_canvas.width = original_canvas.height;
            new_canvas.height = original_canvas.width;
            new_ctx.disable_image_smoothing();
            new_ctx.translate(new_canvas.width, 0);
            new_ctx.rotate(TAU / 4);
            break;
          case TAU / 2:
          case TAU / -2:
            new_ctx.translate(new_canvas.width, new_canvas.height);
            new_ctx.rotate(TAU / 2);
            break;
          case TAU * 3 / 4:
          case TAU / -4:
            new_canvas.width = original_canvas.height;
            new_canvas.height = original_canvas.width;
            new_ctx.disable_image_smoothing();
            new_ctx.translate(0, new_canvas.height);
            new_ctx.rotate(TAU / -4);
            break;
          default: {
            const w = original_canvas.width;
            const h = original_canvas.height;

            let bb_min_x = +Infinity;
            let bb_max_x = -Infinity;
            let bb_min_y = +Infinity;
            let bb_max_y = -Infinity;
            const corner = (x01, y01) => {
              const x = Math.sin(-angle) * h * x01 + Math.cos(+angle) * w * y01;
              const y = Math.sin(+angle) * w * y01 + Math.cos(-angle) * h * x01;
              bb_min_x = Math.min(bb_min_x, x);
              bb_max_x = Math.max(bb_max_x, x);
              bb_min_y = Math.min(bb_min_y, y);
              bb_max_y = Math.max(bb_max_y, y);
            };

            corner(0, 0);
            corner(0, 1);
            corner(1, 0);
            corner(1, 1);

            const bb_x = bb_min_x;
            const bb_y = bb_min_y;
            const bb_w = bb_max_x - bb_min_x;
            const bb_h = bb_max_y - bb_min_y;

            new_canvas.width = bb_w;
            new_canvas.height = bb_h;
            new_ctx.disable_image_smoothing();

            if (!transparency) {
              new_ctx.fillStyle = colors.background;
              new_ctx.fillRect(0, 0, new_canvas.width, new_canvas.height);
            }

            new_ctx.translate(-bb_x, -bb_y);
            new_ctx.rotate(angle);
            new_ctx.drawImage(original_canvas, 0, 0, w, h);
            break;
          }
        }
        new_ctx.drawImage(original_canvas, 0, 0);
        new_ctx.restore();
      });
    }

    function stretch_and_skew(xscale, yscale, hsa, vsa) {
      apply_image_transformation({
        name: (hsa !== 0 || vsa !== 0) ? (
          (xscale !== 1 || yscale !== 1) ? "Stretch/Skew" : "Skew"
        ) : "Stretch",
        icon: get_help_folder_icon(
          (hsa !== 0) ? "p_skew_h.png" :
          (vsa !== 0) ? "p_skew_v.png" :
          (yscale !== 1) ? (
            (xscale !== 1) ? "p_stretch_both.png" : "p_stretch_v.png"
          ) : "p_stretch_h.png"
        ),
      }, (original_canvas, original_ctx, new_canvas, new_ctx) => {
        const w = original_canvas.width * xscale;
        const h = original_canvas.height * yscale;

        let bb_min_x = +Infinity;
        let bb_max_x = -Infinity;
        let bb_min_y = +Infinity;
        let bb_max_y = -Infinity;
        const corner = (x01, y01) => {
          const x = Math.tan(hsa) * h * x01 + w * y01;
          const y = Math.tan(vsa) * w * y01 + h * x01;
          bb_min_x = Math.min(bb_min_x, x);
          bb_max_x = Math.max(bb_max_x, x);
          bb_min_y = Math.min(bb_min_y, y);
          bb_max_y = Math.max(bb_max_y, y);
        };

        corner(0, 0);
        corner(0, 1);
        corner(1, 0);
        corner(1, 1);

        const bb_x = bb_min_x;
        const bb_y = bb_min_y;
        const bb_w = bb_max_x - bb_min_x;
        const bb_h = bb_max_y - bb_min_y;

        new_canvas.width = Math.max(1, bb_w);
        new_canvas.height = Math.max(1, bb_h);
        new_ctx.disable_image_smoothing();

        if (!transparency) {
          new_ctx.fillStyle = colors.background;
          new_ctx.fillRect(0, 0, new_canvas.width, new_canvas.height);
        }

        new_ctx.save();
        new_ctx.transform(
          1, // x scale
          Math.tan(vsa), // vertical skew (skewY)
          Math.tan(hsa), // horizontal skew (skewX)
          1, // y scale
          -bb_x, // x translation
          -bb_y // y translation
        );
        new_ctx.drawImage(original_canvas, 0, 0, w, h);
        new_ctx.restore();
      });
    }

    function invert_rgb(source_ctx, dest_ctx = source_ctx) {
      const image_data = source_ctx.getImageData(0, 0, source_ctx.canvas.width, source_ctx.canvas.height);
      for (let i = 0; i < image_data.data.length; i += 4) {
        image_data.data[i + 0] = 255 - image_data.data[i + 0];
        image_data.data[i + 1] = 255 - image_data.data[i + 1];
        image_data.data[i + 2] = 255 - image_data.data[i + 2];
      }
      dest_ctx.putImageData(image_data, 0, 0);
    }

    function threshold_black_and_white(ctx, threshold) {
      const image_data = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
      for (let i = 0; i < image_data.data.length; i += 4) {
        const white = (image_data.data[i + 0] + image_data.data[i + 1] + image_data.data[i + 2]) / 3 / 255 > threshold;
        image_data.data[i + 0] = 255 * white;
        image_data.data[i + 1] = 255 * white;
        image_data.data[i + 2] = 255 * white;
        image_data.data[i + 3] = 255;
      }
      ctx.putImageData(image_data, 0, 0);
    }

    function replace_colors_with_swatch(ctx, swatch, x_offset_from_global_canvas = 0, y_offset_from_global_canvas = 0) {
      // USAGE NOTE: Context MUST be untranslated! (for the rectangle to cover the exact area of the canvas, and presumably for the pattern alignment as well)
      // This function is mainly for patterns support (for black & white mode) but naturally handles solid colors as well.
      ctx.globalCompositeOperation = "source-in";
      ctx.fillStyle = swatch;
      ctx.beginPath();
      ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height);
      ctx.save();
      ctx.translate(-x_offset_from_global_canvas, -y_offset_from_global_canvas);
      ctx.fill();
      ctx.restore();
    }

    // adapted from https://github.com/Pomax/bezierjs
    function compute_bezier(t, start_x, start_y, control_1_x, control_1_y, control_2_x, control_2_y, end_x, end_y) {
      const mt = 1 - t;
      const mt2 = mt * mt;
      const t2 = t * t;
      let a, b, c, d = 0;

      a = mt2 * mt;
      b = mt2 * t * 3;
      c = mt * t2 * 3;
      d = t * t2;

      return {
        x: a * start_x + b * control_1_x + c * control_2_x + d * end_x,
        y: a * start_y + b * control_1_y + c * control_2_y + d * end_y
      };
    }

    function draw_bezier_curve_without_pattern_support(ctx, start_x, start_y, control_1_x, control_1_y, control_2_x, control_2_y, end_x, end_y, stroke_size) {
      const steps = 100;
      let point_a = {
        x: start_x,
        y: start_y
      };
      for (let t = 0; t < 1; t += 1 / steps) {
        const point_b = compute_bezier(t, start_x, start_y, control_1_x, control_1_y, control_2_x, control_2_y, end_x, end_y);
        // @TODO: carry "error" from Bresenham line algorithm between iterations? and/or get a proper Bezier drawing algorithm
        draw_line_without_pattern_support(ctx, point_a.x, point_a.y, point_b.x, point_b.y, stroke_size);
        point_a = point_b;
      }
    }

    function draw_quadratic_curve(ctx, start_x, start_y, control_x, control_y, end_x, end_y, stroke_size) {
      draw_bezier_curve(ctx, start_x, start_y, control_x, control_y, control_x, control_y, end_x, end_y, stroke_size);
    }

    function draw_bezier_curve(ctx, start_x, start_y, control_1_x, control_1_y, control_2_x, control_2_y, end_x, end_y, stroke_size) {
      // could calculate bounds of Bezier curve with something like bezier-js
      // but just using the control points should be fine
      const min_x = Math.min(start_x, control_1_x, control_2_x, end_x);
      const min_y = Math.min(start_y, control_1_y, control_2_y, end_y);
      const max_x = Math.max(start_x, control_1_x, control_2_x, end_x);
      const max_y = Math.max(start_y, control_1_y, control_2_y, end_y);
      draw_with_swatch(ctx, min_x, min_y, max_x, max_y, stroke_color, op_ctx_2d => {
        draw_bezier_curve_without_pattern_support(op_ctx_2d, start_x, start_y, control_1_x, control_1_y, control_2_x, control_2_y, end_x, end_y, stroke_size);
      });
    }

    function draw_line(ctx, x1, y1, x2, y2, stroke_size) {
      const min_x = Math.min(x1, x2);
      const min_y = Math.min(y1, y2);
      const max_x = Math.max(x1, x2);
      const max_y = Math.max(y1, y2);
      draw_with_swatch(ctx, min_x, min_y, max_x, max_y, stroke_color, op_ctx_2d => {
        draw_line_without_pattern_support(op_ctx_2d, x1, y1, x2, y2, stroke_size);
      });
      // also works:
      // draw_line_strip(ctx, [{x: x1, y: y1}, {x: x2, y: y2}]);
    }

    let grid_pattern;

    function draw_grid(ctx, scale) {
      const pattern_size = Math.floor(scale); // @TODO: try ceil too
      if (!grid_pattern || grid_pattern.width !== pattern_size || grid_pattern.height !== pattern_size) {
        const grid_pattern_canvas = make_canvas(pattern_size, pattern_size);
        const dark_gray = "#808080";
        const light_gray = "#c0c0c0";
        grid_pattern_canvas.ctx.fillStyle = dark_gray;
        grid_pattern_canvas.ctx.fillRect(0, 0, 1, pattern_size);
        grid_pattern_canvas.ctx.fillStyle = dark_gray;
        grid_pattern_canvas.ctx.fillRect(0, 0, pattern_size, 1);
        grid_pattern_canvas.ctx.fillStyle = light_gray;
        for (let i = 1; i < pattern_size; i += 2) {
          grid_pattern_canvas.ctx.fillRect(i, 0, 1, 1);
          grid_pattern_canvas.ctx.fillRect(0, i, 1, 1);
        }
        grid_pattern = ctx.createPattern(grid_pattern_canvas, "repeat");
      }
      ctx.save();
      ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height);
      if (scale !== pattern_size) {
        ctx.translate(-0.5, -0.75); // hand picked to look "good" at 110% in chrome
        // might be better to just hide the grid in some more cases tho
        // ...@TODO: if I can get helper layer to be pixel aligned, I can probably remove this
      }
      ctx.scale(scale / pattern_size, scale / pattern_size);
      ctx.enable_image_smoothing();
      ctx.fillStyle = grid_pattern;
      ctx.fill();
      ctx.restore();
    }

    (() => {

      // the dashes of the border are sized such that at 4x zoom,
      // they're squares equal to one canvas pixel
      // they're offset by a screen pixel tho from the canvas pixel cells

      const svg_for_creating_matrices = document.createElementNS("http://www.w3.org/2000/svg", "svg");

      const horizontal_pattern_canvas = make_canvas(8, 4);
      const vertical_pattern_canvas = make_canvas(4, 8);
      let horizontal_pattern;
      let vertical_pattern;

      function draw_dashes(ctx, x, y, go_x, go_y, scale, translate_x, translate_y) {
        if (!vertical_pattern) {
          horizontal_pattern_canvas.ctx.fillStyle = "white";
          horizontal_pattern_canvas.ctx.fillRect(4, 0, 4, 4);
          vertical_pattern_canvas.ctx.fillStyle = "white";
          vertical_pattern_canvas.ctx.fillRect(0, 4, 4, 4);
          horizontal_pattern = ctx.createPattern(horizontal_pattern_canvas, "repeat");
          vertical_pattern = ctx.createPattern(vertical_pattern_canvas, "repeat");
        }

        const dash_width = 1;
        const hairline_width = 1 / scale; // size of a screen pixel

        ctx.save();

        ctx.scale(scale, scale);
        ctx.translate(translate_x, translate_y);

        ctx.translate(x, y);
        ctx.globalCompositeOperation = "difference";


        if (go_x > 0) {
          const matrix = svg_for_creating_matrices.createSVGMatrix();
          if (horizontal_pattern.setTransform) { // not supported by Edge as of 2019-12-04
            horizontal_pattern.setTransform(matrix.translate(-x, -y).translate(hairline_width, 0).scale(1 / scale));
          }
          ctx.fillStyle = horizontal_pattern;
          ctx.fillRect(0, 0, go_x, dash_width);
        } else if (go_y > 0) {
          const matrix = svg_for_creating_matrices.createSVGMatrix();
          if (vertical_pattern.setTransform) { // not supported by Edge as of 2019-12-04
            vertical_pattern.setTransform(matrix.translate(-x, -y).translate(0, hairline_width).scale(1 / scale));
          }
          ctx.fillStyle = vertical_pattern;
          ctx.fillRect(0, 0, dash_width, go_y);
        }
        ctx.restore();
      }

      window.draw_selection_box = (ctx, rect_x, rect_y, rect_w, rect_h, scale, translate_x, translate_y) => {
        draw_dashes(ctx, rect_x, rect_y, rect_w - 1, 0, scale, translate_x, translate_y); // top
        if (rect_h === 1) {
          draw_dashes(ctx, rect_x, rect_y, 0, 1, scale, translate_x, translate_y); // left
        } else {
          draw_dashes(ctx, rect_x, rect_y + 1, 0, rect_h - 2, scale, translate_x, translate_y); // left
        }
        draw_dashes(ctx, rect_x + rect_w - 1, rect_y, 0, rect_h, scale, translate_x, translate_y); // right
        draw_dashes(ctx, rect_x, rect_y + rect_h - 1, rect_w - 1, 0, scale, translate_x, translate_y); // bottom
        draw_dashes(ctx, rect_x, rect_y + 1, 0, 1, scale, translate_x, translate_y); // top left dangling bit???
      };

    })();

    (() => {

      const tessy = (function initTesselator() {
        // function called for each vertex of tesselator output
        function vertexCallback(data, polyVertArray) {
          // window.console && console.log(data[0], data[1]);
          polyVertArray[polyVertArray.length] = data[0];
          polyVertArray[polyVertArray.length] = data[1];
        }

        function begincallback(type) {
          if (type !== libtess.primitiveType.GL_TRIANGLES) {
            window.console && console.log(`Expected TRIANGLES but got type: ${type}`);
          }
        }

        function errorcallback(errno) {
          window.console && console.log('error callback');
          window.console && console.log(`error number: ${errno}`);
        }
        // callback for when segments intersect and must be split
        function combinecallback(coords /*, data, weight*/ ) {
          // window.console && console.log('combine callback');
          return [coords[0], coords[1], coords[2]];
        }

        function edgeCallback( /*flag*/ ) {
          // don't really care about the flag, but need no-strip/no-fan behavior
          // window.console && console.log('edge flag: ' + flag);
        }

        const tessy = new libtess.GluTesselator();
        // tessy.gluTessProperty(libtess.gluEnum.GLU_TESS_WINDING_RULE, libtess.windingRule.GLU_TESS_WINDING_POSITIVE);
        tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_VERTEX_DATA, vertexCallback);
        tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_BEGIN, begincallback);
        tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_ERROR, errorcallback);
        tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_COMBINE, combinecallback);
        tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_EDGE_FLAG, edgeCallback);

        return tessy;
      })();

      function triangulate(contours) {
        // libtess will take 3d verts and flatten to a plane for tesselation
        // since only doing 2d tesselation here, provide z=1 normal to skip
        // iterating over verts only to get the same answer.
        tessy.gluTessNormal(0, 0, 1);

        const triangleVerts = [];
        tessy.gluTessBeginPolygon(triangleVerts);

        for (let i = 0; i < contours.length; i++) {
          tessy.gluTessBeginContour();
          const contour = contours[i];
          for (let j = 0; j < contour.length; j += 2) {
            const coords = [contour[j], contour[j + 1], 0];
            tessy.gluTessVertex(coords, coords);
          }
          tessy.gluTessEndContour();
        }

        tessy.gluTessEndPolygon();

        return triangleVerts;
      }


      let gl;
      let positionLoc;

      function initWebGL(canvas) {
        gl = canvas.getContext('webgl', {
          antialias: false
        });

        window.WEBGL_lose_context = gl.getExtension("WEBGL_lose_context");

        const program = createShaderProgram();
        positionLoc = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(positionLoc);
      }

      function initArrayBuffer(triangleVertexCoords) {
        // put triangle coordinates into a WebGL ArrayBuffer and bind to
        // shader's 'position' attribute variable
        const rawData = new Float32Array(triangleVertexCoords);
        const polygonArrayBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, polygonArrayBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, rawData, gl.STATIC_DRAW);
        gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

        return triangleVertexCoords.length / 2;
      }

      function createShaderProgram() {
        // create vertex shader
        const vertexSrc = [
          'attribute vec4 position;',
          'void main() {',
          '	/* already in normalized coordinates, so just pass through */',
          '	gl_Position = position;',
          '}'
        ].join('');
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexSrc);
        gl.compileShader(vertexShader);

        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
          window.console && console.log(
            `Vertex shader failed to compile. Log: ${gl.getShaderInfoLog(vertexShader)}`
          );
        }

        // create fragment shader
        const fragmentSrc = [
          'precision mediump float;',
          'void main() {',
          '	gl_FragColor = vec4(0, 0, 0, 1);',
          '}'
        ].join('');
        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragmentSrc);
        gl.compileShader(fragmentShader);

        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
          window.console && console.log(
            `Fragment shader failed to compile. Log: ${gl.getShaderInfoLog(fragmentShader)}`
          );
        }

        // link shaders to create our program
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        gl.useProgram(program);

        return program;
      }


      const op_canvas_webgl = document.createElement('canvas');
      const op_canvas_2d = document.createElement('canvas');
      const op_ctx_2d = op_canvas_2d.getContext("2d");

      initWebGL(op_canvas_webgl);
      let warning_tid;
      op_canvas_webgl.addEventListener("webglcontextlost", (e) => {
        e.preventDefault();
        window.console && console.warn("WebGL context lost");
        clamp_brush_sizes();

        warning_tid = setTimeout(() => {
          show_error_message("The WebGL context was lost. You may need to refresh the web page, or restart your computer.");
        }, 3000);
      }, false);
      op_canvas_webgl.addEventListener("webglcontextrestored", () => {
        initWebGL(op_canvas_webgl);

        window.console && console.warn("WebGL context restored");
        clearTimeout(warning_tid);

        clamp_brush_sizes();

        // brushes rendered using WebGL may be invalid (i.e. invisible) since the context was lost
        // invalidate the cache(s) so that brushes will be re-rendered now that WebGL is restored
        $G.triggerHandler("invalidate-brush-canvases");

        $G.triggerHandler("redraw-tool-options-because-webglcontextrestored");
      }, false);

      function clamp_brush_sizes() {
        const max_size = 100;
        if (brush_size > max_size) {
          brush_size = max_size;
          show_error_message(`Brush size clamped to ${max_size}`);
        }
        if (pencil_size > max_size) {
          pencil_size = max_size;
          show_error_message(`Pencil size clamped to ${max_size}`);
        }
        if (stroke_size > max_size) {
          stroke_size = max_size;
          show_error_message(`Stroke size clamped to ${max_size}`);
        }
      }

      window.draw_line_strip = (ctx, points) => {
        draw_polygon_or_line_strip(ctx, points, true, false, false);
      };
      window.draw_polygon = (ctx, points, stroke, fill) => {
        draw_polygon_or_line_strip(ctx, points, stroke, fill, true);
      };

      function draw_polygon_or_line_strip(ctx, points, stroke, fill, close_path) {

        // this must be before stuff is done with op_canvas
        // otherwise update_brush_for_drawing_lines calls render_brush calls draw_ellipse calls draw_polygon calls draw_polygon_or_line_strip
        // trying to use the same op_canvas
        // (also, avoiding infinite recursion by checking for stroke; assuming brushes will never have outlines)
        if (stroke && stroke_size > 1) {
          update_brush_for_drawing_lines(stroke_size);
        }

        const stroke_color = ctx.strokeStyle;
        const fill_color = ctx.fillStyle;

        const numPoints = points.length;
        const numCoords = numPoints * 2;

        if (numPoints === 0) {
          return;
        }

        let x_min = +Infinity;
        let x_max = -Infinity;
        let y_min = +Infinity;
        let y_max = -Infinity;
        for (const {
            x,
            y
          } of points) {
          x_min = Math.min(x, x_min);
          x_max = Math.max(x, x_max);
          y_min = Math.min(y, y_min);
          y_max = Math.max(y, y_max);
        }
        x_max += 1;
        y_max += 1;
        x_min -= 1;
        y_min -= 1;

        op_canvas_webgl.width = x_max - x_min;
        op_canvas_webgl.height = y_max - y_min;
        gl.viewport(0, 0, op_canvas_webgl.width, op_canvas_webgl.height);

        const coords = new Float32Array(numCoords);
        for (let i = 0; i < numPoints; i++) {
          coords[i * 2 + 0] = (points[i].x - x_min) / op_canvas_webgl.width * 2 - 1;
          coords[i * 2 + 1] = 1 - (points[i].y - y_min) / op_canvas_webgl.height * 2;
          // @TODO: investigate: does this cause resolution/information loss? can we change the coordinate system?
        }

        if (fill) {
          const contours = [coords];
          const polyTriangles = triangulate(contours);
          let numVertices = initArrayBuffer(polyTriangles);
          gl.clear(gl.COLOR_BUFFER_BIT);
          gl.drawArrays(gl.TRIANGLES, 0, numVertices);

          op_canvas_2d.width = op_canvas_webgl.width;
          op_canvas_2d.height = op_canvas_webgl.height;

          op_ctx_2d.drawImage(op_canvas_webgl, 0, 0);
          replace_colors_with_swatch(op_ctx_2d, fill_color, x_min, y_min);
          ctx.drawImage(op_canvas_2d, x_min, y_min);
        }
        if (stroke) {
          if (stroke_size > 1) {
            const stroke_margin = ~~(stroke_size * 1.1);

            const op_canvas_x = x_min - stroke_margin;
            const op_canvas_y = y_min - stroke_margin;

            op_canvas_2d.width = x_max - x_min + stroke_margin * 2;
            op_canvas_2d.height = y_max - y_min + stroke_margin * 2;
            for (let i = 0; i < numPoints - (close_path ? 0 : 1); i++) {
              const point_a = points[i];
              const point_b = points[(i + 1) % numPoints];
              // Note: update_brush_for_drawing_lines way above
              draw_line_without_pattern_support(
                op_ctx_2d,
                point_a.x - op_canvas_x,
                point_a.y - op_canvas_y,
                point_b.x - op_canvas_x,
                point_b.y - op_canvas_y,
                stroke_size
              );
            }

            replace_colors_with_swatch(op_ctx_2d, stroke_color, op_canvas_x, op_canvas_y);
            ctx.drawImage(op_canvas_2d, op_canvas_x, op_canvas_y);
          } else {
            let numVertices = initArrayBuffer(coords);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(close_path ? gl.LINE_LOOP : gl.LINE_STRIP, 0, numVertices);

            op_canvas_2d.width = op_canvas_webgl.width;
            op_canvas_2d.height = op_canvas_webgl.height;

            op_ctx_2d.drawImage(op_canvas_webgl, 0, 0);
            replace_colors_with_swatch(op_ctx_2d, stroke_color, x_min, y_min);
            ctx.drawImage(op_canvas_2d, x_min, y_min);
          }
        }
      }

      window.copy_contents_within_polygon = (canvas, points, x_min, y_min, x_max, y_max) => {
        // Copy the contents of the given canvas within the polygon given by points bounded by x/y_min/max
        x_max = Math.max(x_max, x_min + 1);
        y_max = Math.max(y_max, y_min + 1);
        const width = x_max - x_min;
        const height = y_max - y_min;

        // @TODO: maybe have the cutout only the width/height of the bounds
        // const cutout = make_canvas(width, height);
        const cutout = make_canvas(canvas);

        cutout.ctx.save();
        cutout.ctx.globalCompositeOperation = "destination-in";
        draw_polygon(cutout.ctx, points, false, true);
        cutout.ctx.restore();

        const cutout_crop = make_canvas(width, height);
        cutout_crop.ctx.drawImage(cutout, x_min, y_min, width, height, 0, 0, width, height);

        return cutout_crop;
      }

      // @TODO: maybe shouldn't be external...
      window.draw_with_swatch = (ctx, x_min, y_min, x_max, y_max, swatch, callback) => {
        const stroke_margin = ~~(stroke_size * 1.1);

        x_max = Math.max(x_max, x_min + 1);
        y_max = Math.max(y_max, y_min + 1);
        op_canvas_2d.width = x_max - x_min + stroke_margin * 2;
        op_canvas_2d.height = y_max - y_min + stroke_margin * 2;

        const x = x_min - stroke_margin;
        const y = y_min - stroke_margin;

        op_ctx_2d.save();
        op_ctx_2d.translate(-x, -y);
        callback(op_ctx_2d);
        op_ctx_2d.restore(); // for replace_colors_with_swatch!

        replace_colors_with_swatch(op_ctx_2d, swatch, x, y);
        ctx.drawImage(op_canvas_2d, x, y);

        // for debug:
        // ctx.fillStyle = "rgba(255, 0, 255, 0.1)";
        // ctx.fillRect(x, y, op_canvas_2d.width, op_canvas_2d.height);
      }
    })();
  </script>
  <script>
    const ChooserCanvas = (
      url,
      invert,
      width,
      height,
      sourceX,
      sourceY,
      sourceWidth,
      sourceHeight,
      destX,
      destY,
      destWidth,
      destHeight,
      reuse_canvas,
    ) => {
      const c = reuse_canvas(width, height);
      let img = ChooserCanvas.cache[url];
      if (!img) {
        img = ChooserCanvas.cache[url] = E("img");
        img.onerror = () => {
          delete ChooserCanvas.cache[url];
        };
        img.src = url;
      }
      const render = () => {
        try {
          c.ctx.drawImage(
            img,
            sourceX, sourceY, sourceWidth, sourceHeight,
            destX, destY, destWidth, destHeight
          );
          // eslint-disable-next-line no-empty
        } catch (error) {}
        if (invert) {
          invert_rgb(c.ctx);
        }
      };
      $(img).on("load", render);
      render();
      return c;
    };
    ChooserCanvas.cache = {};

    const $Choose = (things, display, choose, is_chosen, gray_background_for_unselected) => {
      const $chooser = $(E("div")).addClass("chooser").attr("touch-action", "none");
      const choose_thing = (thing) => {
        if (is_chosen(thing)) {
          return;
        }
        choose(thing);
        $G.trigger("option-changed");
      };
      $chooser.on("update", () => {
        if (!$chooser.is(":visible")) {
          return;
        }
        $chooser.empty();
        for (let i = 0; i < things.length; i++) {
          (thing => {
            const $option_container = $(E("div")).addClass("chooser-option").appendTo($chooser);
            $option_container.data("thing", thing);
            const reuse_canvas = (width, height) => {
              let option_canvas = $option_container.find("canvas")[0];
              if (option_canvas) {
                if (option_canvas.width !== width) {
                  option_canvas.width = width;
                }
                if (option_canvas.height !== height) {
                  option_canvas.height = height;
                }
              } else {
                option_canvas = make_canvas(width, height);
                $option_container.append(option_canvas);
              }
              return option_canvas;
            };
            const update = () => {
              const selected_color = getComputedStyle($chooser[0]).getPropertyValue("--Hilight");
              const unselected_color = gray_background_for_unselected ? "rgb(192, 192, 192)" : "";
              $option_container.css({
                backgroundColor: is_chosen(thing) ? selected_color : unselected_color,
              });
              display(thing, is_chosen(thing), reuse_canvas);
            };
            update();
            $G.on("option-changed theme-load redraw-tool-options-because-webglcontextrestored", update);
          })(things[i]);
        }

        const onpointerover_while_pointer_down = (event) => {
          const option_container = event.target.closest(".chooser-option");
          if (option_container) {
            choose_thing($(option_container).data("thing"));
          }
        };
        const ontouchmove_while_pointer_down = (event) => {
          const touch = event.originalEvent.changedTouches[0];
          const target = document.elementFromPoint(touch.clientX, touch.clientY);
          const option_container = target.closest(".chooser-option");
          if (option_container) {
            choose_thing($(option_container).data("thing"));
          }
          event.preventDefault();
        };
        $chooser.on("pointerdown click", (event) => {
          const option_container = event.target.closest(".chooser-option");
          if (option_container) {
            choose_thing($(option_container).data("thing"));
          }
          if (event.type === "pointerdown") {
            // glide thru tool options
            $chooser.on("pointerover", onpointerover_while_pointer_down);
            $chooser.on("touchmove", ontouchmove_while_pointer_down);
          }
        });
        $G.on("pointerup pointercancel", () => {
          $chooser.off("pointerover", onpointerover_while_pointer_down);
          $chooser.off("touchmove", ontouchmove_while_pointer_down);
        });
      });
      return $chooser;
    };
    const $ChooseShapeStyle = () => {
      const $chooser = $Choose(
        [{
            stroke: true,
            fill: false
          },
          {
            stroke: true,
            fill: true
          },
          {
            stroke: false,
            fill: true
          }
        ],
        ({
          stroke,
          fill
        }, is_chosen, reuse_canvas) => {
          const sscanvas = reuse_canvas(39, 21);
          const ssctx = sscanvas.ctx;

          // border px inwards amount
          let b = 5;

          const style = getComputedStyle(sscanvas);
          ssctx.fillStyle = is_chosen ? style.getPropertyValue("--HilightText") : style.getPropertyValue("--WindowText");

          if (stroke) {
            // just using a solid rectangle for the stroke
            // so as not to have to deal with the pixel grid with strokes
            ssctx.fillRect(b, b, sscanvas.width - b * 2, sscanvas.height - b * 2);
          }

          // go inward a pixel for the fill
          b += 1;
          ssctx.fillStyle = style.getPropertyValue("--ButtonShadow");

          if (fill) {
            ssctx.fillRect(b, b, sscanvas.width - b * 2, sscanvas.height - b * 2);
          } else {
            ssctx.clearRect(b, b, sscanvas.width - b * 2, sscanvas.height - b * 2);
          }

          return sscanvas;
        },
        ({
          stroke,
          fill
        }) => {
          $chooser.stroke = stroke;
          $chooser.fill = fill;
        },
        ({
          stroke,
          fill
        }) => $chooser.stroke === stroke && $chooser.fill === fill
      ).addClass("choose-shape-style");

      $chooser.fill = false;
      $chooser.stroke = true;

      return $chooser;
    };

    const $choose_brush = $Choose(
      (() => {
        const brush_shapes = ["circle", "square", "reverse_diagonal", "diagonal"];
        const circular_brush_sizes = [7, 4, 1];
        const brush_sizes = [8, 5, 2];
        const things = [];
        brush_shapes.forEach((brush_shape) => {
          const sizes = brush_shape === "circle" ? circular_brush_sizes : brush_sizes;
          sizes.forEach((brush_size) => {
            things.push({
              shape: brush_shape,
              size: brush_size,
            });
          });
        });
        return things;
      })(),
      (o, is_chosen, reuse_canvas) => {
        const cbcanvas = reuse_canvas(10, 10);
        const style = getComputedStyle(cbcanvas);

        const shape = o.shape;
        const size = o.size;
        const color = is_chosen ? style.getPropertyValue("--HilightText") : style.getPropertyValue("--WindowText");

        stamp_brush_canvas(cbcanvas.ctx, 5, 5, shape, size);
        replace_colors_with_swatch(cbcanvas.ctx, color);

        return cbcanvas;
      }, ({
        shape,
        size
      }) => {
        brush_shape = shape;
        brush_size = size;
      }, ({
        shape,
        size
      }) => brush_shape === shape && brush_size === size
    ).addClass("choose-brush");

    const $choose_eraser_size = $Choose(
      [4, 6, 8, 10],
      (size, is_chosen, reuse_canvas) => {
        const cecanvas = reuse_canvas(39, 16);

        const style = getComputedStyle(cecanvas);
        cecanvas.ctx.fillStyle = is_chosen ? style.getPropertyValue("--HilightText") : style.getPropertyValue("--WindowText");
        render_brush(cecanvas.ctx, "square", size);

        return cecanvas;
      },
      size => {
        eraser_size = size;
      },
      size => eraser_size === size
    ).addClass("choose-eraser");

    const $choose_stroke_size = $Choose(
      [1, 2, 3, 4, 5],
      (size, is_chosen, reuse_canvas) => {
        const w = 39,
          h = 12,
          b = 5;
        const cscanvas = reuse_canvas(w, h);
        const center_y = (h - size) / 2;
        const style = getComputedStyle(cscanvas);
        cscanvas.ctx.fillStyle = is_chosen ? style.getPropertyValue("--HilightText") : style.getPropertyValue("--WindowText");
        cscanvas.ctx.fillRect(b, ~~center_y, w - b * 2, size);
        return cscanvas;
      },
      size => {
        stroke_size = size;
      },
      size => stroke_size === size
    ).addClass("choose-stroke-size");

    const magnifications = [1, 2, 6, 8, 10];
    const $choose_magnification = $Choose(
        magnifications,
        (scale, is_chosen, reuse_canvas) => {
          const i = magnifications.indexOf(scale);
          const secret = scale === 10; // 10x is secret
          const chooser_canvas = ChooserCanvas(
            OPTIONS_MAGNIFICATION_BASE64,
            is_chosen, // invert if chosen
            39, (secret ? 2 : 13), // width, height of destination canvas
            i * 23, 0, 23, 9, // x, y, width, height from source image
            8, 2, 23, 9, // x, y, width, height on destination
            reuse_canvas,
          );
          if (secret) {
            $(chooser_canvas).addClass("secret-option");
          }
          return chooser_canvas;
        },
        scale => {
          set_magnification(scale);
        },
        scale => scale === magnification,
        true,
      ).addClass("choose-magnification")
      .css({
        position: "relative"
      }); // positioning context for above `position: "absolute"` canvas

    $choose_magnification.on("update", () => {
      $choose_magnification
        .find(".secret-option")
        .parent()
        .css({
          position: "absolute",
          bottom: "-2px",
          left: 0,
          opacity: 0
        });
    });

    const airbrush_sizes = [9, 16, 24];
    const $choose_airbrush_size = $Choose(
      airbrush_sizes,
      (size, is_chosen, reuse_canvas) => {

        const image_width = 72; // width of source image
        const i = airbrush_sizes.indexOf(size); // 0 or 1 or 2
        const l = airbrush_sizes.length; // 3
        const is_bottom = (i === 2);

        const shrink = 4 * !is_bottom;
        const w = image_width / l - shrink * 2;
        const h = 23;
        const source_x = image_width / l * i + shrink;

        return ChooserCanvas(
          OPTIONS_AIRBRUSH_SIZE_BASE64,
          is_chosen, // invert if chosen
          w, h, // width, height of created destination canvas
          source_x, 0, w, h, // x, y, width, height from source image
          0, 0, w, h, // x, y, width, height on created destination canvas
          reuse_canvas,
        );
      },
      size => {
        airbrush_size = size;
      },
      size => size === airbrush_size,
      true,
    ).addClass("choose-airbrush-size");

    const $choose_transparent_mode = $Choose(
      [false, true],
      (option, _is_chosen, reuse_canvas) => {
        const sw = 35,
          sh = 23; // width, height from source image
        const b = 2; // margin by which the source image is inset on the destination
        const theme_folder = `images/${get_theme().replace(/\.css/, "")}`;
        return ChooserCanvas(
          `${OPTIONS_TRANSPARENCY_BASE64}`,
          false, // never invert it
          b + sw + b, b + sh + b, // width, height of created destination canvas
          0, option ? 22 : 0, sw, sh, // x, y, width, height from source image
          b, b, sw, sh, // x, y, width, height on created destination canvas
          reuse_canvas,
        );
      },
      option => {
        tool_transparent_mode = option;
      },
      option => option === tool_transparent_mode,
      true,
    ).addClass("choose-transparent-mode");
  </script>
  <script>
    (() => {

      // This is for linting stuff at the bottom.
      /* eslint no-restricted-syntax: ["error", "ThisExpression"] */
      /* eslint-disable no-restricted-syntax */

      window.tools = [{
        name: "Free-Form Select",
        speech_recognition: [],
        help_icon: "p_free.gif",
        description: "Selects a free-form part of the picture to move, copy, or edit.",
        cursor: [PRECISE, [16, 16], "crosshair"],

        // A canvas for rendering a preview of the shape
        preview_canvas: null,

        // The vertices of the polygon
        points: [],

        // The boundaries of the polygon
        x_min: +Infinity,
        x_max: -Infinity,
        y_min: +Infinity,
        y_max: -Infinity,

        pointerdown() {
          this.x_min = pointer.x;
          this.x_max = pointer.x + 1;
          this.y_min = pointer.y;
          this.y_max = pointer.y + 1;
          this.points = [];
          this.preview_canvas = make_canvas(canvas.width, canvas.height);

          // End prior selection, drawing it to the canvas
          deselect();
        },
        paint(ctx, x, y) {
          // Constrain the pointer to the canvas
          pointer.x = Math.min(canvas.width, pointer.x);
          pointer.x = Math.max(0, pointer.x);
          pointer.y = Math.min(canvas.height, pointer.y);
          pointer.y = Math.max(0, pointer.y);
          // Add the point
          this.points.push(pointer);
          // Update the boundaries of the polygon
          this.x_min = Math.min(pointer.x, this.x_min);
          this.x_max = Math.max(pointer.x, this.x_max);
          this.y_min = Math.min(pointer.y, this.y_min);
          this.y_max = Math.max(pointer.y, this.y_max);

          bresenham_line(pointer_previous.x, pointer_previous.y, pointer.x, pointer.y, (x, y) => {
            this.paint_iteration(x, y);
          });
        },
        paint_iteration(x, y) {
          // Constrain the inverty paint brush position to the canvas
          x = Math.min(canvas.width, x);
          x = Math.max(0, x);
          y = Math.min(canvas.height, y);
          y = Math.max(0, y);

          // Find the dimensions on the canvas of the tiny square to invert
          const inverty_size = 2;
          const rect_x = ~~(x - inverty_size / 2);
          const rect_y = ~~(y - inverty_size / 2);
          const rect_w = inverty_size;
          const rect_h = inverty_size;

          const ctx_dest = this.preview_canvas.ctx;
          const id_src = ctx.getImageData(rect_x, rect_y, rect_w, rect_h);
          const id_dest = ctx_dest.getImageData(rect_x, rect_y, rect_w, rect_h);

          for (let i = 0, l = id_dest.data.length; i < l; i += 4) {
            id_dest.data[i + 0] = 255 - id_src.data[i + 0];
            id_dest.data[i + 1] = 255 - id_src.data[i + 1];
            id_dest.data[i + 2] = 255 - id_src.data[i + 2];
            id_dest.data[i + 3] = 255;
            // @TODO maybe: invert based on id_src.data[i+3] and the checkered background
          }

          ctx_dest.putImageData(id_dest, rect_x, rect_y);
        },
        pointerup() {
          this.preview_canvas.width = 1;
          this.preview_canvas.height = 1;

          const contents_within_polygon = copy_contents_within_polygon(
            canvas,
            this.points,
            this.x_min,
            this.y_min,
            this.x_max,
            this.y_max
          );

          if (selection) {
            // for silly multitools feature
            show_error_message("This isn't supposed to happen: Free-Form Select after Select in the tool chain?");
            meld_selection_into_canvas();
          }

          undoable({
            name: "Free-Form Select",
            icon: get_icon_for_tool(get_tool_by_name("Free-Form Select")),
            soft: true,
          }, () => {
            selection = new OnCanvasSelection(
              this.x_min,
              this.y_min,
              this.x_max - this.x_min,
              this.y_max - this.y_min,
              contents_within_polygon,
            );
            selection.cut_out_background();
          });
        },
        cancel() {
          if (!this.preview_canvas) {
            return;
          }
          this.preview_canvas.width = 1;
          this.preview_canvas.height = 1;
        },
        drawPreviewUnderGrid(ctx, x, y, grid_visible, scale, translate_x, translate_y) {
          if (!pointer_active && !pointer_over_canvas) {
            return;
          }
          if (!this.preview_canvas) {
            return;
          }

          ctx.scale(scale, scale);
          ctx.translate(translate_x, translate_y);

          ctx.drawImage(this.preview_canvas, 0, 0);
        },
        $options: $choose_transparent_mode
      }, {
        name: "Select",
        speech_recognition: [],
        help_icon: "p_sel.gif",
        description: "Selects a rectangular part of the picture to move, copy, or edit.",
        cursor: [PRECISE, [16, 16], "crosshair"],
        selectBox(rect_x, rect_y, rect_width, rect_height) {
          if (rect_width > 1 && rect_height > 1) {
            var free_form_selection = selection;
            if (selection) {
              // for silly multitools feature
              meld_selection_into_canvas();
            }
            if (ctrl) {
              undoable({
                name: "Crop"
              }, () => {
                var cropped_canvas = make_canvas(rect_width, rect_height);
                cropped_canvas.ctx.drawImage(canvas, -rect_x, -rect_y);
                ctx.copy(cropped_canvas);
                $canvas_handles.show();
                $canvas_area.trigger("resize");
              });
            } else if (free_form_selection) {
              // for silly multitools feature,
              // create a selection that's the Free-Form selection XOR the normal selection

              var x_min = Math.min(free_form_selection.x, rect_x);
              var y_min = Math.min(free_form_selection.y, rect_y);
              var x_max = Math.max(free_form_selection.x + free_form_selection.width, rect_x + rect_width);
              var y_max = Math.max(free_form_selection.y + free_form_selection.height, rect_y + rect_height);

              var contents_canvas = make_canvas(
                x_max - x_min,
                y_max - y_min,
              );
              var rect_canvas = make_canvas(
                x_max - x_min,
                y_max - y_min,
              );
              rect_canvas.ctx.drawImage(
                canvas,
                // source:
                rect_x,
                rect_y,
                rect_width,
                rect_height,
                // dest:
                rect_x - x_min,
                rect_y - y_min,
                rect_width,
                rect_height,
              );

              contents_canvas.ctx.drawImage(
                free_form_selection.canvas,
                free_form_selection.x - x_min,
                free_form_selection.y - y_min,
              );
              contents_canvas.ctx.globalCompositeOperation = "xor";
              contents_canvas.ctx.drawImage(rect_canvas, 0, 0);

              undoable({
                name: "Free-Form Select⊕Select",
                icon: get_icon_for_tools([
                  get_tool_by_name("Free-Form Select"),
                  get_tool_by_name("Select"),
                ]),
                soft: true,
              }, () => {
                selection = new OnCanvasSelection(
                  x_min,
                  y_min,
                  x_max - x_min,
                  y_max - y_min,
                  contents_canvas,
                );
                selection.cut_out_background();
              });
            } else {
              undoable({
                name: "Select",
                icon: get_icon_for_tool(get_tool_by_name("Select")),
                soft: true,
              }, () => {
                selection = new OnCanvasSelection(rect_x, rect_y, rect_width, rect_height);
              });
            }
          }
        },
        $options: $choose_transparent_mode
      }, {
        name: "Eraser/Color Eraser",
        speech_recognition: [],
        help_icon: "p_erase.gif",
        description: "Erases a portion of the picture, using the selected eraser shape.",
        cursor: [PRECISE, [16, 16], "crosshair"],

        // binary mask of the drawn area, either opaque white or transparent
        mask_canvas: null,

        get_rect(x, y) {
          const rect_x = Math.ceil(x - eraser_size / 2);
          const rect_y = Math.ceil(y - eraser_size / 2);
          const rect_w = eraser_size;
          const rect_h = eraser_size;
          return {
            rect_x,
            rect_y,
            rect_w,
            rect_h
          };
        },

        drawPreviewUnderGrid(ctx, x, y, grid_visible, scale, translate_x, translate_y) {
          if (!pointer_active && !pointer_over_canvas) {
            return;
          }
          const {
            rect_x,
            rect_y,
            rect_w,
            rect_h
          } = this.get_rect(x, y);

          ctx.scale(scale, scale);
          ctx.translate(translate_x, translate_y);

          if (this.mask_canvas) {
            this.render_from_mask(ctx, true);
            if (transparency) {
              // animate for gradient
              requestAnimationFrame(update_helper_layer);
            }
          }

          ctx.fillStyle = colors.background;
          ctx.fillRect(rect_x, rect_y, rect_w, rect_h);
        },
        drawPreviewAboveGrid(ctx, x, y, grid_visible, scale, translate_x, translate_y) {
          if (!pointer_active && !pointer_over_canvas) {
            return;
          }

          const {
            rect_x,
            rect_y,
            rect_w,
            rect_h
          } = this.get_rect(x, y);

          ctx.scale(scale, scale);
          ctx.translate(translate_x, translate_y);
          const hairline_width = 1 / scale;

          ctx.strokeStyle = "black";
          ctx.lineWidth = hairline_width;
          if (grid_visible) {
            ctx.strokeRect(rect_x + ctx.lineWidth / 2, rect_y + ctx.lineWidth / 2, rect_w, rect_h);
          } else {
            ctx.strokeRect(rect_x + ctx.lineWidth / 2, rect_y + ctx.lineWidth / 2, rect_w - ctx.lineWidth, rect_h - ctx.lineWidth);
          }
        },
        pointerdown() {
          this.mask_canvas = make_canvas(canvas.width, canvas.height);
        },
        render_from_mask(ctx, previewing) {
          ctx.save();
          ctx.globalCompositeOperation = "destination-out";
          ctx.drawImage(this.mask_canvas, 0, 0);
          ctx.restore();

          if (previewing || !transparency) {
            let color = colors.background;
            if (transparency) {
              const t = performance.now() / 2000;
              // 5 distinct colors, 5 distinct gradients, 7 color stops, 6 gradients
              const n = 6;
              const h = ctx.canvas.height;
              const y = (t % 1) * -h * (n - 1);
              const gradient = ctx.createLinearGradient(0, y, 0, y + h * n);
              gradient.addColorStop(0 / n, "red");
              gradient.addColorStop(1 / n, "gold");
              gradient.addColorStop(2 / n, "#00d90b");
              gradient.addColorStop(3 / n, "#2e64d9");
              gradient.addColorStop(4 / n, "#8f2ed9");
              // last two same as the first two so it can seamlessly wrap
              gradient.addColorStop(5 / n, "red");
              gradient.addColorStop(6 / n, "gold");
              color = gradient;
            }
            const mask_fill_canvas = make_canvas(this.mask_canvas);
            replace_colors_with_swatch(mask_fill_canvas.ctx, color, 0, 0);
            ctx.drawImage(mask_fill_canvas, 0, 0);
          }
        },
        pointerup() {
          undoable({
            name: this.color_eraser_mode ? "Color Eraser" : "Eraser",
            icon: get_icon_for_tool(this),
          }, () => {
            this.render_from_mask(ctx);

            this.mask_canvas = null;
          });
        },
        cancel() {
          this.mask_canvas = null;
        },
        paint(ctx, x, y) {
          bresenham_line(pointer_previous.x, pointer_previous.y, pointer.x, pointer.y, (x, y) => {
            this.paint_iteration(ctx, x, y);
          });
        },
        paint_iteration(ctx, x, y) {
          const {
            rect_x,
            rect_y,
            rect_w,
            rect_h
          } = this.get_rect(x, y);

          this.color_eraser_mode = button !== 0;

          if (!this.color_eraser_mode) {
            // Eraser
            this.mask_canvas.ctx.fillStyle = "white";
            this.mask_canvas.ctx.fillRect(rect_x, rect_y, rect_w, rect_h);
          } else {
            // Color Eraser
            // Right click with the eraser to selectively replace
            // the selected foreground color with the selected background color

            const fg_rgba = get_rgba_from_color(colors.foreground);

            const test_image_data = ctx.getImageData(rect_x, rect_y, rect_w, rect_h);
            const result_image_data = this.mask_canvas.ctx.getImageData(rect_x, rect_y, rect_w, rect_h);

            for (let i = 0, l = test_image_data.data.length; i < l; i += 4) {
              if (
                test_image_data.data[i + 0] === fg_rgba[0] &&
                test_image_data.data[i + 1] === fg_rgba[1] &&
                test_image_data.data[i + 2] === fg_rgba[2] &&
                test_image_data.data[i + 3] === fg_rgba[3]
              ) {
                result_image_data.data[i + 0] = 255;
                result_image_data.data[i + 1] = 255;
                result_image_data.data[i + 2] = 255;
                result_image_data.data[i + 3] = 255;
              }
            }

            this.mask_canvas.ctx.putImageData(result_image_data, rect_x, rect_y);
          }
        },
        $options: $choose_eraser_size
      }, {
        name: "Fill With Color",
        speech_recognition: [],
        help_icon: "p_paint.gif",
        description: "Fills an area with the selected drawing color.",
        cursor: [FILL_BUCKET, [8, 22], "crosshair"],
        pointerdown(ctx, x, y) {
          if (shift) {
            undoable({
              name: "Replace Color",
              icon: get_icon_for_tool(this),
            }, () => {
              // Perform global color replacement
              draw_noncontiguous_fill(ctx, x, y, fill_color);
            });
          } else {
            undoable({
              name: "Fill With Color",
              icon: get_icon_for_tool(this),
            }, () => {
              // Perform a normal fill operation
              draw_fill(ctx, x, y, fill_color);
            });
          }
        }
      }, {
        name: "Pick Color",
        speech_recognition: [],
        help_icon: "p_eye.gif",
        description: "Picks up a color from the picture for drawing.",
        cursor: [EYE_DROPPER, [9, 22], "crosshair"],
        deselect: true,

        current_color: "",
        display_current_color() {
          this.$options.css({
            background: this.current_color
          });
        },
        pointerdown() {
          $G.one("pointerup", () => {
            this.$options.css({
              background: ""
            });
          });
        },
        paint(ctx, x, y) {
          if (x >= 0 && y >= 0 && x < canvas.width && y < canvas.height) {
            const id = ctx.getImageData(~~x, ~~y, 1, 1);
            const r = id.data[0];
            const g = id.data[1];
            const b = id.data[2];
            const a = id.data[3];
            this.current_color = `rgba(${r},${g},${b},${a/255})`;
          } else {
            this.current_color = "white";
          }
          this.display_current_color();
        },
        pointerup() {
          colors[fill_color_k] = this.current_color;
          $G.trigger("option-changed");
        },
        $options: $(E("div"))
      }, {
        name: "Magnifier",
        speech_recognition: [],
        help_icon: "p_zoom.gif",
        description: "Changes the magnification.",
        cursor: [MAGNIFIER, [16, 16], "zoom-in"], // overridden below
        deselect: true,

        getProspectiveMagnification: () => (
          magnification === 1 ? return_to_magnification : 1
        ),

        drawPreviewAboveGrid(ctx, x, y, grid_visible, scale, translate_x, translate_y) {
          if (!pointer_active && !pointer_over_canvas) {
            return;
          }
          if (pointer_active) {
            return;
          }
          const prospective_magnification = this.getProspectiveMagnification();

          // hacky place to put this but whatever
          // use specific zoom-in/zoom-out as fallback,
          // even though the custom cursor image is less descriptive
          // because there's no generic "zoom" css cursor
          if (prospective_magnification < magnification) {
            $canvas.css({
              cursor: make_css_cursor(MAGNIFIER, [16, 16], "zoom-out"),
            });
          } else {
            $canvas.css({
              cursor: make_css_cursor(MAGNIFIER, [16, 16], "zoom-in"),
            });
          }

          if (prospective_magnification < magnification) {
            return;
          } // hide if would be zooming out

          // prospective viewport size in document coords
          const w = $canvas_area.width() / prospective_magnification;
          const h = $canvas_area.height() / prospective_magnification;

          let rect_x1 = ~~(x - w / 2);
          let rect_y1 = ~~(y - h / 2);

          // try to move rect into bounds without squishing
          rect_x1 = Math.max(0, rect_x1);
          rect_y1 = Math.max(0, rect_y1);
          rect_x1 = Math.min(canvas.width - w, rect_x1);
          rect_y1 = Math.min(canvas.height - h, rect_y1);

          let rect_x2 = rect_x1 + w;
          let rect_y2 = rect_y1 + h;

          // clamp rect to bounds (with squishing)
          rect_x1 = Math.max(0, rect_x1);
          rect_y1 = Math.max(0, rect_y1);
          rect_x2 = Math.min(canvas.width, rect_x2);
          rect_y2 = Math.min(canvas.height, rect_y2);

          const rect_w = rect_x2 - rect_x1;
          const rect_h = rect_y2 - rect_y1;
          const rect_x = rect_x1;
          const rect_y = rect_y1;

          const id_src = canvas.ctx.getImageData(rect_x, rect_y, rect_w + 1, rect_h + 1);
          const id_dest = ctx.getImageData((rect_x + translate_x) * scale, (rect_y + translate_y) * scale, rect_w * scale + 1, rect_h * scale + 1);

          function copyPixelInverted(x_dest, y_dest) {
            const x_src = ~~(x_dest / scale);
            const y_src = ~~(y_dest / scale);
            const index_src = (x_src + y_src * id_src.width) * 4;
            const index_dest = (x_dest + y_dest * id_dest.width) * 4;
            id_dest.data[index_dest + 0] = 255 - id_src.data[index_src + 0];
            id_dest.data[index_dest + 1] = 255 - id_src.data[index_src + 1];
            id_dest.data[index_dest + 2] = 255 - id_src.data[index_src + 2];
            id_dest.data[index_dest + 3] = 255;
            // @TODO maybe: invert based on id_src.data[index_src+3] and the checkered background
          }

          for (let x = 0, limit = id_dest.width; x < limit; x += 1) {
            copyPixelInverted(x, 0);
            copyPixelInverted(x, id_dest.height - 1);
          }
          for (let y = 1, limit = id_dest.height - 1; y < limit; y += 1) {
            copyPixelInverted(0, y);
            copyPixelInverted(id_dest.width - 1, y);
          }

          // for debug: fill rect
          // for(let x=0, x_limit=id_dest.width; x<x_limit; x+=1){
          // 	for(let y=1, y_limit=id_dest.height-1; y<y_limit; y+=1){
          // 		copyPixelInverted(x, y);
          // 	}
          // }

          ctx.putImageData(id_dest, (rect_x + translate_x) * scale, (rect_y + translate_y) * scale);

          // debug:
          // ctx.scale(scale, scale);
          // ctx.translate(translate_x, translate_y);
          // ctx.strokeStyle = "#f0f";
          // ctx.strokeRect(rect_x1, rect_y1, rect_w, rect_h);
        },
        pointerdown(ctx, x, y) {
          const prev_magnification = magnification;
          const prospective_magnification = this.getProspectiveMagnification();

          set_magnification(prospective_magnification);

          if (magnification > prev_magnification) {

            // (new) viewport size in document coords
            const w = $canvas_area.width() / magnification;
            const h = $canvas_area.height() / magnification;

            const scroll_left = (x - w / 2) * magnification / prev_magnification;
            const scroll_top = (y - h / 2) * magnification / prev_magnification;

            $canvas_area.scrollLeft(scroll_left);
            $canvas_area.scrollTop(scroll_top);
            $canvas_area.trigger("scroll");
          }
        },
        $options: $choose_magnification
      }, {
        name: "Pencil",
        speech_recognition: [],
        help_icon: "p_pencil.gif",
        description: "Draws a free-form line one pixel wide.",
        cursor: [PENCIL, [13, 23], "crosshair"],
        stroke_only: true,
        get_brush() {
          return {
            size: pencil_size,
            shape: "circle"
          };
        }
      }, {
        name: "Brush",
        speech_recognition: [],
        help_icon: "p_brush.gif",
        description: "Draws using a brush with the selected shape and size.",
        cursor: [PRECISE_DOTTED, [16, 16], "crosshair"],
        dynamic_preview_cursor: true,
        get_brush() {
          return {
            size: brush_size,
            shape: brush_shape
          };
        },
        $options: $choose_brush
      }, {
        name: "Airbrush",
        speech_recognition: [],
        help_icon: "p_airb.gif",
        description: "Draws using an airbrush of the selected size.",
        cursor: [AIRBRUSH, [7, 22], "crosshair"],
        paint_on_time_interval: 5,
        paint_mask(ctx, x, y) {
          const r = airbrush_size / 2;
          for (let i = 0; i < 6 + r / 5; i++) {
            const rx = (Math.random() * 2 - 1) * r;
            const ry = (Math.random() * 2 - 1) * r;
            const d = rx * rx + ry * ry;
            if (d <= r * r) {
              ctx.fillRect(x + ~~rx, y + ~~ry, 1, 1);
            }
          }
          update_helper_layer();
        },
        $options: $choose_airbrush_size
      }, {
        name: "Text",
        speech_recognition: [],
        help_icon: "p_txt.gif",
        description: "Inserts text into the picture.",
        cursor: [PRECISE, [16, 16], "crosshair"],
        preload() {
          setTimeout(FontDetective.preload, 10);
        },
        selectBox(rect_x, rect_y, rect_width, rect_height) {
          if (rect_width > 1 && rect_height > 1) {
            textbox = new OnCanvasTextBox(rect_x, rect_y, rect_width, rect_height);
          }
        },
        $options: $choose_transparent_mode
      }, {
        name: "Line",
        speech_recognition: [],
        help_icon: "p_line.gif",
        description: "Draws a straight line with the selected line width.",
        cursor: [PRECISE, [16, 16], "crosshair"],
        stroke_only: true,
        shape(ctx, x, y, w, h) {
          update_brush_for_drawing_lines(stroke_size);
          draw_line(ctx, x, y, x + w, y + h, stroke_size);
        },
        $options: $choose_stroke_size
      }, {
        name: "Curve",
        speech_recognition: [],
        help_icon: "p_curve.gif",
        description: "Draws a curved line with the selected line width.",
        cursor: [PRECISE, [16, 16], "crosshair"],
        stroke_only: true,
        points: [],
        pointerup(ctx, x, y) {
          if (this.points.length >= 4) {
            undoable({
              name: "Curve",
              icon: get_icon_for_tool(this),
            }, () => {
              this.draw_curve(ctx);
            });
            this.points = [];
          }
        },
        pointerdown(ctx, x, y) {
          if (this.points.length < 1) {
            this.points.push({
              x,
              y
            });
            if (!$("body").hasClass("eye-gaze-mode")) {
              // second point so first action draws a line
              this.points.push({
                x,
                y
              });
            }
          } else {
            this.points.push({
              x,
              y
            });
          }
        },
        paint(ctx, x, y) {
          if (this.points.length < 1) {
            return;
          }

          const i = this.points.length - 1;
          this.points[i].x = x;
          this.points[i].y = y;
        },
        draw_curve(ctx, x, y) {
          if (this.points.length < 1) {
            return;
          }

          update_brush_for_drawing_lines(stroke_size);

          if (this.points.length === 4) {
            draw_bezier_curve(
              ctx,
              this.points[0].x, this.points[0].y,
              this.points[2].x, this.points[2].y,
              this.points[3].x, this.points[3].y,
              this.points[1].x, this.points[1].y,
              stroke_size
            );
          } else if (this.points.length === 3) {
            draw_quadratic_curve(
              ctx,
              this.points[0].x, this.points[0].y,
              this.points[2].x, this.points[2].y,
              this.points[1].x, this.points[1].y,
              stroke_size
            );
          } else if (this.points.length === 2) {
            draw_line(
              ctx,
              this.points[0].x, this.points[0].y,
              this.points[1].x, this.points[1].y,
              stroke_size
            );
          } else {
            draw_line(
              ctx,
              this.points[0].x, this.points[0].y,
              this.points[0].x, this.points[0].y,
              stroke_size
            );
          }
        },
        drawPreviewUnderGrid(ctx, x, y, grid_visible, scale, translate_x, translate_y) {
          // if(!pointer_active && !pointer_over_canvas){return;}
          // if(!this.preview_canvas){return;}

          ctx.scale(scale, scale);
          ctx.translate(translate_x, translate_y);

          this.draw_curve(ctx);
        },
        cancel() {
          this.points = [];
        },
        end() {
          this.points = [];
          update_helper_layer();
        },
        $options: $choose_stroke_size
      }, {
        name: "Rectangle",
        speech_recognition: [],
        help_icon: "p_rect.gif",
        description: "Draws a rectangle with the selected fill style.",
        cursor: [PRECISE, [16, 16], "crosshair"],
        shape(ctx, x, y, w, h) {
          if (w < 0) {
            x += w;
            w = -w;
          }
          if (h < 0) {
            y += h;
            h = -h;
          }

          if (this.$options.fill) {
            ctx.fillRect(x, y, w, h);
          }
          if (this.$options.stroke) {
            if (w < stroke_size * 2 || h < stroke_size * 2) {
              ctx.save();
              ctx.fillStyle = ctx.strokeStyle;
              ctx.fillRect(x, y, w, h);
              ctx.restore();
            } else {
              // @TODO: shouldn't that be ~~(stroke_size / 2)?
              ctx.strokeRect(x + stroke_size / 2, y + stroke_size / 2, w - stroke_size, h - stroke_size);
            }
          }
        },
        $options: $ChooseShapeStyle()
      }, {
        name: "Polygon",
        speech_recognition: [],
        help_icon: "p_poly.gif",
        description: "Draws a polygon with the selected fill style.",
        cursor: [PRECISE, [16, 16], "crosshair"],

        // Record the last click for double-clicking
        // A double click happens on pointerdown of a second click
        // (within a cylindrical volume in 2d space + 1d time)
        last_click_pointerdown: {
          x: -Infinity,
          y: -Infinity,
          time: -Infinity
        },
        last_click_pointerup: {
          x: -Infinity,
          y: -Infinity,
          time: -Infinity
        },

        // The vertices of the polygon
        points: [],

        // A canvas for rendering a preview of the shape
        preview_canvas: null,

        pointerup(ctx, x, y) {
          if (this.points.length < 1) {
            return;
          }

          const i = this.points.length - 1;
          this.points[i].x = x;
          this.points[i].y = y;
          const dx = this.points[i].x - this.points[0].x;
          const dy = this.points[i].y - this.points[0].y;
          const d = Math.sqrt(dx * dx + dy * dy);
          if ($("body").hasClass("eye-gaze-mode")) {
            if (this.points.length >= 3) {
              if (d < stroke_size * 10 + 20) {
                this.complete(ctx);
              }
            }
          } else {
            if (d < stroke_size * 5.1010101) { // arbitrary number (@TODO: find correct value (or formula))
              this.complete(ctx);
            }
          }

          this.last_click_pointerup = {
            x,
            y,
            time: +(new Date)
          };
        },
        pointerdown(ctx, x, y) {
          if (this.points.length < 1) {
            this.preview_canvas = make_canvas(canvas.width, canvas.height);

            // Add the first point of the polygon
            this.points.push({
              x,
              y
            });

            if (!$("body").hasClass("eye-gaze-mode")) {
              // Add a second point so first action draws a line
              this.points.push({
                x,
                y
              });
            }
          } else {
            const lx = this.last_click_pointerdown.x;
            const ly = this.last_click_pointerdown.y;
            const lt = this.last_click_pointerdown.time;
            const dx = x - lx;
            const dy = y - ly;
            const dt = +(new Date) - lt;
            const d = Math.sqrt(dx * dx + dy * dy);
            if (d < 4.1010101 && dt < 250) { // arbitrary 101 (@TODO: find correct value (or formula))
              this.complete(ctx);
            } else {
              // Add the point
              this.points.push({
                x,
                y
              });
            }
          }
          this.last_click_pointerdown = {
            x,
            y,
            time: +new Date
          };
        },
        paint(ctx, x, y) {
          if (this.points.length < 1) {
            return;
          }

          const i = this.points.length - 1;
          this.points[i].x = x;
          this.points[i].y = y;

          this.preview_canvas.ctx.clearRect(0, 0, this.preview_canvas.width, this.preview_canvas.height);
          if (this.$options.fill && !this.$options.stroke) {
            this.preview_canvas.ctx.drawImage(canvas, 0, 0);
            this.preview_canvas.ctx.strokeStyle = "white";
            this.preview_canvas.ctx.globalCompositeOperation = "difference";
            var orig_stroke_size = stroke_size;
            stroke_size = 2;
            draw_line_strip(
              this.preview_canvas.ctx,
              this.points
            );
            stroke_size = orig_stroke_size;
          } else if (this.points.length > 1) {
            this.preview_canvas.ctx.strokeStyle = stroke_color;
            draw_line_strip(
              this.preview_canvas.ctx,
              this.points
            );
          } else {
            draw_line(
              this.preview_canvas.ctx,
              this.points[0].x, this.points[0].y,
              this.points[0].x, this.points[0].y,
              stroke_size
            );
          }
        },
        drawPreviewUnderGrid(ctx, x, y, grid_visible, scale, translate_x, translate_y) {
          // if(!pointer_active && !pointer_over_canvas){return;}
          if (!this.preview_canvas) {
            return;
          }

          ctx.scale(scale, scale);
          ctx.translate(translate_x, translate_y);

          ctx.drawImage(this.preview_canvas, 0, 0);
        },
        complete(ctx) {
          if (this.points.length >= 3) {
            undoable({
              name: "Polygon",
              icon: get_icon_for_tool(this),
            }, () => {
              ctx.fillStyle = fill_color;
              ctx.strokeStyle = stroke_color;

              var orig_stroke_size = stroke_size;
              if (this.$options.fill && !this.$options.stroke) {
                stroke_size = 2;
                ctx.strokeStyle = fill_color;
              }

              draw_polygon(
                ctx,
                this.points,
                this.$options.stroke || (this.$options.fill && !this.$options.stroke),
                this.$options.fill
              );

              stroke_size = orig_stroke_size;
            });
          }

          this.reset();
        },
        cancel() {
          this.reset();
        },
        end(ctx) {
          this.complete(ctx);
          update_helper_layer();
        },
        reset() {
          this.points = [];
          this.last_click_pointerdown = {
            x: -Infinity,
            y: -Infinity,
            time: -Infinity
          };
          this.last_click_pointerup = {
            x: -Infinity,
            y: -Infinity,
            time: -Infinity
          };

          if (!this.preview_canvas) {
            return;
          }
          this.preview_canvas.width = 1;
          this.preview_canvas.height = 1;
        },
        shape_colors: true,
        $options: $ChooseShapeStyle()
      }, {
        name: "Ellipse",
        speech_recognition: [],
        help_icon: "p_oval.gif",
        description: "Draws an ellipse with the selected fill style.",
        cursor: [PRECISE, [16, 16], "crosshair"],
        shape(ctx, x, y, w, h) {
          if (w < 0) {
            x += w;
            w = -w;
          }
          if (h < 0) {
            y += h;
            h = -h;
          }

          if (w < stroke_size || h < stroke_size) {
            ctx.fillStyle = ctx.strokeStyle;
            draw_ellipse(ctx, x, y, w, h, false, true);
          } else {
            draw_ellipse(
              ctx,
              x + ~~(stroke_size / 2),
              y + ~~(stroke_size / 2),
              w - stroke_size,
              h - stroke_size,
              this.$options.stroke,
              this.$options.fill
            );
          }
        },
        $options: $ChooseShapeStyle()
      }, {
        name: "Rounded Rectangle",
        speech_recognition: [],
        help_icon: "p_rrect.gif",
        description: "Draws a rounded rectangle with the selected fill style.",
        cursor: [PRECISE, [16, 16], "crosshair"],
        shape(ctx, x, y, w, h) {
          if (w < 0) {
            x += w;
            w = -w;
          }
          if (h < 0) {
            y += h;
            h = -h;
          }

          if (w < stroke_size || h < stroke_size) {
            ctx.fillStyle = ctx.strokeStyle;
            const radius = Math.min(8, w / 2, h / 2);
            // const radius_x = Math.min(8, w/2);
            // const radius_y = Math.min(8, h/2);
            draw_rounded_rectangle(
              ctx,
              x, y, w, h,
              radius, radius,
              // radius_x, radius_y,
              false,
              true
            );
          } else {
            const radius = Math.min(8, (w - stroke_size) / 2, (h - stroke_size) / 2);
            // const radius_x = Math.min(8, (w - stroke_size)/2);
            // const radius_y = Math.min(8, (h - stroke_size)/2);
            draw_rounded_rectangle(
              ctx,
              x + ~~(stroke_size / 2),
              y + ~~(stroke_size / 2),
              w - stroke_size,
              h - stroke_size,
              radius, radius,
              // radius_x, radius_y,
              this.$options.stroke,
              this.$options.fill
            );
          }
        },
        $options: $ChooseShapeStyle()
      }];

      /* eslint-enable no-restricted-syntax */

      tools.forEach((tool) => {
        if (tool.selectBox) {
          let drag_start_x = 0;
          let drag_start_y = 0;
          let pointer_has_moved = false;
          let rect_x = 0;
          let rect_y = 0;
          let rect_width = 0;
          let rect_height = 0;

          tool.pointerdown = () => {
            drag_start_x = pointer.x;
            drag_start_y = pointer.y;
            pointer_has_moved = false;
            $G.one("pointermove", () => {
              pointer_has_moved = true;
            });
            if (selection) {
              meld_selection_into_canvas();
            }
            if (textbox) {
              meld_textbox_into_canvas();
            }
            $canvas_handles.hide();
          };
          tool.paint = () => {
            rect_x = ~~Math.max(0, Math.min(drag_start_x, pointer.x));
            rect_y = ~~Math.max(0, Math.min(drag_start_y, pointer.y));
            rect_width = (~~Math.min(canvas.width, Math.max(drag_start_x, pointer.x) + 1)) - rect_x;
            rect_height = (~~Math.min(canvas.height, Math.max(drag_start_y, pointer.y + 1))) - rect_y;
          };
          tool.pointerup = () => {
            $canvas_handles.show();
            tool.selectBox(rect_x, rect_y, rect_width, rect_height);
          };
          tool.cancel = () => {
            $canvas_handles.show();
          };
          tool.drawPreviewUnderGrid = (ctx, x, y, grid_visible, scale, translate_x, translate_y) => {
            if (!pointer_active) {
              return;
            }
            if (!pointer_has_moved) {
              return;
            }

            ctx.scale(scale, scale);
            ctx.translate(translate_x, translate_y);

            // make the document canvas part of the helper canvas so that inversion can apply to it
            ctx.drawImage(canvas, 0, 0);
          };
          tool.drawPreviewAboveGrid = (ctx, x, y, grid_visible, scale, translate_x, translate_y) => {
            if (!pointer_active) {
              return;
            }
            if (!pointer_has_moved) {
              return;
            }

            draw_selection_box(ctx, rect_x, rect_y, rect_width, rect_height, scale, translate_x, translate_y);
          };
        }
        if (tool.shape) {
          tool.shape_canvas = null;
          tool.pointerdown = () => {
            tool.shape_canvas = make_canvas(canvas.width, canvas.height);
          };
          tool.paint = () => {
            tool.shape_canvas.ctx.clearRect(0, 0, tool.shape_canvas.width, tool.shape_canvas.height);
            tool.shape_canvas.ctx.fillStyle = ctx.fillStyle;
            tool.shape_canvas.ctx.strokeStyle = ctx.strokeStyle;
            tool.shape_canvas.ctx.lineWidth = ctx.lineWidth;
            tool.shape(tool.shape_canvas.ctx, pointer_start.x, pointer_start.y, pointer.x - pointer_start.x, pointer.y - pointer_start.y);
          };
          tool.pointerup = () => {
            if (!tool.shape_canvas) {
              return;
            }
            undoable({
              name: tool.name,
              icon: get_icon_for_tool(tool),
            }, () => {
              ctx.drawImage(tool.shape_canvas, 0, 0);
              tool.shape_canvas = null;
            });
          };
          tool.drawPreviewUnderGrid = (ctx, x, y, grid_visible, scale, translate_x, translate_y) => {
            if (!pointer_active) {
              return;
            }
            if (!tool.shape_canvas) {
              return;
            }

            ctx.scale(scale, scale);
            ctx.translate(translate_x, translate_y);

            ctx.drawImage(tool.shape_canvas, 0, 0);
          };
        }
        if (tool.paint_mask) {

          // binary mask of the drawn area, either opaque white or transparent
          tool.mask_canvas = null;

          tool.pointerdown = (ctx, x, y) => {
            if (!tool.mask_canvas) {
              tool.mask_canvas = make_canvas(canvas.width, canvas.height);
            }
            if (tool.mask_canvas.width !== canvas.width) {
              tool.mask_canvas.width = canvas.width;
            }
            if (tool.mask_canvas.height !== canvas.height) {
              tool.mask_canvas.height = canvas.height;
            }
            tool.mask_canvas.ctx.disable_image_smoothing();
          };
          tool.pointerup = () => {
            undoable({
              name: tool.name,
              icon: get_icon_for_tool(tool),
            }, () => {
              tool.render_from_mask(ctx);

              tool.mask_canvas.width = 1;
              tool.mask_canvas.height = 1;
            });
          };
          tool.paint = (ctx, x, y) => {
            tool.paint_mask(tool.mask_canvas.ctx, x, y);
          };
          tool.cancel = () => {
            if (tool.mask_canvas) {
              tool.mask_canvas.width = 1;
              tool.mask_canvas.height = 1;
            }
          };
          tool.render_from_mask = (ctx, previewing) => { // could be private
            ctx.save();
            ctx.globalCompositeOperation = "destination-out";
            ctx.drawImage(tool.mask_canvas, 0, 0);
            ctx.restore();

            let color = stroke_color;
            const translucent = get_rgba_from_color(color)[3] < 255;
            if (translucent && previewing) {
              const t = performance.now() / 2000;
              // 5 distinct colors, 5 distinct gradients, 7 color stops, 6 gradients
              const n = 6;
              const h = ctx.canvas.height;
              const y = (t % 1) * -h * (n - 1);
              const gradient = ctx.createLinearGradient(0, y, 0, y + h * n);
              gradient.addColorStop(0 / n, "red");
              gradient.addColorStop(1 / n, "gold");
              gradient.addColorStop(2 / n, "#00d90b");
              gradient.addColorStop(3 / n, "#2e64d9");
              gradient.addColorStop(4 / n, "#8f2ed9");
              // last two same as the first two so it can seamlessly wrap
              gradient.addColorStop(5 / n, "red");
              gradient.addColorStop(6 / n, "gold");
              color = gradient;
            }
            // @TODO: perf: keep this canvas around too
            const mask_fill_canvas = make_canvas(tool.mask_canvas);
            replace_colors_with_swatch(mask_fill_canvas.ctx, color, 0, 0);
            ctx.drawImage(mask_fill_canvas, 0, 0);
            return translucent;
          };
          tool.drawPreviewUnderGrid = (ctx, x, y, grid_visible, scale, translate_x, translate_y) => {
            if (!pointer_active && !pointer_over_canvas) {
              return;
            }

            ctx.scale(scale, scale);
            ctx.translate(translate_x, translate_y);

            if (tool.mask_canvas) {
              const should_animate = tool.render_from_mask(ctx, true);
              if (should_animate) {
                // animate for gradient
                requestAnimationFrame(update_helper_layer);
              }
            }
          };
        }
        if (tool.get_brush) {
          // binary mask of the drawn area, either opaque white or transparent
          tool.mask_canvas = null;

          tool.init_mask_canvas = (ctx, x, y) => {
            if (!tool.mask_canvas) {
              tool.mask_canvas = make_canvas(canvas.width, canvas.height);
            }
            if (tool.mask_canvas.width !== canvas.width) {
              tool.mask_canvas.width = canvas.width;
            }
            if (tool.mask_canvas.height !== canvas.height) {
              tool.mask_canvas.height = canvas.height;
            }
            tool.mask_canvas.ctx.disable_image_smoothing();
          };
          tool.pointerdown = (ctx, x, y) => {
            tool.init_mask_canvas();
          };
          tool.pointerup = () => {
            undoable({
              name: tool.name,
              icon: get_icon_for_tool(tool),
            }, () => {
              tool.render_from_mask(ctx);

              tool.mask_canvas.width = 1;
              tool.mask_canvas.height = 1;
            });
          };

          tool.paint = () => {
            const brush = tool.get_brush();
            const circumference_points = get_circumference_points_for_brush(brush.shape, brush.size);
            tool.mask_canvas.ctx.fillStyle = stroke_color;
            const iterate_line = brush.size > 1 ? brosandham_line : bresenham_line;
            iterate_line(pointer_previous.x, pointer_previous.y, pointer.x, pointer.y, (x, y) => {
              for (const point of circumference_points) {
                tool.mask_canvas.ctx.fillRect(x + point.x, y + point.y, 1, 1);
              }
            });
            stamp_brush_canvas(tool.mask_canvas.ctx, pointer_previous.x, pointer_previous.y, brush.shape, brush.size);
            stamp_brush_canvas(tool.mask_canvas.ctx, pointer.x, pointer.y, brush.shape, brush.size);
          };

          tool.cancel = () => {
            if (tool.mask_canvas) {
              tool.mask_canvas.width = 1;
              tool.mask_canvas.height = 1;
            }
          };
          tool.render_from_mask = (ctx, previewing) => { // could be private
            ctx.save();
            ctx.globalCompositeOperation = "destination-out";
            ctx.drawImage(tool.mask_canvas, 0, 0);
            ctx.restore();

            let color = stroke_color;
            const translucent = get_rgba_from_color(color)[3] < 255;
            if (translucent && previewing) {
              const t = performance.now() / 2000;
              // 5 distinct colors, 5 distinct gradients, 7 color stops, 6 gradients
              const n = 6;
              const h = ctx.canvas.height;
              const y = (t % 1) * -h * (n - 1);
              const gradient = ctx.createLinearGradient(0, y, 0, y + h * n);
              gradient.addColorStop(0 / n, "red");
              gradient.addColorStop(1 / n, "gold");
              gradient.addColorStop(2 / n, "#00d90b");
              gradient.addColorStop(3 / n, "#2e64d9");
              gradient.addColorStop(4 / n, "#8f2ed9");
              // last two same as the first two so it can seamlessly wrap
              gradient.addColorStop(5 / n, "red");
              gradient.addColorStop(6 / n, "gold");
              color = gradient;
            }
            // @TODO: perf: keep this canvas around too
            const mask_fill_canvas = make_canvas(tool.mask_canvas);
            if (previewing && tool.dynamic_preview_cursor) {
              const brush = tool.get_brush();
              // dynamic cursor preview:
              // stamp just onto this temporary canvas so it's temporary
              stamp_brush_canvas(mask_fill_canvas.ctx, pointer.x, pointer.y, brush.shape, brush.size);
            }
            replace_colors_with_swatch(mask_fill_canvas.ctx, color, 0, 0);
            ctx.drawImage(mask_fill_canvas, 0, 0);
            return translucent;
          };
          tool.drawPreviewUnderGrid = (ctx, x, y, grid_visible, scale, translate_x, translate_y) => {
            if (!pointer_active && !pointer_over_canvas) {
              return;
            }

            ctx.scale(scale, scale);
            ctx.translate(translate_x, translate_y);

            tool.init_mask_canvas();

            const should_animate = tool.render_from_mask(ctx, true);

            if (should_animate) {
              // animate for gradient
              requestAnimationFrame(update_helper_layer);
            }
          };
        }
      });

    })();
  </script>
  <script>
    const GIF_WORKER_SCRIPT_BASE64 = "data:text/javascript;base64,Ly8gZ2lmLndvcmtlci5qcyBAIGh0dHBzOi8vZ2l0aHViLmNvbS9qbm9yZGJlcmcvZ2lmLmpzL3RyZWUvOTJkMjdhMDI4NDEzMzllMjAyYzc1MTUwZGNmNmZlNWY0ZmE0MmVjNQooZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz0iZnVuY3Rpb24iPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcigiQ2Fubm90IGZpbmQgbW9kdWxlICciK2krIiciKTt0aHJvdyBhLmNvZGU9Ik1PRFVMRV9OT1RfRk9VTkQiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT0iZnVuY3Rpb24iPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkoezE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe3ZhciBOZXVRdWFudD1yZXF1aXJlKCIuL1R5cGVkTmV1UXVhbnQuanMiKTt2YXIgTFpXRW5jb2Rlcj1yZXF1aXJlKCIuL0xaV0VuY29kZXIuanMiKTtmdW5jdGlvbiBCeXRlQXJyYXkoKXt0aGlzLnBhZ2U9LTE7dGhpcy5wYWdlcz1bXTt0aGlzLm5ld1BhZ2UoKX1CeXRlQXJyYXkucGFnZVNpemU9NDA5NjtCeXRlQXJyYXkuY2hhck1hcD17fTtmb3IodmFyIGk9MDtpPDI1NjtpKyspQnl0ZUFycmF5LmNoYXJNYXBbaV09U3RyaW5nLmZyb21DaGFyQ29kZShpKTtCeXRlQXJyYXkucHJvdG90eXBlLm5ld1BhZ2U9ZnVuY3Rpb24oKXt0aGlzLnBhZ2VzWysrdGhpcy5wYWdlXT1uZXcgVWludDhBcnJheShCeXRlQXJyYXkucGFnZVNpemUpO3RoaXMuY3Vyc29yPTB9O0J5dGVBcnJheS5wcm90b3R5cGUuZ2V0RGF0YT1mdW5jdGlvbigpe3ZhciBydj0iIjtmb3IodmFyIHA9MDtwPHRoaXMucGFnZXMubGVuZ3RoO3ArKyl7Zm9yKHZhciBpPTA7aTxCeXRlQXJyYXkucGFnZVNpemU7aSsrKXtydis9Qnl0ZUFycmF5LmNoYXJNYXBbdGhpcy5wYWdlc1twXVtpXV19fXJldHVybiBydn07Qnl0ZUFycmF5LnByb3RvdHlwZS53cml0ZUJ5dGU9ZnVuY3Rpb24odmFsKXtpZih0aGlzLmN1cnNvcj49Qnl0ZUFycmF5LnBhZ2VTaXplKXRoaXMubmV3UGFnZSgpO3RoaXMucGFnZXNbdGhpcy5wYWdlXVt0aGlzLmN1cnNvcisrXT12YWx9O0J5dGVBcnJheS5wcm90b3R5cGUud3JpdGVVVEZCeXRlcz1mdW5jdGlvbihzdHJpbmcpe2Zvcih2YXIgbD1zdHJpbmcubGVuZ3RoLGk9MDtpPGw7aSsrKXRoaXMud3JpdGVCeXRlKHN0cmluZy5jaGFyQ29kZUF0KGkpKX07Qnl0ZUFycmF5LnByb3RvdHlwZS53cml0ZUJ5dGVzPWZ1bmN0aW9uKGFycmF5LG9mZnNldCxsZW5ndGgpe2Zvcih2YXIgbD1sZW5ndGh8fGFycmF5Lmxlbmd0aCxpPW9mZnNldHx8MDtpPGw7aSsrKXRoaXMud3JpdGVCeXRlKGFycmF5W2ldKX07ZnVuY3Rpb24gR0lGRW5jb2Rlcih3aWR0aCxoZWlnaHQpe3RoaXMud2lkdGg9fn53aWR0aDt0aGlzLmhlaWdodD1+fmhlaWdodDt0aGlzLnRyYW5zcGFyZW50PW51bGw7dGhpcy50cmFuc0luZGV4PTA7dGhpcy5yZXBlYXQ9LTE7dGhpcy5kZWxheT0wO3RoaXMuaW1hZ2U9bnVsbDt0aGlzLnBpeGVscz1udWxsO3RoaXMuaW5kZXhlZFBpeGVscz1udWxsO3RoaXMuY29sb3JEZXB0aD1udWxsO3RoaXMuY29sb3JUYWI9bnVsbDt0aGlzLm5ldVF1YW50PW51bGw7dGhpcy51c2VkRW50cnk9bmV3IEFycmF5O3RoaXMucGFsU2l6ZT03O3RoaXMuZGlzcG9zZT0tMTt0aGlzLmZpcnN0RnJhbWU9dHJ1ZTt0aGlzLnNhbXBsZT0xMDt0aGlzLmRpdGhlcj1mYWxzZTt0aGlzLmdsb2JhbFBhbGV0dGU9ZmFsc2U7dGhpcy5vdXQ9bmV3IEJ5dGVBcnJheX1HSUZFbmNvZGVyLnByb3RvdHlwZS5zZXREZWxheT1mdW5jdGlvbihtaWxsaXNlY29uZHMpe3RoaXMuZGVsYXk9TWF0aC5yb3VuZChtaWxsaXNlY29uZHMvMTApfTtHSUZFbmNvZGVyLnByb3RvdHlwZS5zZXRGcmFtZVJhdGU9ZnVuY3Rpb24oZnBzKXt0aGlzLmRlbGF5PU1hdGgucm91bmQoMTAwL2Zwcyl9O0dJRkVuY29kZXIucHJvdG90eXBlLnNldERpc3Bvc2U9ZnVuY3Rpb24oZGlzcG9zYWxDb2RlKXtpZihkaXNwb3NhbENvZGU+PTApdGhpcy5kaXNwb3NlPWRpc3Bvc2FsQ29kZX07R0lGRW5jb2Rlci5wcm90b3R5cGUuc2V0UmVwZWF0PWZ1bmN0aW9uKHJlcGVhdCl7dGhpcy5yZXBlYXQ9cmVwZWF0fTtHSUZFbmNvZGVyLnByb3RvdHlwZS5zZXRUcmFuc3BhcmVudD1mdW5jdGlvbihjb2xvcil7dGhpcy50cmFuc3BhcmVudD1jb2xvcn07R0lGRW5jb2Rlci5wcm90b3R5cGUuYWRkRnJhbWU9ZnVuY3Rpb24oaW1hZ2VEYXRhKXt0aGlzLmltYWdlPWltYWdlRGF0YTt0aGlzLmNvbG9yVGFiPXRoaXMuZ2xvYmFsUGFsZXR0ZSYmdGhpcy5nbG9iYWxQYWxldHRlLnNsaWNlP3RoaXMuZ2xvYmFsUGFsZXR0ZTpudWxsO3RoaXMuZ2V0SW1hZ2VQaXhlbHMoKTt0aGlzLmFuYWx5emVQaXhlbHMoKTtpZih0aGlzLmdsb2JhbFBhbGV0dGU9PT10cnVlKXRoaXMuZ2xvYmFsUGFsZXR0ZT10aGlzLmNvbG9yVGFiO2lmKHRoaXMuZmlyc3RGcmFtZSl7dGhpcy53cml0ZUxTRCgpO3RoaXMud3JpdGVQYWxldHRlKCk7aWYodGhpcy5yZXBlYXQ+PTApe3RoaXMud3JpdGVOZXRzY2FwZUV4dCgpfX10aGlzLndyaXRlR3JhcGhpY0N0cmxFeHQoKTt0aGlzLndyaXRlSW1hZ2VEZXNjKCk7aWYoIXRoaXMuZmlyc3RGcmFtZSYmIXRoaXMuZ2xvYmFsUGFsZXR0ZSl0aGlzLndyaXRlUGFsZXR0ZSgpO3RoaXMud3JpdGVQaXhlbHMoKTt0aGlzLmZpcnN0RnJhbWU9ZmFsc2V9O0dJRkVuY29kZXIucHJvdG90eXBlLmZpbmlzaD1mdW5jdGlvbigpe3RoaXMub3V0LndyaXRlQnl0ZSg1OSl9O0dJRkVuY29kZXIucHJvdG90eXBlLnNldFF1YWxpdHk9ZnVuY3Rpb24ocXVhbGl0eSl7aWYocXVhbGl0eTwxKXF1YWxpdHk9MTt0aGlzLnNhbXBsZT1xdWFsaXR5fTtHSUZFbmNvZGVyLnByb3RvdHlwZS5zZXREaXRoZXI9ZnVuY3Rpb24oZGl0aGVyKXtpZihkaXRoZXI9PT10cnVlKWRpdGhlcj0iRmxveWRTdGVpbmJlcmciO3RoaXMuZGl0aGVyPWRpdGhlcn07R0lGRW5jb2Rlci5wcm90b3R5cGUuc2V0R2xvYmFsUGFsZXR0ZT1mdW5jdGlvbihwYWxldHRlKXt0aGlzLmdsb2JhbFBhbGV0dGU9cGFsZXR0ZX07R0lGRW5jb2Rlci5wcm90b3R5cGUuZ2V0R2xvYmFsUGFsZXR0ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdsb2JhbFBhbGV0dGUmJnRoaXMuZ2xvYmFsUGFsZXR0ZS5zbGljZSYmdGhpcy5nbG9iYWxQYWxldHRlLnNsaWNlKDApfHx0aGlzLmdsb2JhbFBhbGV0dGV9O0dJRkVuY29kZXIucHJvdG90eXBlLndyaXRlSGVhZGVyPWZ1bmN0aW9uKCl7dGhpcy5vdXQud3JpdGVVVEZCeXRlcygiR0lGODlhIil9O0dJRkVuY29kZXIucHJvdG90eXBlLmFuYWx5emVQaXhlbHM9ZnVuY3Rpb24oKXtpZighdGhpcy5jb2xvclRhYil7dGhpcy5uZXVRdWFudD1uZXcgTmV1UXVhbnQodGhpcy5waXhlbHMsdGhpcy5zYW1wbGUpO3RoaXMubmV1UXVhbnQuYnVpbGRDb2xvcm1hcCgpO3RoaXMuY29sb3JUYWI9dGhpcy5uZXVRdWFudC5nZXRDb2xvcm1hcCgpfWlmKHRoaXMuZGl0aGVyKXt0aGlzLmRpdGhlclBpeGVscyh0aGlzLmRpdGhlci5yZXBsYWNlKCItc2VycGVudGluZSIsIiIpLHRoaXMuZGl0aGVyLm1hdGNoKC8tc2VycGVudGluZS8pIT09bnVsbCl9ZWxzZXt0aGlzLmluZGV4UGl4ZWxzKCl9dGhpcy5waXhlbHM9bnVsbDt0aGlzLmNvbG9yRGVwdGg9ODt0aGlzLnBhbFNpemU9NztpZih0aGlzLnRyYW5zcGFyZW50IT09bnVsbCl7dGhpcy50cmFuc0luZGV4PXRoaXMuZmluZENsb3Nlc3QodGhpcy50cmFuc3BhcmVudCx0cnVlKX19O0dJRkVuY29kZXIucHJvdG90eXBlLmluZGV4UGl4ZWxzPWZ1bmN0aW9uKGltZ3Epe3ZhciBuUGl4PXRoaXMucGl4ZWxzLmxlbmd0aC8zO3RoaXMuaW5kZXhlZFBpeGVscz1uZXcgVWludDhBcnJheShuUGl4KTt2YXIgaz0wO2Zvcih2YXIgaj0wO2o8blBpeDtqKyspe3ZhciBpbmRleD10aGlzLmZpbmRDbG9zZXN0UkdCKHRoaXMucGl4ZWxzW2srK10mMjU1LHRoaXMucGl4ZWxzW2srK10mMjU1LHRoaXMucGl4ZWxzW2srK10mMjU1KTt0aGlzLnVzZWRFbnRyeVtpbmRleF09dHJ1ZTt0aGlzLmluZGV4ZWRQaXhlbHNbal09aW5kZXh9fTtHSUZFbmNvZGVyLnByb3RvdHlwZS5kaXRoZXJQaXhlbHM9ZnVuY3Rpb24oa2VybmVsLHNlcnBlbnRpbmUpe3ZhciBrZXJuZWxzPXtGYWxzZUZsb3lkU3RlaW5iZXJnOltbMy84LDEsMF0sWzMvOCwwLDFdLFsyLzgsMSwxXV0sRmxveWRTdGVpbmJlcmc6W1s3LzE2LDEsMF0sWzMvMTYsLTEsMV0sWzUvMTYsMCwxXSxbMS8xNiwxLDFdXSxTdHVja2k6W1s4LzQyLDEsMF0sWzQvNDIsMiwwXSxbMi80MiwtMiwxXSxbNC80MiwtMSwxXSxbOC80MiwwLDFdLFs0LzQyLDEsMV0sWzIvNDIsMiwxXSxbMS80MiwtMiwyXSxbMi80MiwtMSwyXSxbNC80MiwwLDJdLFsyLzQyLDEsMl0sWzEvNDIsMiwyXV0sQXRraW5zb246W1sxLzgsMSwwXSxbMS84LDIsMF0sWzEvOCwtMSwxXSxbMS84LDAsMV0sWzEvOCwxLDFdLFsxLzgsMCwyXV19O2lmKCFrZXJuZWx8fCFrZXJuZWxzW2tlcm5lbF0pe3Rocm93IlVua25vd24gZGl0aGVyaW5nIGtlcm5lbDogIitrZXJuZWx9dmFyIGRzPWtlcm5lbHNba2VybmVsXTt2YXIgaW5kZXg9MCxoZWlnaHQ9dGhpcy5oZWlnaHQsd2lkdGg9dGhpcy53aWR0aCxkYXRhPXRoaXMucGl4ZWxzO3ZhciBkaXJlY3Rpb249c2VycGVudGluZT8tMToxO3RoaXMuaW5kZXhlZFBpeGVscz1uZXcgVWludDhBcnJheSh0aGlzLnBpeGVscy5sZW5ndGgvMyk7Zm9yKHZhciB5PTA7eTxoZWlnaHQ7eSsrKXtpZihzZXJwZW50aW5lKWRpcmVjdGlvbj1kaXJlY3Rpb24qLTE7Zm9yKHZhciB4PWRpcmVjdGlvbj09MT8wOndpZHRoLTEseGVuZD1kaXJlY3Rpb249PTE/d2lkdGg6MDt4IT09eGVuZDt4Kz1kaXJlY3Rpb24pe2luZGV4PXkqd2lkdGgreDt2YXIgaWR4PWluZGV4KjM7dmFyIHIxPWRhdGFbaWR4XTt2YXIgZzE9ZGF0YVtpZHgrMV07dmFyIGIxPWRhdGFbaWR4KzJdO2lkeD10aGlzLmZpbmRDbG9zZXN0UkdCKHIxLGcxLGIxKTt0aGlzLnVzZWRFbnRyeVtpZHhdPXRydWU7dGhpcy5pbmRleGVkUGl4ZWxzW2luZGV4XT1pZHg7aWR4Kj0zO3ZhciByMj10aGlzLmNvbG9yVGFiW2lkeF07dmFyIGcyPXRoaXMuY29sb3JUYWJbaWR4KzFdO3ZhciBiMj10aGlzLmNvbG9yVGFiW2lkeCsyXTt2YXIgZXI9cjEtcjI7dmFyIGVnPWcxLWcyO3ZhciBlYj1iMS1iMjtmb3IodmFyIGk9ZGlyZWN0aW9uPT0xPzA6ZHMubGVuZ3RoLTEsZW5kPWRpcmVjdGlvbj09MT9kcy5sZW5ndGg6MDtpIT09ZW5kO2krPWRpcmVjdGlvbil7dmFyIHgxPWRzW2ldWzFdO3ZhciB5MT1kc1tpXVsyXTtpZih4MSt4Pj0wJiZ4MSt4PHdpZHRoJiZ5MSt5Pj0wJiZ5MSt5PGhlaWdodCl7dmFyIGQ9ZHNbaV1bMF07aWR4PWluZGV4K3gxK3kxKndpZHRoO2lkeCo9MztkYXRhW2lkeF09TWF0aC5tYXgoMCxNYXRoLm1pbigyNTUsZGF0YVtpZHhdK2VyKmQpKTtkYXRhW2lkeCsxXT1NYXRoLm1heCgwLE1hdGgubWluKDI1NSxkYXRhW2lkeCsxXStlZypkKSk7ZGF0YVtpZHgrMl09TWF0aC5tYXgoMCxNYXRoLm1pbigyNTUsZGF0YVtpZHgrMl0rZWIqZCkpfX19fX07R0lGRW5jb2Rlci5wcm90b3R5cGUuZmluZENsb3Nlc3Q9ZnVuY3Rpb24oYyx1c2VkKXtyZXR1cm4gdGhpcy5maW5kQ2xvc2VzdFJHQigoYyYxNjcxMTY4MCk+PjE2LChjJjY1MjgwKT4+OCxjJjI1NSx1c2VkKX07R0lGRW5jb2Rlci5wcm90b3R5cGUuZmluZENsb3Nlc3RSR0I9ZnVuY3Rpb24ocixnLGIsdXNlZCl7aWYodGhpcy5jb2xvclRhYj09PW51bGwpcmV0dXJuLTE7aWYodGhpcy5uZXVRdWFudCYmIXVzZWQpe3JldHVybiB0aGlzLm5ldVF1YW50Lmxvb2t1cFJHQihyLGcsYil9dmFyIGM9YnxnPDw4fHI8PDE2O3ZhciBtaW5wb3M9MDt2YXIgZG1pbj0yNTYqMjU2KjI1Njt2YXIgbGVuPXRoaXMuY29sb3JUYWIubGVuZ3RoO2Zvcih2YXIgaT0wLGluZGV4PTA7aTxsZW47aW5kZXgrKyl7dmFyIGRyPXItKHRoaXMuY29sb3JUYWJbaSsrXSYyNTUpO3ZhciBkZz1nLSh0aGlzLmNvbG9yVGFiW2krK10mMjU1KTt2YXIgZGI9Yi0odGhpcy5jb2xvclRhYltpKytdJjI1NSk7dmFyIGQ9ZHIqZHIrZGcqZGcrZGIqZGI7aWYoKCF1c2VkfHx0aGlzLnVzZWRFbnRyeVtpbmRleF0pJiZkPGRtaW4pe2RtaW49ZDttaW5wb3M9aW5kZXh9fXJldHVybiBtaW5wb3N9O0dJRkVuY29kZXIucHJvdG90eXBlLmdldEltYWdlUGl4ZWxzPWZ1bmN0aW9uKCl7dmFyIHc9dGhpcy53aWR0aDt2YXIgaD10aGlzLmhlaWdodDt0aGlzLnBpeGVscz1uZXcgVWludDhBcnJheSh3KmgqMyk7dmFyIGRhdGE9dGhpcy5pbWFnZTt2YXIgc3JjUG9zPTA7dmFyIGNvdW50PTA7Zm9yKHZhciBpPTA7aTxoO2krKyl7Zm9yKHZhciBqPTA7ajx3O2orKyl7dGhpcy5waXhlbHNbY291bnQrK109ZGF0YVtzcmNQb3MrK107dGhpcy5waXhlbHNbY291bnQrK109ZGF0YVtzcmNQb3MrK107dGhpcy5waXhlbHNbY291bnQrK109ZGF0YVtzcmNQb3MrK107c3JjUG9zKyt9fX07R0lGRW5jb2Rlci5wcm90b3R5cGUud3JpdGVHcmFwaGljQ3RybEV4dD1mdW5jdGlvbigpe3RoaXMub3V0LndyaXRlQnl0ZSgzMyk7dGhpcy5vdXQud3JpdGVCeXRlKDI0OSk7dGhpcy5vdXQud3JpdGVCeXRlKDQpO3ZhciB0cmFuc3AsZGlzcDtpZih0aGlzLnRyYW5zcGFyZW50PT09bnVsbCl7dHJhbnNwPTA7ZGlzcD0wfWVsc2V7dHJhbnNwPTE7ZGlzcD0yfWlmKHRoaXMuZGlzcG9zZT49MCl7ZGlzcD10aGlzLmRpc3Bvc2UmN31kaXNwPDw9Mjt0aGlzLm91dC53cml0ZUJ5dGUoMHxkaXNwfDB8dHJhbnNwKTt0aGlzLndyaXRlU2hvcnQodGhpcy5kZWxheSk7dGhpcy5vdXQud3JpdGVCeXRlKHRoaXMudHJhbnNJbmRleCk7dGhpcy5vdXQud3JpdGVCeXRlKDApfTtHSUZFbmNvZGVyLnByb3RvdHlwZS53cml0ZUltYWdlRGVzYz1mdW5jdGlvbigpe3RoaXMub3V0LndyaXRlQnl0ZSg0NCk7dGhpcy53cml0ZVNob3J0KDApO3RoaXMud3JpdGVTaG9ydCgwKTt0aGlzLndyaXRlU2hvcnQodGhpcy53aWR0aCk7dGhpcy53cml0ZVNob3J0KHRoaXMuaGVpZ2h0KTtpZih0aGlzLmZpcnN0RnJhbWV8fHRoaXMuZ2xvYmFsUGFsZXR0ZSl7dGhpcy5vdXQud3JpdGVCeXRlKDApfWVsc2V7dGhpcy5vdXQud3JpdGVCeXRlKDEyOHwwfDB8MHx0aGlzLnBhbFNpemUpfX07R0lGRW5jb2Rlci5wcm90b3R5cGUud3JpdGVMU0Q9ZnVuY3Rpb24oKXt0aGlzLndyaXRlU2hvcnQodGhpcy53aWR0aCk7dGhpcy53cml0ZVNob3J0KHRoaXMuaGVpZ2h0KTt0aGlzLm91dC53cml0ZUJ5dGUoMTI4fDExMnwwfHRoaXMucGFsU2l6ZSk7dGhpcy5vdXQud3JpdGVCeXRlKDApO3RoaXMub3V0LndyaXRlQnl0ZSgwKX07R0lGRW5jb2Rlci5wcm90b3R5cGUud3JpdGVOZXRzY2FwZUV4dD1mdW5jdGlvbigpe3RoaXMub3V0LndyaXRlQnl0ZSgzMyk7dGhpcy5vdXQud3JpdGVCeXRlKDI1NSk7dGhpcy5vdXQud3JpdGVCeXRlKDExKTt0aGlzLm91dC53cml0ZVVURkJ5dGVzKCJORVRTQ0FQRTIuMCIpO3RoaXMub3V0LndyaXRlQnl0ZSgzKTt0aGlzLm91dC53cml0ZUJ5dGUoMSk7dGhpcy53cml0ZVNob3J0KHRoaXMucmVwZWF0KTt0aGlzLm91dC53cml0ZUJ5dGUoMCl9O0dJRkVuY29kZXIucHJvdG90eXBlLndyaXRlUGFsZXR0ZT1mdW5jdGlvbigpe3RoaXMub3V0LndyaXRlQnl0ZXModGhpcy5jb2xvclRhYik7dmFyIG49MyoyNTYtdGhpcy5jb2xvclRhYi5sZW5ndGg7Zm9yKHZhciBpPTA7aTxuO2krKyl0aGlzLm91dC53cml0ZUJ5dGUoMCl9O0dJRkVuY29kZXIucHJvdG90eXBlLndyaXRlU2hvcnQ9ZnVuY3Rpb24ocFZhbHVlKXt0aGlzLm91dC53cml0ZUJ5dGUocFZhbHVlJjI1NSk7dGhpcy5vdXQud3JpdGVCeXRlKHBWYWx1ZT4+OCYyNTUpfTtHSUZFbmNvZGVyLnByb3RvdHlwZS53cml0ZVBpeGVscz1mdW5jdGlvbigpe3ZhciBlbmM9bmV3IExaV0VuY29kZXIodGhpcy53aWR0aCx0aGlzLmhlaWdodCx0aGlzLmluZGV4ZWRQaXhlbHMsdGhpcy5jb2xvckRlcHRoKTtlbmMuZW5jb2RlKHRoaXMub3V0KX07R0lGRW5jb2Rlci5wcm90b3R5cGUuc3RyZWFtPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3V0fTttb2R1bGUuZXhwb3J0cz1HSUZFbmNvZGVyfSx7Ii4vTFpXRW5jb2Rlci5qcyI6MiwiLi9UeXBlZE5ldVF1YW50LmpzIjozfV0sMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIEVPRj0tMTt2YXIgQklUUz0xMjt2YXIgSFNJWkU9NTAwMzt2YXIgbWFza3M9WzAsMSwzLDcsMTUsMzEsNjMsMTI3LDI1NSw1MTEsMTAyMywyMDQ3LDQwOTUsODE5MSwxNjM4MywzMjc2Nyw2NTUzNV07ZnVuY3Rpb24gTFpXRW5jb2Rlcih3aWR0aCxoZWlnaHQscGl4ZWxzLGNvbG9yRGVwdGgpe3ZhciBpbml0Q29kZVNpemU9TWF0aC5tYXgoMixjb2xvckRlcHRoKTt2YXIgYWNjdW09bmV3IFVpbnQ4QXJyYXkoMjU2KTt2YXIgaHRhYj1uZXcgSW50MzJBcnJheShIU0laRSk7dmFyIGNvZGV0YWI9bmV3IEludDMyQXJyYXkoSFNJWkUpO3ZhciBjdXJfYWNjdW0sY3VyX2JpdHM9MDt2YXIgYV9jb3VudDt2YXIgZnJlZV9lbnQ9MDt2YXIgbWF4Y29kZTt2YXIgY2xlYXJfZmxnPWZhbHNlO3ZhciBnX2luaXRfYml0cyxDbGVhckNvZGUsRU9GQ29kZTtmdW5jdGlvbiBjaGFyX291dChjLG91dHMpe2FjY3VtW2FfY291bnQrK109YztpZihhX2NvdW50Pj0yNTQpZmx1c2hfY2hhcihvdXRzKX1mdW5jdGlvbiBjbF9ibG9jayhvdXRzKXtjbF9oYXNoKEhTSVpFKTtmcmVlX2VudD1DbGVhckNvZGUrMjtjbGVhcl9mbGc9dHJ1ZTtvdXRwdXQoQ2xlYXJDb2RlLG91dHMpfWZ1bmN0aW9uIGNsX2hhc2goaHNpemUpe2Zvcih2YXIgaT0wO2k8aHNpemU7KytpKWh0YWJbaV09LTF9ZnVuY3Rpb24gY29tcHJlc3MoaW5pdF9iaXRzLG91dHMpe3ZhciBmY29kZSxjLGksZW50LGRpc3AsaHNpemVfcmVnLGhzaGlmdDtnX2luaXRfYml0cz1pbml0X2JpdHM7Y2xlYXJfZmxnPWZhbHNlO25fYml0cz1nX2luaXRfYml0czttYXhjb2RlPU1BWENPREUobl9iaXRzKTtDbGVhckNvZGU9MTw8aW5pdF9iaXRzLTE7RU9GQ29kZT1DbGVhckNvZGUrMTtmcmVlX2VudD1DbGVhckNvZGUrMjthX2NvdW50PTA7ZW50PW5leHRQaXhlbCgpO2hzaGlmdD0wO2ZvcihmY29kZT1IU0laRTtmY29kZTw2NTUzNjtmY29kZSo9MikrK2hzaGlmdDtoc2hpZnQ9OC1oc2hpZnQ7aHNpemVfcmVnPUhTSVpFO2NsX2hhc2goaHNpemVfcmVnKTtvdXRwdXQoQ2xlYXJDb2RlLG91dHMpO291dGVyX2xvb3A6d2hpbGUoKGM9bmV4dFBpeGVsKCkpIT1FT0Ype2Zjb2RlPShjPDxCSVRTKStlbnQ7aT1jPDxoc2hpZnReZW50O2lmKGh0YWJbaV09PT1mY29kZSl7ZW50PWNvZGV0YWJbaV07Y29udGludWV9ZWxzZSBpZihodGFiW2ldPj0wKXtkaXNwPWhzaXplX3JlZy1pO2lmKGk9PT0wKWRpc3A9MTtkb3tpZigoaS09ZGlzcCk8MClpKz1oc2l6ZV9yZWc7aWYoaHRhYltpXT09PWZjb2RlKXtlbnQ9Y29kZXRhYltpXTtjb250aW51ZSBvdXRlcl9sb29wfX13aGlsZShodGFiW2ldPj0wKX1vdXRwdXQoZW50LG91dHMpO2VudD1jO2lmKGZyZWVfZW50PDE8PEJJVFMpe2NvZGV0YWJbaV09ZnJlZV9lbnQrKztodGFiW2ldPWZjb2RlfWVsc2V7Y2xfYmxvY2sob3V0cyl9fW91dHB1dChlbnQsb3V0cyk7b3V0cHV0KEVPRkNvZGUsb3V0cyl9ZnVuY3Rpb24gZW5jb2RlKG91dHMpe291dHMud3JpdGVCeXRlKGluaXRDb2RlU2l6ZSk7cmVtYWluaW5nPXdpZHRoKmhlaWdodDtjdXJQaXhlbD0wO2NvbXByZXNzKGluaXRDb2RlU2l6ZSsxLG91dHMpO291dHMud3JpdGVCeXRlKDApfWZ1bmN0aW9uIGZsdXNoX2NoYXIob3V0cyl7aWYoYV9jb3VudD4wKXtvdXRzLndyaXRlQnl0ZShhX2NvdW50KTtvdXRzLndyaXRlQnl0ZXMoYWNjdW0sMCxhX2NvdW50KTthX2NvdW50PTB9fWZ1bmN0aW9uIE1BWENPREUobl9iaXRzKXtyZXR1cm4oMTw8bl9iaXRzKS0xfWZ1bmN0aW9uIG5leHRQaXhlbCgpe2lmKHJlbWFpbmluZz09PTApcmV0dXJuIEVPRjstLXJlbWFpbmluZzt2YXIgcGl4PXBpeGVsc1tjdXJQaXhlbCsrXTtyZXR1cm4gcGl4JjI1NX1mdW5jdGlvbiBvdXRwdXQoY29kZSxvdXRzKXtjdXJfYWNjdW0mPW1hc2tzW2N1cl9iaXRzXTtpZihjdXJfYml0cz4wKWN1cl9hY2N1bXw9Y29kZTw8Y3VyX2JpdHM7ZWxzZSBjdXJfYWNjdW09Y29kZTtjdXJfYml0cys9bl9iaXRzO3doaWxlKGN1cl9iaXRzPj04KXtjaGFyX291dChjdXJfYWNjdW0mMjU1LG91dHMpO2N1cl9hY2N1bT4+PTg7Y3VyX2JpdHMtPTh9aWYoZnJlZV9lbnQ+bWF4Y29kZXx8Y2xlYXJfZmxnKXtpZihjbGVhcl9mbGcpe21heGNvZGU9TUFYQ09ERShuX2JpdHM9Z19pbml0X2JpdHMpO2NsZWFyX2ZsZz1mYWxzZX1lbHNleysrbl9iaXRzO2lmKG5fYml0cz09QklUUyltYXhjb2RlPTE8PEJJVFM7ZWxzZSBtYXhjb2RlPU1BWENPREUobl9iaXRzKX19aWYoY29kZT09RU9GQ29kZSl7d2hpbGUoY3VyX2JpdHM+MCl7Y2hhcl9vdXQoY3VyX2FjY3VtJjI1NSxvdXRzKTtjdXJfYWNjdW0+Pj04O2N1cl9iaXRzLT04fWZsdXNoX2NoYXIob3V0cyl9fXRoaXMuZW5jb2RlPWVuY29kZX1tb2R1bGUuZXhwb3J0cz1MWldFbmNvZGVyfSx7fV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7dmFyIG5jeWNsZXM9MTAwO3ZhciBuZXRzaXplPTI1Njt2YXIgbWF4bmV0cG9zPW5ldHNpemUtMTt2YXIgbmV0Ymlhc3NoaWZ0PTQ7dmFyIGludGJpYXNzaGlmdD0xNjt2YXIgaW50Ymlhcz0xPDxpbnRiaWFzc2hpZnQ7dmFyIGdhbW1hc2hpZnQ9MTA7dmFyIGdhbW1hPTE8PGdhbW1hc2hpZnQ7dmFyIGJldGFzaGlmdD0xMDt2YXIgYmV0YT1pbnRiaWFzPj5iZXRhc2hpZnQ7dmFyIGJldGFnYW1tYT1pbnRiaWFzPDxnYW1tYXNoaWZ0LWJldGFzaGlmdDt2YXIgaW5pdHJhZD1uZXRzaXplPj4zO3ZhciByYWRpdXNiaWFzc2hpZnQ9Njt2YXIgcmFkaXVzYmlhcz0xPDxyYWRpdXNiaWFzc2hpZnQ7dmFyIGluaXRyYWRpdXM9aW5pdHJhZCpyYWRpdXNiaWFzO3ZhciByYWRpdXNkZWM9MzA7dmFyIGFscGhhYmlhc3NoaWZ0PTEwO3ZhciBpbml0YWxwaGE9MTw8YWxwaGFiaWFzc2hpZnQ7dmFyIGFscGhhZGVjO3ZhciByYWRiaWFzc2hpZnQ9ODt2YXIgcmFkYmlhcz0xPDxyYWRiaWFzc2hpZnQ7dmFyIGFscGhhcmFkYnNoaWZ0PWFscGhhYmlhc3NoaWZ0K3JhZGJpYXNzaGlmdDt2YXIgYWxwaGFyYWRiaWFzPTE8PGFscGhhcmFkYnNoaWZ0O3ZhciBwcmltZTE9NDk5O3ZhciBwcmltZTI9NDkxO3ZhciBwcmltZTM9NDg3O3ZhciBwcmltZTQ9NTAzO3ZhciBtaW5waWN0dXJlYnl0ZXM9MypwcmltZTQ7ZnVuY3Rpb24gTmV1UXVhbnQocGl4ZWxzLHNhbXBsZWZhYyl7dmFyIG5ldHdvcms7dmFyIG5ldGluZGV4O3ZhciBiaWFzO3ZhciBmcmVxO3ZhciByYWRwb3dlcjtmdW5jdGlvbiBpbml0KCl7bmV0d29yaz1bXTtuZXRpbmRleD1uZXcgSW50MzJBcnJheSgyNTYpO2JpYXM9bmV3IEludDMyQXJyYXkobmV0c2l6ZSk7ZnJlcT1uZXcgSW50MzJBcnJheShuZXRzaXplKTtyYWRwb3dlcj1uZXcgSW50MzJBcnJheShuZXRzaXplPj4zKTt2YXIgaSx2O2ZvcihpPTA7aTxuZXRzaXplO2krKyl7dj0oaTw8bmV0Ymlhc3NoaWZ0KzgpL25ldHNpemU7bmV0d29ya1tpXT1uZXcgRmxvYXQ2NEFycmF5KFt2LHYsdiwwXSk7ZnJlcVtpXT1pbnRiaWFzL25ldHNpemU7Ymlhc1tpXT0wfX1mdW5jdGlvbiB1bmJpYXNuZXQoKXtmb3IodmFyIGk9MDtpPG5ldHNpemU7aSsrKXtuZXR3b3JrW2ldWzBdPj49bmV0Ymlhc3NoaWZ0O25ldHdvcmtbaV1bMV0+Pj1uZXRiaWFzc2hpZnQ7bmV0d29ya1tpXVsyXT4+PW5ldGJpYXNzaGlmdDtuZXR3b3JrW2ldWzNdPWl9fWZ1bmN0aW9uIGFsdGVyc2luZ2xlKGFscGhhLGksYixnLHIpe25ldHdvcmtbaV1bMF0tPWFscGhhKihuZXR3b3JrW2ldWzBdLWIpL2luaXRhbHBoYTtuZXR3b3JrW2ldWzFdLT1hbHBoYSoobmV0d29ya1tpXVsxXS1nKS9pbml0YWxwaGE7bmV0d29ya1tpXVsyXS09YWxwaGEqKG5ldHdvcmtbaV1bMl0tcikvaW5pdGFscGhhfWZ1bmN0aW9uIGFsdGVybmVpZ2gocmFkaXVzLGksYixnLHIpe3ZhciBsbz1NYXRoLmFicyhpLXJhZGl1cyk7dmFyIGhpPU1hdGgubWluKGkrcmFkaXVzLG5ldHNpemUpO3ZhciBqPWkrMTt2YXIgaz1pLTE7dmFyIG09MTt2YXIgcCxhO3doaWxlKGo8aGl8fGs+bG8pe2E9cmFkcG93ZXJbbSsrXTtpZihqPGhpKXtwPW5ldHdvcmtbaisrXTtwWzBdLT1hKihwWzBdLWIpL2FscGhhcmFkYmlhcztwWzFdLT1hKihwWzFdLWcpL2FscGhhcmFkYmlhcztwWzJdLT1hKihwWzJdLXIpL2FscGhhcmFkYmlhc31pZihrPmxvKXtwPW5ldHdvcmtbay0tXTtwWzBdLT1hKihwWzBdLWIpL2FscGhhcmFkYmlhcztwWzFdLT1hKihwWzFdLWcpL2FscGhhcmFkYmlhcztwWzJdLT1hKihwWzJdLXIpL2FscGhhcmFkYmlhc319fWZ1bmN0aW9uIGNvbnRlc3QoYixnLHIpe3ZhciBiZXN0ZD1+KDE8PDMxKTt2YXIgYmVzdGJpYXNkPWJlc3RkO3ZhciBiZXN0cG9zPS0xO3ZhciBiZXN0Ymlhc3Bvcz1iZXN0cG9zO3ZhciBpLG4sZGlzdCxiaWFzZGlzdCxiZXRhZnJlcTtmb3IoaT0wO2k8bmV0c2l6ZTtpKyspe249bmV0d29ya1tpXTtkaXN0PU1hdGguYWJzKG5bMF0tYikrTWF0aC5hYnMoblsxXS1nKStNYXRoLmFicyhuWzJdLXIpO2lmKGRpc3Q8YmVzdGQpe2Jlc3RkPWRpc3Q7YmVzdHBvcz1pfWJpYXNkaXN0PWRpc3QtKGJpYXNbaV0+PmludGJpYXNzaGlmdC1uZXRiaWFzc2hpZnQpO2lmKGJpYXNkaXN0PGJlc3RiaWFzZCl7YmVzdGJpYXNkPWJpYXNkaXN0O2Jlc3RiaWFzcG9zPWl9YmV0YWZyZXE9ZnJlcVtpXT4+YmV0YXNoaWZ0O2ZyZXFbaV0tPWJldGFmcmVxO2JpYXNbaV0rPWJldGFmcmVxPDxnYW1tYXNoaWZ0fWZyZXFbYmVzdHBvc10rPWJldGE7Ymlhc1tiZXN0cG9zXS09YmV0YWdhbW1hO3JldHVybiBiZXN0Ymlhc3Bvc31mdW5jdGlvbiBpbnhidWlsZCgpe3ZhciBpLGoscCxxLHNtYWxscG9zLHNtYWxsdmFsLHByZXZpb3VzY29sPTAsc3RhcnRwb3M9MDtmb3IoaT0wO2k8bmV0c2l6ZTtpKyspe3A9bmV0d29ya1tpXTtzbWFsbHBvcz1pO3NtYWxsdmFsPXBbMV07Zm9yKGo9aSsxO2o8bmV0c2l6ZTtqKyspe3E9bmV0d29ya1tqXTtpZihxWzFdPHNtYWxsdmFsKXtzbWFsbHBvcz1qO3NtYWxsdmFsPXFbMV19fXE9bmV0d29ya1tzbWFsbHBvc107aWYoaSE9c21hbGxwb3Mpe2o9cVswXTtxWzBdPXBbMF07cFswXT1qO2o9cVsxXTtxWzFdPXBbMV07cFsxXT1qO2o9cVsyXTtxWzJdPXBbMl07cFsyXT1qO2o9cVszXTtxWzNdPXBbM107cFszXT1qfWlmKHNtYWxsdmFsIT1wcmV2aW91c2NvbCl7bmV0aW5kZXhbcHJldmlvdXNjb2xdPXN0YXJ0cG9zK2k+PjE7Zm9yKGo9cHJldmlvdXNjb2wrMTtqPHNtYWxsdmFsO2orKyluZXRpbmRleFtqXT1pO3ByZXZpb3VzY29sPXNtYWxsdmFsO3N0YXJ0cG9zPWl9fW5ldGluZGV4W3ByZXZpb3VzY29sXT1zdGFydHBvcyttYXhuZXRwb3M+PjE7Zm9yKGo9cHJldmlvdXNjb2wrMTtqPDI1NjtqKyspbmV0aW5kZXhbal09bWF4bmV0cG9zfWZ1bmN0aW9uIGlueHNlYXJjaChiLGcscil7dmFyIGEscCxkaXN0O3ZhciBiZXN0ZD0xZTM7dmFyIGJlc3Q9LTE7dmFyIGk9bmV0aW5kZXhbZ107dmFyIGo9aS0xO3doaWxlKGk8bmV0c2l6ZXx8aj49MCl7aWYoaTxuZXRzaXplKXtwPW5ldHdvcmtbaV07ZGlzdD1wWzFdLWc7aWYoZGlzdD49YmVzdGQpaT1uZXRzaXplO2Vsc2V7aSsrO2lmKGRpc3Q8MClkaXN0PS1kaXN0O2E9cFswXS1iO2lmKGE8MClhPS1hO2Rpc3QrPWE7aWYoZGlzdDxiZXN0ZCl7YT1wWzJdLXI7aWYoYTwwKWE9LWE7ZGlzdCs9YTtpZihkaXN0PGJlc3RkKXtiZXN0ZD1kaXN0O2Jlc3Q9cFszXX19fX1pZihqPj0wKXtwPW5ldHdvcmtbal07ZGlzdD1nLXBbMV07aWYoZGlzdD49YmVzdGQpaj0tMTtlbHNle2otLTtpZihkaXN0PDApZGlzdD0tZGlzdDthPXBbMF0tYjtpZihhPDApYT0tYTtkaXN0Kz1hO2lmKGRpc3Q8YmVzdGQpe2E9cFsyXS1yO2lmKGE8MClhPS1hO2Rpc3QrPWE7aWYoZGlzdDxiZXN0ZCl7YmVzdGQ9ZGlzdDtiZXN0PXBbM119fX19fXJldHVybiBiZXN0fWZ1bmN0aW9uIGxlYXJuKCl7dmFyIGk7dmFyIGxlbmd0aGNvdW50PXBpeGVscy5sZW5ndGg7dmFyIGFscGhhZGVjPTMwKyhzYW1wbGVmYWMtMSkvMzt2YXIgc2FtcGxlcGl4ZWxzPWxlbmd0aGNvdW50LygzKnNhbXBsZWZhYyk7dmFyIGRlbHRhPX5+KHNhbXBsZXBpeGVscy9uY3ljbGVzKTt2YXIgYWxwaGE9aW5pdGFscGhhO3ZhciByYWRpdXM9aW5pdHJhZGl1czt2YXIgcmFkPXJhZGl1cz4+cmFkaXVzYmlhc3NoaWZ0O2lmKHJhZDw9MSlyYWQ9MDtmb3IoaT0wO2k8cmFkO2krKylyYWRwb3dlcltpXT1hbHBoYSooKHJhZCpyYWQtaSppKSpyYWRiaWFzLyhyYWQqcmFkKSk7dmFyIHN0ZXA7aWYobGVuZ3RoY291bnQ8bWlucGljdHVyZWJ5dGVzKXtzYW1wbGVmYWM9MTtzdGVwPTN9ZWxzZSBpZihsZW5ndGhjb3VudCVwcmltZTEhPT0wKXtzdGVwPTMqcHJpbWUxfWVsc2UgaWYobGVuZ3RoY291bnQlcHJpbWUyIT09MCl7c3RlcD0zKnByaW1lMn1lbHNlIGlmKGxlbmd0aGNvdW50JXByaW1lMyE9PTApe3N0ZXA9MypwcmltZTN9ZWxzZXtzdGVwPTMqcHJpbWU0fXZhciBiLGcscixqO3ZhciBwaXg9MDtpPTA7d2hpbGUoaTxzYW1wbGVwaXhlbHMpe2I9KHBpeGVsc1twaXhdJjI1NSk8PG5ldGJpYXNzaGlmdDtnPShwaXhlbHNbcGl4KzFdJjI1NSk8PG5ldGJpYXNzaGlmdDtyPShwaXhlbHNbcGl4KzJdJjI1NSk8PG5ldGJpYXNzaGlmdDtqPWNvbnRlc3QoYixnLHIpO2FsdGVyc2luZ2xlKGFscGhhLGosYixnLHIpO2lmKHJhZCE9PTApYWx0ZXJuZWlnaChyYWQsaixiLGcscik7cGl4Kz1zdGVwO2lmKHBpeD49bGVuZ3RoY291bnQpcGl4LT1sZW5ndGhjb3VudDtpKys7aWYoZGVsdGE9PT0wKWRlbHRhPTE7aWYoaSVkZWx0YT09PTApe2FscGhhLT1hbHBoYS9hbHBoYWRlYztyYWRpdXMtPXJhZGl1cy9yYWRpdXNkZWM7cmFkPXJhZGl1cz4+cmFkaXVzYmlhc3NoaWZ0O2lmKHJhZDw9MSlyYWQ9MDtmb3Ioaj0wO2o8cmFkO2orKylyYWRwb3dlcltqXT1hbHBoYSooKHJhZCpyYWQtaipqKSpyYWRiaWFzLyhyYWQqcmFkKSl9fX1mdW5jdGlvbiBidWlsZENvbG9ybWFwKCl7aW5pdCgpO2xlYXJuKCk7dW5iaWFzbmV0KCk7aW54YnVpbGQoKX10aGlzLmJ1aWxkQ29sb3JtYXA9YnVpbGRDb2xvcm1hcDtmdW5jdGlvbiBnZXRDb2xvcm1hcCgpe3ZhciBtYXA9W107dmFyIGluZGV4PVtdO2Zvcih2YXIgaT0wO2k8bmV0c2l6ZTtpKyspaW5kZXhbbmV0d29ya1tpXVszXV09aTt2YXIgaz0wO2Zvcih2YXIgbD0wO2w8bmV0c2l6ZTtsKyspe3ZhciBqPWluZGV4W2xdO21hcFtrKytdPW5ldHdvcmtbal1bMF07bWFwW2srK109bmV0d29ya1tqXVsxXTttYXBbaysrXT1uZXR3b3JrW2pdWzJdfXJldHVybiBtYXB9dGhpcy5nZXRDb2xvcm1hcD1nZXRDb2xvcm1hcDt0aGlzLmxvb2t1cFJHQj1pbnhzZWFyY2h9bW9kdWxlLmV4cG9ydHM9TmV1UXVhbnR9LHt9XSw0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXt2YXIgR0lGRW5jb2RlcixyZW5kZXJGcmFtZTtHSUZFbmNvZGVyPXJlcXVpcmUoIi4vR0lGRW5jb2Rlci5qcyIpO3JlbmRlckZyYW1lPWZ1bmN0aW9uKGZyYW1lKXt2YXIgZW5jb2RlcixwYWdlLHN0cmVhbSx0cmFuc2ZlcjtlbmNvZGVyPW5ldyBHSUZFbmNvZGVyKGZyYW1lLndpZHRoLGZyYW1lLmhlaWdodCk7aWYoZnJhbWUuaW5kZXg9PT0wKXtlbmNvZGVyLndyaXRlSGVhZGVyKCl9ZWxzZXtlbmNvZGVyLmZpcnN0RnJhbWU9ZmFsc2V9ZW5jb2Rlci5zZXRUcmFuc3BhcmVudChmcmFtZS50cmFuc3BhcmVudCk7ZW5jb2Rlci5zZXREaXNwb3NlKGZyYW1lLmRpc3Bvc2UpO2VuY29kZXIuc2V0UmVwZWF0KGZyYW1lLnJlcGVhdCk7ZW5jb2Rlci5zZXREZWxheShmcmFtZS5kZWxheSk7ZW5jb2Rlci5zZXRRdWFsaXR5KGZyYW1lLnF1YWxpdHkpO2VuY29kZXIuc2V0RGl0aGVyKGZyYW1lLmRpdGhlcik7ZW5jb2Rlci5zZXRHbG9iYWxQYWxldHRlKGZyYW1lLmdsb2JhbFBhbGV0dGUpO2VuY29kZXIuYWRkRnJhbWUoZnJhbWUuZGF0YSk7aWYoZnJhbWUubGFzdCl7ZW5jb2Rlci5maW5pc2goKX1pZihmcmFtZS5nbG9iYWxQYWxldHRlPT09dHJ1ZSl7ZnJhbWUuZ2xvYmFsUGFsZXR0ZT1lbmNvZGVyLmdldEdsb2JhbFBhbGV0dGUoKX1zdHJlYW09ZW5jb2Rlci5zdHJlYW0oKTtmcmFtZS5kYXRhPXN0cmVhbS5wYWdlcztmcmFtZS5jdXJzb3I9c3RyZWFtLmN1cnNvcjtmcmFtZS5wYWdlU2l6ZT1zdHJlYW0uY29uc3RydWN0b3IucGFnZVNpemU7aWYoZnJhbWUuY2FuVHJhbnNmZXIpe3RyYW5zZmVyPWZ1bmN0aW9uKCl7dmFyIGksbGVuLHJlZixyZXN1bHRzO3JlZj1mcmFtZS5kYXRhO3Jlc3VsdHM9W107Zm9yKGk9MCxsZW49cmVmLmxlbmd0aDtpPGxlbjtpKyspe3BhZ2U9cmVmW2ldO3Jlc3VsdHMucHVzaChwYWdlLmJ1ZmZlcil9cmV0dXJuIHJlc3VsdHN9KCk7cmV0dXJuIHNlbGYucG9zdE1lc3NhZ2UoZnJhbWUsdHJhbnNmZXIpfWVsc2V7cmV0dXJuIHNlbGYucG9zdE1lc3NhZ2UoZnJhbWUpfX07c2VsZi5vbm1lc3NhZ2U9ZnVuY3Rpb24oZXZlbnQpe3JldHVybiByZW5kZXJGcmFtZShldmVudC5kYXRhKX19LHsiLi9HSUZFbmNvZGVyLmpzIjoxfV19LHt9LFs0XSk7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPWdpZi53b3JrZXIuanMubWFwCg==";
  </script>
  <script>
    const STRETCH_X_BASE64 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAgklEQVR42u2XQQrAIAwEk5/lZ/o1X6ZWL6VQTKjt9rBLDh426yARVAUs9ZhqL3V6oz1LQx01jGEAT596Qp4ArHrVE7BDdxD/PYFrEGQGzmGwW/C28AA5563THlHfewKklD7fvJQiZkYAAhCAAAQgAAEIMAGOBUIDQDZ/QKLCP0rRAA1CepoN3cqHGgAAAABJRU5ErkJggg==";
    const STRETCH_Y_BASE64 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAhUlEQVR42u3WbQqAIAwG4O1m3mxezZOpRcUQCdHUQe+LUKC154dfTDne+0gfJf/reHDreL4BIjJcPIRAzjkAALALyEstctG3DBDP9hRl9T4foIuXiOmAWnGN+M8cAAAAAAAAYBvAxGG09TiuIZZfSDRi6ySsBQA7gOvD4XQB6GWz6EwzIAHDV/wh5oNISwAAAABJRU5ErkJggg==";
    const SKEW_X_BASE64 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAs0lEQVR42u2W2w2AIAxF7WZsBqsxmQJR4wsppaWa0BB/6O05MRKBSblgCGCa5rCgUhabKTbMaaXGagFMDjBDWgRKWcAM4KicxHffwHWQyjdwHKZ2CqRrCDQJOOeajmrI0wUi3FpLhnvvJ2MMTYALHgqqBTjh+0MLXiUgAUcLSMFRApLwooA0/HWjBzy72Qv+2NATfmvqDT81asD3Zi14CkT4GiYXFb6FOK7f5N/6v29EHLUAj92FHx4pJQ0AAAAASUVORK5CYII=";
    const SKEW_Y_BASE64 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAxElEQVR42u3XQQrEIAxAUb2ZN9OreTLHzDAlFE1i0tiN0kI38h9Fqo3BOEoprd/wGDXzVZNwPKUU4N4OgHjOOdRa9wP+cRjbATguAbR+RaKzBLjHOUD7Xldo2BIDRnEKgOMUQgSYxWeAUXyGYAFUnHoDGKNeA1zcFSCJuwGk8QM4gAM4gNcBKzshCvKb0VN7ABdXA6THMPWBZHX/5xCPrQHrAdQE8IiLAV5xEcAzzgK84yTA+s9nBlj+eM2A8PuAuMdhfAAPD/YhFyzU6gAAAABJRU5ErkJggg==";
  </script>
  <script>
    const ABOUT_PAINT_LOGO_32_BASE64 = "data:image/png;base64,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";
  </script>
  <script>
    // expresses order in the URL as well as type
    const param_types = {
      // settings
      "eye-gaze-mode": "bool",
      "vertical-color-box-mode": "bool",
      "speech-recognition-mode": "bool",
      // sessions
      "local": "string",
      "session": "string",
      "load": "string",
    };

    const exclusive_params = [
      "local",
      "session",
      "load",
    ];

    function get_all_url_params() {
      const params = {};
      location.hash.replace(/^#/, "").split(/,/).forEach((param_decl) => {
        // colon is used in param value for URLs so split(":") isn't good enough
        const colon_index = param_decl.indexOf(":");
        if (colon_index === -1) {
          // boolean value, implicitly true because it's in the URL
          const param_name = param_decl;
          params[param_name] = true;
        } else {
          const param_name = param_decl.slice(0, colon_index);
          const param_value = param_decl.slice(colon_index + 1);
          params[param_name] = decodeURIComponent(param_value);
        }
      });
      for (const [param_name, param_type] of Object.entries(param_types)) {
        if (param_type === "bool" && !params[param_name]) {
          params[param_name] = false;
        }
      }
      return params;
    }

    function get_url_param(param_name) {
      return get_all_url_params()[param_name];
    }

    function change_url_param(param_name, value, {
      replace_history_state = false
    } = {}) {
      change_some_url_params({
        [param_name]: value
      }, {
        replace_history_state
      });
    }

    function change_some_url_params(updates, {
      replace_history_state = false
    } = {}) {
      for (const exclusive_param of exclusive_params) {
        if (updates[exclusive_param]) {
          exclusive_params.forEach((param) => {
            if (param !== exclusive_param) {
              updates[param] = null; // must be enumerated (for Object.assign) but falsey, to get removed from the URL
            }
          });
        }
      }
      set_all_url_params(Object.assign({}, get_all_url_params(), updates), {
        replace_history_state
      });
    }

    function set_all_url_params(params, {
      replace_history_state = false
    } = {}) {

      let new_hash = "";
      for (const [param_name, param_type] of Object.entries(param_types)) {
        if (params[param_name]) {
          if (new_hash.length) {
            new_hash += ",";
          }
          new_hash += encodeURIComponent(param_name);
          if (param_type !== "bool") {
            new_hash += ":" + encodeURIComponent(params[param_name]);
          }
        }
      }
      // Note: gets rid of query string (?) portion of the URL
      // This is desired for upgrading backwards compatibility URLs;
      // may not be desired for future cases.
      const new_url = `${location.origin}${location.pathname}#${new_hash}`;
      if (replace_history_state) {
        history.replaceState(null, document.title, new_url);
      } else {
        history.pushState(null, document.title, new_url);
      }

      $G.triggerHandler("change-url-params");
    }

    function update_magnified_canvas_size() {
      $canvas.css("width", canvas.width * magnification);
      $canvas.css("height", canvas.height * magnification);

      update_canvas_rect();
    }

    function update_canvas_rect() {
      canvas_bounding_client_rect = canvas.getBoundingClientRect();

      update_helper_layer();
    }

    let helper_layer_update_queued;
    let info_for_updating_pointer; // for updating on scroll or resize, where the mouse stays in the same place but its coordinates in the document change
    function update_helper_layer(e) {
      // e may be a number from requestAnimationFrame callback; ignore that
      if (e && isFinite(e.clientX)) {
        info_for_updating_pointer = {
          clientX: e.clientX,
          clientY: e.clientY,
          devicePixelRatio
        };
      }
      if (helper_layer_update_queued) {
        // window.console && console.log("update_helper_layer - nah, already queued");
        return;
      } else {
        // window.console && console.log("update_helper_layer");
      }
      helper_layer_update_queued = true;
      requestAnimationFrame(() => {
        helper_layer_update_queued = false;
        update_helper_layer_immediately();
      });
    }

    function update_helper_layer_immediately() {
      // window.console && console.log("Update helper layer NOW");
      if (info_for_updating_pointer) {
        const rescale = info_for_updating_pointer.devicePixelRatio / devicePixelRatio;
        info_for_updating_pointer.clientX *= rescale;
        info_for_updating_pointer.clientY *= rescale;
        info_for_updating_pointer.devicePixelRatio = devicePixelRatio;
        pointer = to_canvas_coords(info_for_updating_pointer);
      }

      update_fill_and_stroke_colors_and_lineWidth(selected_tool);

      const grid_visible = show_grid && magnification >= 4 && (window.devicePixelRatio * magnification) >= 4;

      const scale = magnification * window.devicePixelRatio;

      if (!helper_layer) {
        helper_layer = new OnCanvasHelperLayer(0, 0, canvas.width, canvas.height, false, scale);
      }

      const hcanvas = helper_layer.canvas;
      const hctx = hcanvas.ctx;

      const margin = 15;
      const viewport_x = Math.floor(Math.max($canvas_area.scrollLeft() / magnification - margin, 0));
      const viewport_y = Math.floor(Math.max($canvas_area.scrollTop() / magnification - margin, 0));
      const viewport_x2 = Math.floor(Math.min(viewport_x + $canvas_area.width() / magnification + margin * 2, canvas.width));
      const viewport_y2 = Math.floor(Math.min(viewport_y + $canvas_area.height() / magnification + margin * 2, canvas.height));
      const viewport_width = viewport_x2 - viewport_x;
      const viewport_height = viewport_y2 - viewport_y;
      const resolution_width = viewport_width * scale;
      const resolution_height = viewport_height * scale;
      if (
        hcanvas.width !== resolution_width ||
        hcanvas.height !== resolution_height
      ) {
        hcanvas.width = resolution_width;
        hcanvas.height = resolution_height;
        hcanvas.ctx.disable_image_smoothing();
        helper_layer.width = viewport_width;
        helper_layer.height = viewport_height;
      }
      helper_layer.x = viewport_x;
      helper_layer.y = viewport_y;
      helper_layer.position();

      hctx.clearRect(0, 0, hcanvas.width, hcanvas.height);

      var tools_to_preview = [...selected_tools];
      // the select box previews draw the document canvas onto the preview canvas
      // so they have something to invert within the preview canvas
      // but this means they block out anything earlier
      // NOTE: sort Select after Free-Form Select,
      // Brush after Eraser, as they are from the toolbar ordering
      tools_to_preview.sort((a, b) => {
        if (a.selectBox && !b.selectBox) {
          return -1;
        }
        if (!a.selectBox && b.selectBox) {
          return 1;
        }
        return 0;
      });
      // two select box previews would just invert and cancel each other out
      // so only render one if there's one or more
      var select_box_index = tools_to_preview.findIndex((tool) => tool.selectBox);
      if (select_box_index >= 0) {
        tools_to_preview = tools_to_preview.filter((tool, index) => !tool.selectBox || index == select_box_index);
      }

      tools_to_preview.forEach((tool) => {
        if (tool.drawPreviewUnderGrid && pointer && pointers.length < 2) {
          hctx.save();
          tool.drawPreviewUnderGrid(hctx, pointer.x, pointer.y, grid_visible, scale, -viewport_x, -viewport_y);
          hctx.restore();
        }
      });

      if (selection) {
        hctx.save();

        hctx.scale(scale, scale);
        hctx.translate(-viewport_x, -viewport_y);

        hctx.drawImage(selection.canvas, selection.x, selection.y);

        hctx.restore();
      }

      if (textbox) {
        hctx.save();

        hctx.scale(scale, scale);
        hctx.translate(-viewport_x, -viewport_y);

        hctx.drawImage(textbox.canvas, textbox.x, textbox.y);

        hctx.restore();
      }

      if (grid_visible) {
        draw_grid(hctx, scale);
      }

      tools_to_preview.forEach((tool) => {
        if (tool.drawPreviewAboveGrid && pointer && pointers.length < 2) {
          hctx.save();
          tool.drawPreviewAboveGrid(hctx, pointer.x, pointer.y, grid_visible, scale, -viewport_x, -viewport_y);
          hctx.restore();
        }
      });
    }

    function update_disable_aa() {
      const dots_per_canvas_px = window.devicePixelRatio * magnification;
      const round = Math.floor(dots_per_canvas_px) === dots_per_canvas_px;
      $canvas_area.toggleClass("disable-aa-for-things-at-main-canvas-scale", dots_per_canvas_px >= 3 || round);
    }

    function set_magnification(scale) {
      const prev_magnification = magnification;
      let scroll_left = $canvas_area.scrollLeft();
      let scroll_top = $canvas_area.scrollTop();

      magnification = scale;
      if (scale !== 1) {
        return_to_magnification = scale;
      }
      update_magnified_canvas_size();

      // rescale viewport with top left as anchor
      scroll_left *= magnification / prev_magnification;
      scroll_top *= magnification / prev_magnification;

      $canvas_area.scrollLeft(scroll_left);
      $canvas_area.scrollTop(scroll_top);

      $G.triggerHandler("resize"); // updates handles & grid
      $G.trigger("option-changed"); // updates options area
    }

    let $custom_zoom_window;

    function show_custom_zoom_window() {
      if ($custom_zoom_window) {
        $custom_zoom_window.close();
      }
      const $w = new $FormToolWindow("Custom Zoom");
      $custom_zoom_window = $w;

      // @TODO: show Current zoom: blah% ?
      const $fieldset = $(E("fieldset"))
        .addClass("xp-groupbox")
        .attr("style", "background-color: #ece9d8;")
        .appendTo($w.$main);

      $fieldset.append("<legend>Zoom to</legend>");
      $fieldset.append("<label><input type='radio' name='custom-zoom-radio' value='1'/>100%</label>");
      $fieldset.append("<label><input type='radio' name='custom-zoom-radio' value='2'/>200%</label>");
      $fieldset.append("<label><input type='radio' name='custom-zoom-radio' value='4'/>400%</label>");
      $fieldset.append("<label><input type='radio' name='custom-zoom-radio' value='6'/>600%</label>");
      $fieldset.append("<label><input type='radio' name='custom-zoom-radio' value='8'/>800%</label>");
      $fieldset.append("<label><input type='radio' name='custom-zoom-radio' value='really-custom'/><input type='number' min='10' max='1000' name='really-custom-zoom-input' value=''/>%</label>");
      let is_custom = true;
      $fieldset.find("input[type=radio]").get().forEach((el) => {
        if (parseFloat(el.value) === magnification) {
          el.checked = true;
          is_custom = false;
        }
      });
      const $really_custom_radio_option = $fieldset.find("input[value='really-custom']");
      const $really_custom_input = $fieldset.find("input[name='really-custom-zoom-input']");

      $really_custom_input.closest("label").on("click", () => {
        $really_custom_radio_option.prop("checked", true);
        $really_custom_input[0].focus();
      });

      if (is_custom) {
        $really_custom_input.val(magnification * 100);
        $really_custom_radio_option.prop("checked", true);
      }

      $fieldset.find("label").css({
        display: "block"
      });

      $w.$Button("OK", () => {
        let option_val = $fieldset.find("input[name='custom-zoom-radio']:checked").val();
        let mag;
        if (option_val === "really-custom") {
          option_val = $really_custom_input.val();
          if (`${option_val}`.match(/\dx$/)) { // ...you can't actually type an x; oh well...
            mag = parseFloat(option_val);
          } else if (`${option_val}`.match(/\d%?$/)) {
            mag = parseFloat(option_val) / 100;
          }
          if (isNaN(mag)) {
            const $msgw = new $FormToolWindow("Invalid Value").addClass("dialogue-window");
            $msgw.$main.text("The value specified for custom zoom was invalid.");
            $msgw.$Button("OK", () => {
              $msgw.close();
            });
            return;
          }
        } else {
          mag = parseFloat(option_val);
        }

        set_magnification(mag);

        $w.close();
      })[0].focus();
      $w.$Button("Cancel", () => {
        $w.close();
      });

      $w.center();
    }

    function toggle_grid() {
      show_grid = !show_grid;
      // $G.trigger("option-changed");
      update_helper_layer();
    }

    function reset_colors() {
      colors = {
        foreground: "#000000",
        background: "#ffffff",
        ternary: "",
      };
      $G.trigger("option-changed");
    }

    function reset_file() {
      document_file_path = null;
      file_name = "untitled";
      update_title();
      saved = true;
    }

    function reset_canvas_and_history() {
      undos.length = 0;
      redos.length = 0;
      current_history_node = root_history_node = make_history_node({
        name: "New Document",
        icon: get_help_folder_icon("p_blank.png"),
      });
      history_node_to_cancel_to = null;

      canvas.width = Math.max(1, my_canvas_width);
      canvas.height = Math.max(1, my_canvas_height);
      ctx.disable_image_smoothing();
      ctx.fillStyle = colors.background;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      current_history_node.image_data = ctx.getImageData(0, 0, canvas.width, canvas.height);

      $canvas_area.trigger("resize");
      $G.triggerHandler("history-update"); // update history view
    }

    function make_history_node({
      parent = null,
      futures = [],
      timestamp = Date.now(),
      soft = false,
      image_data = null,
      selection_image_data = null,
      selection_x,
      selection_y,
      textbox_text,
      textbox_x,
      textbox_y,
      textbox_width,
      textbox_height,
      text_tool_font = null,
      tool_transparent_mode,
      foreground_color,
      background_color,
      ternary_color,
      name,
      icon = null,
    }) {
      return {
        parent,
        futures,
        timestamp,
        soft,
        image_data,
        selection_image_data,
        selection_x,
        selection_y,
        textbox_text,
        textbox_x,
        textbox_y,
        textbox_width,
        textbox_height,
        text_tool_font,
        tool_transparent_mode,
        foreground_color,
        background_color,
        ternary_color,
        name,
        icon,
      };
    }

    function update_title() {
      document.title = `${file_name} - Paint`;
    }

    function create_and_trigger_input(attrs, callback) {
      const $input = $(E("input")).attr(attrs)
        .on("change", () => {
          callback($input[0]);
          $input.remove();
        })
        .appendTo($app)
        .hide()
        .trigger("click");
      return $input;
    }

    // @TODO: rename these functions to lowercase (and maybe say "files" in this case)
    function get_FileList_from_file_select_dialog(callback) {
      // @TODO: specify mime types?
      create_and_trigger_input({
        type: "file"
      }, input => {
        callback(input.files);
      });
    }

    function open_from_Image(img, callback, canceled) {
      are_you_sure(() => {
        // @TODO: shouldn't open_from_* start a new session?

        deselect();
        cancel();
        saved = false;

        reset_file();
        reset_colors();
        reset_canvas_and_history(); // (with newly reset colors)
        set_magnification(default_magnification);

        ctx.copy(img);
        detect_transparency();
        $canvas_area.trigger("resize");

        current_history_node.name = "Load Document";
        current_history_node.image_data = ctx.getImageData(0, 0, canvas.width, canvas.height);
        current_history_node.icon = null; // @TODO

        $G.triggerHandler("session-update"); // autosave
        $G.triggerHandler("history-update"); // update history view

        callback && callback();
      }, canceled);
    }

    function get_URIs(text) {
      // parse text/uri-list
      // get lines, discarding comments
      const lines = text.split(/[\n\r]+/).filter(line => line[0] !== "#" && line);
      // discard text with too many lines (likely pasted HTML or something) - may want to revisit this
      if (lines.length > 15) {
        return [];
      }
      // parse URLs, discarding anything that parses as a relative URL
      const uris = [];
      for (let i = 0; i < lines.length; i++) {
        try {
          const url = new URL(lines[i]);
          uris.push(url.href);
          // eslint-disable-next-line no-empty
        } catch (e) {}
      }
      return uris;
    }

    function load_image_from_URI(uri, callback) {
      const is_blob_uri = uri.match(/^blob:/);
      const is_download = !uri.match(/^(blob|data):/);

      if (is_blob_uri && uri.indexOf(`blob:${location.origin}`) === -1) {
        const error = new Error("can't load blob: URI from another domain");
        error.code = "cors-blob-uri";
        callback(error);
        return;
      }

      const uris_to_try = is_download ? [
        uri,
        // work around CORS headers not sent by whatever server
        `https://jspaint-cors-proxy.herokuapp.com/${uri}`,
        // if the image isn't available on the live web, see if it's archived
        `https://web.archive.org/${uri}`,
      ] : [uri];

      let index = 0;
      const try_next_uri = () => {
        const uri_to_try = uris_to_try[index];
        if (is_download) {
          $status_text.text("Downloading picture...");
        }

        const handle_fetch_fail = () => {
          index += 1;
          if (index >= uris_to_try.length) {
            if (is_download) {
              $status_text.text("Failed to download picture.");
            }
            callback && callback(new Error(`failed to download image from any of three URIs (${JSON.stringify(uris_to_try)}).`));
          } else {
            try_next_uri();
          }
        };
        const show_progress = ({
          loaded,
          total
        }) => {
          if (is_download) {
            $status_text.text(`Downloading picture... (${Math.round(loaded/total*100)}%)`);
          }
        };

        if (is_download) {
          console.log(`Try loading image from URI (${index + 1}/${uris_to_try.length}): "${uri_to_try}"`);
        }
        fetch(uri_to_try)
          .then(response => {
            if (!response.ok) {
              throw Error(`${response.status} ${response.statusText}`);
            }
            if (!response.body) {
              if (is_download) {
                console.log("ReadableStream not yet supported in this browser. Progress won't be shown for image requests.");
              }
              return response;
            }

            // to access headers, server must send CORS header "Access-Control-Expose-Headers: content-encoding, content-length x-file-size"
            // server must send custom x-file-size header if gzip or other content-encoding is used
            const contentEncoding = response.headers.get("content-encoding");
            const contentLength = response.headers.get(contentEncoding ? "x-file-size" : "content-length");
            if (contentLength === null) {
              if (is_download) {
                console.log("Response size header unavailable. Progress won't be shown for this image request.");
              }
              return response;
            }

            const total = parseInt(contentLength, 10);
            let loaded = 0;

            return new Response(
              new ReadableStream({
                start(controller) {
                  const reader = response.body.getReader();

                  read();

                  function read() {
                    reader.read().then(({
                      done,
                      value
                    }) => {
                      if (done) {
                        controller.close();
                        return;
                      }
                      loaded += value.byteLength;
                      show_progress({
                        loaded,
                        total
                      })
                      controller.enqueue(value);
                      read();
                    }).catch(error => {
                      console.error(error);
                      controller.error(error)
                    })
                  }
                }
              })
            );
          })
          .then(response => response.blob())
          .then(blob => {
            if (is_download) {
              console.log("Download complete.");
              $status_text.text("Download complete.");
            }
            const img = new Image();
            img.crossOrigin = "Anonymous";
            const handle_decode_fail = () => {
              // @TODO: use headers to detect HTML instead, since a doctype is not guaranteed
              // @TODO: fall back to WayBack Machine still for decode errors,
              // since a website might start redirecting swathes of URLs regardless of what they originally pointed to,
              // at which point they would likely point to a web page instead of an image.
              // (But still show an error about it not being an image, if WayBack also fails.)
              var fr = new FileReader();
              fr.onerror = () => {
                const error = new Error("failed to decode blob as image or text");
                error.code = "decode-fail";
                callback(error);
              };
              fr.onload = (e) => {
                const error = new Error("failed to decode blob as an image");
                error.code = e.target.result.match(/^\s*<!doctype\s+html/i) ? "html-not-image" : "decode-fail";
                callback(error);
              };
              fr.readAsText(blob);
            };
            img.onload = () => {
              if (!img.complete || typeof img.naturalWidth == "undefined" || img.naturalWidth === 0) {
                handle_decode_fail();
                return;
              }
              callback(null, img);
            };
            img.onerror = handle_decode_fail;
            img.src = window.URL.createObjectURL(blob);
          })
          .catch(handle_fetch_fail);
      };
      try_next_uri();
    }

    function open_from_URI(uri, callback, canceled) {
      load_image_from_URI(uri, (error, img) => {
        if (error) {
          return callback(error);
        }
        open_from_Image(img, callback, canceled);
      });
    }

    function open_from_File(file, callback, canceled) {
      const blob_url = URL.createObjectURL(file);
      load_image_from_URI(blob_url, (error, img) => {
        // revoke object URL regardless of error
        URL.revokeObjectURL(file);
        if (error) {
          return callback(error);
        }

        open_from_Image(img, () => {
          file_name = file.name;
          document_file_path = file.path; // available in Electron
          update_title();
          saved = true;
          callback();
        }, canceled);
      });
    }

    function open_from_FileList(files, user_input_method_verb_past_tense) {
      for (const file of files) {
        if (file.type.match(/^image/)) {
          open_from_File(file, err => {
            if (err) {
              return show_error_message("Failed to open file:", err);
            }
          });
          return;
        } else if (file.name.match(/\.theme(pack)?$/i)) {
          loadThemeFile(file);
          return;
        }
      }
      if (files.length > 1) {
        show_error_message(`None of the files ${user_input_method_verb_past_tense} appear to be images.`);
      } else {
        show_error_message(`File ${user_input_method_verb_past_tense} does not appear to be an image.`);
      }
    }

    function loadThemeFile(file) {
      var reader = new FileReader();
      reader.onload = () => {
        loadThemeFromText(reader.result);
      };
      reader.readAsText(file);
    }

    function loadThemeFromText(fileText) {
      var cssProperties = parseThemeFileString(fileText);
      applyCSSProperties(cssProperties);

      window.themeCSSProperties = cssProperties;
      $("iframe").each((i, iframe) => {
        try {
          applyCSSProperties(cssProperties, iframe.contentDocument.documentElement);
        } catch (error) {
          console.log("error applying theme to iframe", iframe, error);
        }
      })

      $G.triggerHandler("theme-load");
    }

    function file_new() {
      are_you_sure(() => {
        deselect();
        cancel();
        saved = false;

        reset_file();
        reset_colors();
        reset_canvas_and_history(); // (with newly reset colors)
        set_magnification(default_magnification);

        $G.triggerHandler("session-update"); // autosave
      });
    }

    // @TODO: factor out open_select/choose_file_dialog or get_file_from_file_select_dialog or whatever
    // all these open_from_* things are done backwards, basically
    // there's this little thing called Inversion of Control...
    // also paste_from_file_select_dialog
    function file_open() {
      get_FileList_from_file_select_dialog(files => {
        open_from_FileList(files, "selected");
      });
    }

    function file_save() {
      deselect();
      if (file_name.match(/\.svg$/)) {
        // @TODO: only affect suggested name in save dialog, don't change file_name
        file_name = `${file_name.replace(/\.svg$/, "")}.png`;
        return file_save_as();
      }
      if (document_file_path) {
        // @TODO: save as JPEG by default if the previously opened/saved file was a JPEG?
        return save_to_file_path(document_file_path, "PNG", (saved_file_path, saved_file_name) => {
          saved = true;
          document_file_path = saved_file_path;
          file_name = saved_file_name;
          update_title();
        });
      }
      file_save_as();
    }

    function file_save_as() {
      deselect();
      save_canvas_as(canvas, `${file_name.replace(/\.(bmp|dib|a?png|gif|jpe?g|jpe|jfif|tiff?|webp|raw)$/, "")}.png`, (saved_file_path, saved_file_name) => {
        saved = true;
        document_file_path = saved_file_path;
        file_name = saved_file_name;
        update_title();
      });
    }


    function are_you_sure(action, canceled) {
      if (saved) {
        action();
      } else {
        const $w = new $FormToolWindow().addClass("dialogue-window");
        $w.title("Paint");
        $w.$main.text(`Save changes to ${file_name}?`);
        $w.$Button("Save", () => {
          $w.close();
          file_save();
          action();
        })[0].focus();
        $w.$Button("Discard", () => {
          $w.close();
          action();
        });
        $w.$Button("Cancel", () => {
          $w.close();
          canceled && canceled();
        });
        $w.$x.on("click", () => {
          canceled && canceled();
        });
        $w.center();
      }
    }

    function show_error_message(message, error) {
      const $w = $FormToolWindow().title("Error").addClass("dialogue-window");
      $w.$main.text(message);
      $w.$main.css("max-width", "600px");
      if (error) {
        $(E("pre"))
          .appendTo($w.$main)
          .text(error.stack || error.toString())
          .css({
            background: "white",
            color: "#333",
            // background: "#A00",
            // color: "white",
            fontFamily: "monospace",
            width: "500px",
            overflow: "auto",
          });
      }
      $w.$Button("OK", () => {
        $w.close();
      });
      $w.center();
      if (error) {
        window.console && console.error(message, error);
      } else {
        window.console && console.error(message);
      }
    }

    // @TODO: close are_you_sure windows and these Error windows when switching sessions
    // because it can get pretty confusing
    function show_resource_load_error_message(error) {
      const $w = $FormToolWindow().title("Error").addClass("dialogue-window");
      const firefox = navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
      if (error.code === "cors-blob-uri") {
        $w.$main.html(`
			<p>Can't load image from address starting with "blob:".</p>
			${
				firefox ?
					`<p>Try "Copy Image" instead of "Copy Image Location".</p>` :
					`<p>Try "Copy image" instead of "Copy image address".</p>`
			}
		`);
      } else if (error.code === "html-not-image") {
        $w.$main.html(`
			<p>Address points to a web page, not an image file.</p>
			<p>Try copying and pasting an image instead of a URL.</p>
		`);
      } else if (error.code === "decode-fail") {
        $w.$main.html(`
			<p>Address doesn't point to an image file of a supported format.</p>
			<p>Try copying and pasting an image instead of a URL.</p>
		`);
      } else {
        $w.$main.html(`
			<p>Failed to load image from URL.</p>
			<p>Check your browser's devtools for details.</p>
		`);
      }
      $w.$main.css({
        maxWidth: "500px"
      });
      $w.$Button("OK", () => {
        $w.close();
      });
      $w.center();
    }

    let $about_paint_window;
    const $about_paint_content = $("#about-paint");

    function show_about_paint() {
      const $w = new $FormToolWindow("About XP Paint");

      let aboutWindowBody = `
	<div style="background-image: linear-gradient(to right, #6286e1, #9cb9f5, #6286e1); width: 100%; height: 48px;"></div>
	<div style="background-image: linear-gradient(to right, #627ed5, #f79638, #627ed5);  width: 100%; height: 4px"></div>

	<div style="display: flex; flex-direction: row; padding-top: 24px; padding-right: 16px">
		<div style="padding-left: 12px; padding-right: 12px">
			<img src="${ABOUT_PAINT_LOGO_32_BASE64}" width="32" height="32" id="paint-32x32" alt=""/>
		</div>
		<div>
			
			<div style="padding-bottom: 24px">
				<div>XP Paint</div>
				<div>Version 1.0.0 (Build 2020.07.01 : Service Pack 0)</div>
				<div>Copyright © 2020 Nobody</div>
			</div>

			<div style="padding-bottom: 24px">
				<div>This product is licensed under the terms of the same license JS Paint</div>
				<div>is licensed to:</div>
				<div style="padding-left: 16px">You</div>
			</div>
			
			<div>XP Paint is a fork of the web-based remake of MS Paint called JS Paint.</div>
			<div>Credits to <a href="https://github.com/assemblylanguage/">Assembly Language</a> for forking and converting JS Paint to XP Paint.</div>
			<div>Credits to <a href="https://isaiahodhner.io/">Isaiah Odhner</a> and contributors for creating <a href="https://jspaint.app">JS Paint</a>.</div>

			<br>
			<hr class="xp-hr">

			<p>Physical memory available to Windows: 1,337,000 KB</p>
		</div>
	</div>
	`;

      const $fieldset = $(E("div"))
        .appendTo($w.$main);

      $w.$content.attr("style", "margin: 0px; padding: 0px; padding-left: 3px; padding-right: 3px");

      $fieldset.append(aboutWindowBody);
    }
    // show_about_paint(); // for testing


    function update_css_classes_for_conditional_messages() {

      $(".on-dev-host, .on-third-party-host, .on-official-host").hide();
      if (location.hostname.match(/localhost|127.0.0.1/)) {
        $(".on-dev-host").show();
      } else if (location.hostname.match(/jspaint.app/)) {
        $(".on-official-host").show();
      } else {
        $(".on-third-party-host").show();
      }

      $(".navigator-online, .navigator-offline").hide();
      if (navigator.onLine) {
        $(".navigator-online").show();
      } else {
        $(".navigator-offline").show();
      }
    }



    // @TODO: DRY between these functions and open_from_* functions further?

    // function paste_image_from_URI(uri, callback){
    // 	load_image_from_URI(uri, (err, img)=> {
    // 		if(err){ return callback(err); }
    // 		paste(img);
    // 	});
    // };

    function paste_image_from_file(file) {
      const blob_url = URL.createObjectURL(file);
      // paste_image_from_URI(blob_url);
      load_image_from_URI(blob_url, (error, img) => {
        if (error) {
          return show_resource_load_error_message(error);
        }
        paste(img);
        URL.revokeObjectURL(blob_url);
      });
    }

    function paste_from_file_select_dialog() {
      get_FileList_from_file_select_dialog(files => {
        for (const file of files) {
          if (file.type.match(/^image/)) {
            paste_image_from_file(file);
            return;
          }
        }
        if (files.length > 1) {
          show_error_message(`None of the files selected appear to be images.`);
        } else {
          show_error_message(`File selected does not appear to be an image.`);
        }
      });
    }

    function paste(img) {

      if (img.width > canvas.width || img.height > canvas.height) {
        const $w = new $FormToolWindow().addClass("dialogue-window");
        $w.title("Paint");
        $w.$main.html(
          "The image is bigger than the canvas.<br>" +
          "Would you like the canvas to be enlarged?<br>"
        );
        $w.$Button("Enlarge", () => {
          $w.close();
          // The resize gets its own undoable, as in mspaint
          resize_canvas_and_save_dimensions(img.width, img.height, {
            name: "Enlarge Canvas For Paste",
            icon: get_help_folder_icon("p_stretch_both.png"),
          });
          do_the_paste();
          $canvas_area.trigger("resize");
        })[0].focus();
        $w.$Button("Crop", () => {
          $w.close();
          do_the_paste();
        });
        $w.$Button("Cancel", () => {
          $w.close();
        });
        $w.center();
      } else {
        do_the_paste();
      }

      function do_the_paste() {
        deselect();
        select_tool(get_tool_by_name("Select"));
        const x = Math.max(0, Math.ceil($canvas_area.scrollLeft() / magnification));
        const y = Math.max(0, Math.ceil($canvas_area.scrollTop() / magnification));

        undoable({
          name: "Paste",
          icon: get_help_folder_icon("p_paste.png"),
          soft: true,
        }, () => {
          selection = new OnCanvasSelection(x, y, img.width, img.height, img);
        });
      }
    }

    function render_history_as_gif() {
      const $win = $FormToolWindow();
      $win.title("Rendering GIF");
      $win.center();
      const $output = $win.$main;
      const $progress = $(E("progress")).appendTo($output);
      const $progress_percent = $(E("span")).appendTo($output).css({
        width: "2.3em",
        display: "inline-block",
        textAlign: "center",
      });
      $win.$main.css({
        padding: 5
      });

      const $cancel = $win.$Button('Cancel', () => {
        $win.close();
      });

      try {
        const width = canvas.width;
        const height = canvas.height;
        const gif = new GIF({
          //workers: Math.min(5, Math.floor(undos.length/50)+1),
          //workerScript: "lib/gif.js/gif.worker.js",
          workerScript: GIF_WORKER_SCRIPT_BASE64,
          width,
          height,
        });

        $win.on('close', () => {
          gif.abort();
        });

        gif.on("progress", p => {
          $progress.val(p);
          $progress_percent.text(`${~~(p*100)}%`);
        });

        gif.on("finished", blob => {
          $win.title("Rendered GIF");
          const url = URL.createObjectURL(blob);
          $output.empty().append(
            $(E("img")).attr({
              src: url,
              width,
              height,
            })
          );
          $win.$Button("Save", () => {
            $win.close();
            sanity_check_blob(blob, () => {
              saveAs(blob, `${file_name.replace(/\.(bmp|dib|a?png|gif|jpe?g|jpe|jfif|tiff?|webp|raw)$/, "")} history.gif`);
            });
          });
          $cancel.appendTo($win.$buttons);
          $win.center();
        });

        const gif_canvas = make_canvas(width, height);
        const frame_history_nodes = [...undos, current_history_node];
        for (const frame_history_node of frame_history_nodes) {
          gif_canvas.ctx.clearRect(0, 0, gif_canvas.width, gif_canvas.height);
          gif_canvas.ctx.putImageData(frame_history_node.image_data, 0, 0);
          if (frame_history_node.selection_image_data) {
            const selection_canvas = make_canvas(frame_history_node.selection_image_data);
            gif_canvas.ctx.drawImage(selection_canvas, frame_history_node.selection_x, frame_history_node.selection_y);
          }
          gif.addFrame(gif_canvas, {
            delay: 200,
            copy: true
          });
        }
        gif.render();

      } catch (err) {
        $win.close();
        show_error_message("Failed to render GIF:", err);
      }
    }

    function go_to_history_node(target_history_node, canceling) {
      const from_history_node = current_history_node;

      if (!target_history_node.image_data) {
        if (!canceling) {
          show_error_message("History entry has no image data.");
          window.console && console.log("Target history entry has no image data:", target_history_node);
        }
        return;
      }
      const current_image_data = ctx.getImageData(0, 0, canvas.width, canvas.height);
      if (!current_history_node.image_data || !image_data_match(current_history_node.image_data, current_image_data, 5)) {
        window.console && console.log("Canvas image data changed outside of undoable", current_history_node, "current_history_node.image_data:", current_history_node.image_data, "document's current image data:", current_image_data);
        undoable({
          name: "Unknown [GTHN]",
          use_loose_canvas_changes: true
        }, () => {});
      }
      current_history_node = target_history_node;

      deselect(true);
      if (!canceling) {
        cancel(true);
      }
      saved = false;

      ctx.copy(target_history_node.image_data);
      if (target_history_node.selection_image_data) {
        if (selection) {
          selection.destroy();
        }
        // @TODO maybe: could store whether a selection is from Free-Form Select
        // so it selects Free-Form Select when you jump to e.g. Move Selection
        // (or could traverse history to figure it out)
        if (target_history_node.name === "Free-Form Select") {
          select_tool(get_tool_by_name("Free-Form Select"));
        } else {
          select_tool(get_tool_by_name("Select"));
        }
        selection = new OnCanvasSelection(
          target_history_node.selection_x,
          target_history_node.selection_y,
          target_history_node.selection_image_data.width,
          target_history_node.selection_image_data.height,
          target_history_node.selection_image_data,
        );
      }
      if (target_history_node.textbox_text != null) {
        if (textbox) {
          textbox.destroy();
        }
        // @# text_tool_font =
        for (const [k, v] of Object.entries(target_history_node.text_tool_font)) {
          text_tool_font[k] = v;
        }

        colors.foreground = target_history_node.foreground_color;
        colors.background = target_history_node.background_color;
        tool_transparent_mode = target_history_node.tool_transparent_mode;
        $G.trigger("option-changed");

        select_tool(get_tool_by_name("Text"));
        textbox = new OnCanvasTextBox(
          target_history_node.textbox_x,
          target_history_node.textbox_y,
          target_history_node.textbox_width,
          target_history_node.textbox_height,
          target_history_node.textbox_text,
        );
      }

      const ancestors_of_target = get_history_ancestors(target_history_node);

      undos = [...ancestors_of_target];
      undos.reverse();

      const old_history_path =
        redos.length > 0 ? [redos[0], ...get_history_ancestors(redos[0])] : [from_history_node, ...get_history_ancestors(from_history_node)];

      // window.console && console.log("target_history_node:", target_history_node);
      // window.console && console.log("ancestors_of_target:", ancestors_of_target);
      // window.console && console.log("old_history_path:", old_history_path);
      redos.length = 0;

      let latest_node = target_history_node;
      while (latest_node.futures.length > 0) {
        const futures = [...latest_node.futures];
        futures.sort((a, b) => {
          if (old_history_path.indexOf(a) > -1) {
            return -1;
          }
          if (old_history_path.indexOf(b) > -1) {
            return +1;
          }
          return 0;
        });
        latest_node = futures[0];
        redos.unshift(latest_node);
      }
      // window.console && console.log("new undos:", undos);
      // window.console && console.log("new redos:", redos);

      $canvas_area.trigger("resize");
      $G.triggerHandler("session-update"); // autosave
      $G.triggerHandler("history-update"); // update history view
    }

    function undoable({
      name,
      icon,
      use_loose_canvas_changes,
      soft
    }, callback) {
      if (!use_loose_canvas_changes) {
        const current_image_data = ctx.getImageData(0, 0, canvas.width, canvas.height);
        if (!current_history_node.image_data || !image_data_match(current_history_node.image_data, current_image_data, 5)) {
          window.console && console.log("Canvas image data changed outside of undoable", current_history_node, "current_history_node.image_data:", current_history_node.image_data, "document's current image data:", current_image_data);
          undoable({
            name: "Unknown [undoable]",
            use_loose_canvas_changes: true
          }, () => {});
        }
      }

      saved = false;

      const before_callback_history_node = current_history_node;
      callback && callback();
      if (current_history_node !== before_callback_history_node) {
        show_error_message(`History node switched during undoable callback for ${name}. This shouldn't happen.`);
        window.console && console.log(`History node switched during undoable callback for ${name}, from`, before_callback_history_node, "to", current_history_node);
      }

      const image_data = ctx.getImageData(0, 0, canvas.width, canvas.height);

      redos.length = 0;
      undos.push(current_history_node);

      const new_history_node = make_history_node({
        image_data,
        selection_image_data: selection && selection.canvas.ctx.getImageData(0, 0, selection.canvas.width, selection.canvas.height),
        selection_x: selection && selection.x,
        selection_y: selection && selection.y,
        textbox_text: textbox && textbox.$editor.val(),
        textbox_x: textbox && textbox.x,
        textbox_y: textbox && textbox.y,
        textbox_width: textbox && textbox.width,
        textbox_height: textbox && textbox.height,
        text_tool_font: JSON.parse(JSON.stringify(text_tool_font)),
        tool_transparent_mode,
        foreground_color: colors.foreground,
        background_color: colors.background,
        ternary_color: colors.ternary,
        parent: current_history_node,
        name,
        icon,
        soft,
      });
      current_history_node.futures.push(new_history_node);
      current_history_node = new_history_node;

      $G.triggerHandler("history-update"); // update history view

      $G.triggerHandler("session-update"); // autosave
    }

    function make_or_update_undoable(undoable_meta, undoable_action) {
      if (current_history_node.futures.length === 0 && undoable_meta.match(current_history_node)) {
        undoable_action();
        current_history_node.image_data = ctx.getImageData(0, 0, canvas.width, canvas.height);
        current_history_node.selection_image_data = selection && selection.canvas.ctx.getImageData(0, 0, selection.canvas.width, selection.canvas.height);
        current_history_node.selection_x = selection && selection.x;
        current_history_node.selection_y = selection && selection.y;
        if (undoable_meta.update_name) {
          current_history_node.name = undoable_meta.name;
        }
        $G.triggerHandler("history-update"); // update history view
      } else {
        undoable(undoable_meta, undoable_action);
      }
    }

    function undo() {
      if (undos.length < 1) {
        return false;
      }

      redos.push(current_history_node);
      let target_history_node = undos.pop();

      while (target_history_node.soft && undos.length) {
        redos.push(target_history_node);
        target_history_node = undos.pop();
      }

      go_to_history_node(target_history_node);

      return true;
    }

    let $document_history_prompt_window;

    function redo() {
      if (redos.length < 1) {
        if ($document_history_prompt_window) {
          $document_history_prompt_window.close();
        }
        if (!$document_history_window || $document_history_window.closed) {
          const $w = $document_history_prompt_window = new $ToolWindow();
          $w.title("Redo");
          $w.$content.html("Press <b>Ctrl+Shift+Y</b> at any time to open the History window.");
          $w.$Button("Show History", show_document_history);
        }
        return false;
      }

      undos.push(current_history_node);
      let target_history_node = redos.pop();

      while (target_history_node.soft && redos.length) {
        undos.push(target_history_node);
        target_history_node = redos.pop();
      }

      go_to_history_node(target_history_node);

      return true;
    }

    function get_history_ancestors(node) {
      const ancestors = [];
      for (node = node.parent; node; node = node.parent) {
        ancestors.push(node);
      }
      return ancestors;
    }

    let $document_history_window;

    function show_document_history() {
      if ($document_history_prompt_window) {
        $document_history_prompt_window.close();
      }
      if ($document_history_window) {
        $document_history_window.close();
      }
      const $w = $document_history_window = new $ToolWindow();
      $w.title("Document History");
      $w.$content.html(`
		<div class="history-view"></div>
		<p>Press <b>Ctrl+Shift+Y</b> at any time to open this window.</p>
	`);

      const $history_view = $w.$content.find(".history-view");

      let previous_scroll_position = 0;

      let rendered_$entries = [];

      function render_tree_from_node(node) {
        const $entry = $(`
			<div class="history-entry">
				<div class="history-entry-icon-area"></div>
				<div class="history-entry-name"></div>
			</div>
		`);
        // $entry.find(".history-entry-name").text((node.name || "Unknown") + (node.soft ? " (soft)" : ""));
        $entry.find(".history-entry-name").text(node.name || "Unknown");
        $entry.find(".history-entry-icon-area").append(node.icon);
        if (node === current_history_node) {
          $entry.addClass("current");
          requestAnimationFrame(() => {
            $history_view.scrollTop(previous_scroll_position);
            $entry[0].scrollIntoView({
              block: "nearest"
            });
          });
        } else {
          const history_ancestors = get_history_ancestors(current_history_node);
          if (history_ancestors.indexOf(node) > -1) {
            $entry.addClass("ancestor-of-current");
          }
        }
        for (const sub_node of node.futures) {
          render_tree_from_node(sub_node);
        }
        $entry.on("click", () => {
          go_to_history_node(node);
        });
        $entry.history_node = node;
        rendered_$entries.push($entry);
      }
      const render_tree = () => {
        previous_scroll_position = $history_view.scrollTop();
        $history_view.empty();
        rendered_$entries = [];
        render_tree_from_node(root_history_node);
        rendered_$entries.sort(($a, $b) => {
          if ($a.history_node.timestamp < $b.history_node.timestamp) {
            return -1;
          }
          if ($b.history_node.timestamp < $a.history_node.timestamp) {
            return +1;
          }
          return 0;
        });
        rendered_$entries.forEach(($entry) => {
          $history_view.append($entry);
        });
      };
      render_tree();

      $G.on("history-update", render_tree);
      $w.on("close", () => {
        $G.off("history-update", render_tree);
      });

      $w.center();
    }

    function cancel(going_to_history_node) {
      // Note: this function should be idempotent.
      // `cancel(); cancel();` should do the same thing as `cancel();`
      history_node_to_cancel_to = history_node_to_cancel_to || current_history_node;
      $G.triggerHandler("pointerup", ["canceling"]);
      for (const selected_tool of selected_tools) {
        selected_tool.cancel && selected_tool.cancel();
      }
      if (!going_to_history_node) {
        // Note: this will revert any changes from other users in multi-user sessions
        // which isn't good, but there's no real conflict resolution in multi-user mode anyways
        go_to_history_node(history_node_to_cancel_to, true);
      }
      history_node_to_cancel_to = null;
      update_helper_layer();
    }

    function meld_selection_into_canvas(going_to_history_node) {
      selection.draw();
      selection.destroy();
      selection = null;
      if (!going_to_history_node) {
        undoable({
          name: "Deselect",
          icon: get_icon_for_tool(get_tool_by_name("Select")),
          use_loose_canvas_changes: true, // HACK; @TODO: make OnCanvasSelection not change the canvas outside undoable, same rules as tools
        }, () => {});
      }
    }

    function meld_textbox_into_canvas(going_to_history_node) {
      const text = textbox.$editor.val();
      if (text && !going_to_history_node) {
        undoable({
          name: "Text",
          icon: get_icon_for_tool(get_tool_by_name("Text")),
          soft: true,
        }, () => {});
        undoable({
          name: "Finish Text",
          icon: get_icon_for_tool(get_tool_by_name("Text")),
        }, () => {
          ctx.drawImage(textbox.canvas, textbox.x, textbox.y);
          textbox.destroy();
          textbox = null;
        });
      } else {
        textbox.destroy();
        textbox = null;
      }
    }

    function deselect(going_to_history_node) {
      if (selection) {
        meld_selection_into_canvas(going_to_history_node);
      }
      if (textbox) {
        meld_textbox_into_canvas(going_to_history_node);
      }
      for (const selected_tool of selected_tools) {
        selected_tool.end && selected_tool.end(ctx);
      }
    }

    function delete_selection(meta = {}) {
      if (selection) {
        undoable({
          name: meta.name || "Delete",
          icon: meta.icon || get_help_folder_icon("p_delete.png"),
          // soft: @TODO: conditionally soft?,
        }, () => {
          selection.destroy();
          selection = null;
        });
      }
    }

    function select_all() {
      deselect();
      select_tool(get_tool_by_name("Select"));

      undoable({
        name: "Select All",
        icon: get_icon_for_tool(get_tool_by_name("Select")),
        soft: true,
      }, () => {
        selection = new OnCanvasSelection(0, 0, canvas.width, canvas.height);
      });
    }

    const browserRecommendationForClipboardAccess = "Try using Chrome 76+";

    function try_exec_command(commandId) {
      if (document.queryCommandEnabled(commandId)) { // not a reliable source for whether it'll work, if I recall
        document.execCommand(commandId);
        if (!navigator.userAgent.includes("Firefox") || commandId === "paste") {
          return show_error_message(`That ${commandId} probably didn't work. ${browserRecommendationForClipboardAccess}`);
        }
      } else {
        return show_error_message(`Cannot perform ${commandId}. ${browserRecommendationForClipboardAccess}`);
      }
    }

    function getSelectionText() {
      let text = "";
      const activeEl = document.activeElement;
      const activeElTagName = activeEl ? activeEl.tagName.toLowerCase() : null;
      if (
        (activeElTagName == "textarea") || (activeElTagName == "input" &&
          /^(?:text|search|password|tel|url)$/i.test(activeEl.type)) &&
        (typeof activeEl.selectionStart == "number")
      ) {
        text = activeEl.value.slice(activeEl.selectionStart, activeEl.selectionEnd);
      } else if (window.getSelection) {
        text = window.getSelection().toString();
      }
      return text;
    }

    async function edit_copy(execCommandFallback) {
      const text = getSelectionText();

      if (text.length > 0) {
        if (!navigator.clipboard || !navigator.clipboard.writeText) {
          if (execCommandFallback) {
            return try_exec_command("copy");
          } else {
            throw new Error(`The Async Clipboard API is not supported by this browser. ${browserRecommendationForClipboardAccess}`);
          }
        }
        navigator.clipboard.writeText(text);
      } else if (selection && selection.canvas) {
        if (!navigator.clipboard || !navigator.clipboard.write) {
          if (execCommandFallback) {
            return try_exec_command("copy");
          } else {
            throw new Error(`The Async Clipboard API is not supported by this browser. ${browserRecommendationForClipboardAccess}`);
          }
        }
        selection.canvas.toBlob(blob => {
          sanity_check_blob(blob, () => {
            navigator.clipboard.write([
              new ClipboardItem(Object.defineProperty({}, blob.type, {
                value: blob,
                enumerable: true,
              }))
            ]).then(() => {
              window.console && console.log("Copied image to the clipboard.");
            }, error => {
              show_error_message("Failed to copy to the Clipboard.", error);
            });
          });
        });
      }
    }

    function edit_cut(execCommandFallback) {
      if (!navigator.clipboard || !navigator.clipboard.write) {
        if (execCommandFallback) {
          return try_exec_command("cut");
        } else {
          throw new Error(`The Async Clipboard API is not supported by this browser. ${browserRecommendationForClipboardAccess}`);
        }
      }
      edit_copy();
      delete_selection({
        name: "Cut",
        icon: get_help_folder_icon("p_cut.png"),
      });
    }
    async function edit_paste(execCommandFallback) {
      if (
        document.activeElement instanceof HTMLInputElement ||
        document.activeElement instanceof HTMLTextAreaElement
      ) {
        if (!navigator.clipboard || !navigator.clipboard.readText) {
          if (execCommandFallback) {
            return try_exec_command("paste");
          } else {
            throw new Error(`The Async Clipboard API is not supported by this browser. ${browserRecommendationForClipboardAccess}`);
          }
        }
        const clipboardText = await navigator.clipboard.readText();
        document.execCommand("InsertText", false, clipboardText);
        return;
      }
      if (!navigator.clipboard || !navigator.clipboard.read) {
        if (execCommandFallback) {
          return try_exec_command("paste");
        } else {
          throw new Error(`The Async Clipboard API is not supported by this browser. ${browserRecommendationForClipboardAccess}`);
        }
      }
      try {
        const clipboardItems = await navigator.clipboard.read();
        const blob = await clipboardItems[0].getType("image/png");
        paste_image_from_file(blob);
      } catch (error) {
        if (error.name === "NotFoundError") {
          try {
            const clipboardText = await navigator.clipboard.readText();
            if (clipboardText) {
              const uris = get_URIs(clipboardText);
              if (uris.length > 0) {
                load_image_from_URI(uris[0], (error, img) => {
                  if (error) {
                    return show_resource_load_error_message(error);
                  }
                  paste(img);
                });
              } else {
                show_error_message("The information on the Clipboard can't be inserted into Paint.");
              }
            } else {
              show_error_message("The information on the Clipboard can't be inserted into Paint.");
            }
          } catch (error) {
            show_error_message("Failed to read from the Clipboard.", error);
          }
        } else {
          show_error_message("Failed to read from the Clipboard.", error);
        }
      }
    }

    function image_invert_colors() {
      apply_image_transformation({
        name: "Invert Colors",
        icon: get_help_folder_icon("p_invert.png"),
      }, (original_canvas, original_ctx, new_canvas, new_ctx) => {
        invert_rgb(original_ctx, new_ctx);
      });
    }

    function clear() {
      deselect();
      cancel();
      undoable({
        name: "Clear Image",
        icon: get_help_folder_icon("p_blank.png"),
      }, () => {
        saved = false;

        if (transparency) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
        } else {
          ctx.fillStyle = colors.background;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
      });
    }

    function view_bitmap() {
      if (canvas.requestFullscreen) {
        canvas.requestFullscreen();
      }
      if (canvas.webkitRequestFullscreen) {
        canvas.webkitRequestFullscreen();
      }
    }

    function get_tool_by_name(name) {
      for (let i = 0; i < tools.length; i++) {
        if (tools[i].name == name) {
          return tools[i];
        }
      }
      for (let i = 0; i < extra_tools.length; i++) {
        if (extra_tools[i].name == name) {
          return extra_tools[i];
        }
      }
    }

    // hacky but whatever
    // this whole "multiple tools" thing is hacky for now
    function select_tools(tools) {
      for (let i = 0; i < tools.length; i++) {
        select_tool(tools[i], i > 0);
      }
      update_helper_layer();
    }

    function select_tool(tool, toggle) {
      deselect();

      if (!(selected_tools.length === 1 && selected_tool.deselect)) {
        return_to_tools = [...selected_tools];
      }
      if (toggle) {
        const index = selected_tools.indexOf(tool);
        if (index === -1) {
          selected_tools.push(tool);
          selected_tools.sort((a, b) => {
            if (tools.indexOf(a) < tools.indexOf(b)) {
              return -1;
            }
            if (tools.indexOf(a) > tools.indexOf(b)) {
              return +1;
            }
            return 0;
          });
        } else {
          selected_tools.splice(index, 1);
        }
        if (selected_tools.length > 0) {
          selected_tool = selected_tools[selected_tools.length - 1];
        } else {
          selected_tool = default_tool;
          selected_tools = [selected_tool];
        }
      } else {
        selected_tool = tool;
        selected_tools = [tool];
      }

      if (tool.preload) {
        tool.preload();
      }

      $toolbox.update_selected_tool();
      // $toolbox2.update_selected_tool();
    }

    function has_any_transparency(ctx) {
      // @TODO Optimization: Assume JPEGs and some other file types are opaque.
      // Raster file formats that SUPPORT transparency include GIF, PNG, BMP and TIFF
      // (Yes, even BMPs support transparency!)
      const id = ctx.getImageData(0, 0, canvas.width, canvas.height);
      for (let i = 0, l = id.data.length; i < l; i += 4) {
        if (id.data[i + 3] < 255) {
          return true;
        }
      }
      return false;
    }

    function detect_transparency() {
      transparency = has_any_transparency(ctx);
    }

    function is_all_black_and_white(ctx) {
      const id = ctx.getImageData(0, 0, canvas.width, canvas.height);
      for (let i = 0, l = id.data.length; i < l; i += 4) {
        if (id.data[i + 3] < 255) {
          return false;
        }
        if (!(
            (id.data[i] === 255 && id.data[i + 1] === 255 && id.data[i + 2] === 255) ||
            (id.data[i] === 0 && id.data[i + 1] === 0 && id.data[i + 2] === 0)
          )) {
          return false;
        }
      }
      return true;
    }

    function make_monochrome_pattern(lightness) {

      const dither_threshold_table = Array.from({
        length: 64
      }, (_undefined, p) => {
        const q = p ^ (p >> 3);
        return (
          ((p & 4) >> 2) | ((q & 4) >> 1) |
          ((p & 2) << 1) | ((q & 2) << 2) |
          ((p & 1) << 4) | ((q & 1) << 5)
        ) / 64;
      });

      const pattern_canvas = document.createElement("canvas");
      const pattern_ctx = pattern_canvas.getContext("2d");

      pattern_canvas.width = 8;
      pattern_canvas.height = 8;

      const pattern_image_data = ctx.createImageData(pattern_canvas.width, pattern_canvas.height);

      for (let x = 0; x < pattern_canvas.width; x += 1) {
        for (let y = 0; y < pattern_canvas.height; y += 1) {
          const map_value = dither_threshold_table[(x & 7) + ((y & 7) << 3)];
          const px_white = lightness > map_value;
          const index = ((y * pattern_image_data.width) + x) * 4;
          pattern_image_data.data[index + 0] = px_white * 255;
          pattern_image_data.data[index + 1] = px_white * 255;
          pattern_image_data.data[index + 2] = px_white * 255;
          pattern_image_data.data[index + 3] = 255;
        }
      }

      pattern_ctx.putImageData(pattern_image_data, 0, 0);

      return ctx.createPattern(pattern_canvas, "repeat");
    }

    function make_monochrome_palette() {
      const palette = [];
      const n_colors_per_row = 14;
      const n_colors = n_colors_per_row * 2;
      for (let i = 0; i < n_colors_per_row; i++) {
        let lightness = i / n_colors;
        palette.push(make_monochrome_pattern(lightness));
      }
      for (let i = 0; i < n_colors_per_row; i++) {
        let lightness = 1 - i / n_colors;
        palette.push(make_monochrome_pattern(lightness));
      }

      return palette;
    }

    function make_stripe_pattern(reverse, colors, stripe_size = 4) {
      const rgba_colors = colors.map(get_rgba_from_color);

      const pattern_canvas = document.createElement("canvas");
      const pattern_ctx = pattern_canvas.getContext("2d");

      pattern_canvas.width = colors.length * stripe_size;
      pattern_canvas.height = colors.length * stripe_size;

      const pattern_image_data = ctx.createImageData(pattern_canvas.width, pattern_canvas.height);

      for (let x = 0; x < pattern_canvas.width; x += 1) {
        for (let y = 0; y < pattern_canvas.height; y += 1) {
          const pixel_index = ((y * pattern_image_data.width) + x) * 4;
          // +1000 to avoid remainder on negative numbers
          const pos = reverse ? (x - y) : (x + y);
          const color_index = Math.floor((pos + 1000) / stripe_size) % colors.length;
          const rgba = rgba_colors[color_index];
          pattern_image_data.data[pixel_index + 0] = rgba[0];
          pattern_image_data.data[pixel_index + 1] = rgba[1];
          pattern_image_data.data[pixel_index + 2] = rgba[2];
          pattern_image_data.data[pixel_index + 3] = rgba[3];
        }
      }

      pattern_ctx.putImageData(pattern_image_data, 0, 0);

      return ctx.createPattern(pattern_canvas, "repeat");
    }

    function switch_to_polychrome_palette() {

    }

    function make_opaque() {
      undoable({
        name: "Make Opaque",
        icon: get_help_folder_icon("p_make_opaque.png"),
      }, () => {
        ctx.save();
        ctx.globalCompositeOperation = "destination-atop";

        ctx.fillStyle = colors.background;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // in case the selected background color is transparent/translucent
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.restore();
      });
    }

    function resize_canvas_without_saving_dimensions(unclamped_width, unclamped_height, undoable_meta = {}) {
      const new_width = Math.max(1, unclamped_width);
      const new_height = Math.max(1, unclamped_height);
      if (canvas.width !== new_width || canvas.height !== new_height) {
        undoable({
          name: undoable_meta.name || "Resize Canvas",
          icon: undoable_meta.icon || get_help_folder_icon("p_stretch_both.png"),
        }, () => {
          const image_data = ctx.getImageData(0, 0, new_width, new_height);
          canvas.width = new_width;
          canvas.height = new_height;
          ctx.disable_image_smoothing();

          if (!transparency) {
            ctx.fillStyle = colors.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
          }

          const temp_canvas = make_canvas(image_data);
          ctx.drawImage(temp_canvas, 0, 0);

          $canvas_area.trigger("resize");
        });
      }
    }

    function resize_canvas_and_save_dimensions(unclamped_width, unclamped_height, undoable_meta = {}) {
      resize_canvas_without_saving_dimensions(unclamped_width, unclamped_height, undoable_meta);
      storage.set({
        width: canvas.width,
        height: canvas.height,
      }, ( /*error*/ ) => {
        // oh well
      })
    }

    function image_attributes() {
      if (image_attributes.$window) {
        image_attributes.$window.close();
      }
      const $w = image_attributes.$window = new $FormToolWindow("Attributes");

      const $main = $w.$main;

      // Information

      const table = {
        "File last saved": "Not available", // @TODO
        "Size on disk": "Not available", // @TODO
        "Resolution": "72 x 72 dots per inch",
      };
      const $table = $(E("table"))
        .attr("style", "margin-bottom: 10px")
        .appendTo($main);

      for (const k in table) {
        const $tr = $(E("tr")).appendTo($table);
        const $key = $(E("td")).appendTo($tr).text(`${k}:`);
        const $value = $(E("td")).appendTo($tr).text(table[k]);
      }

      // Dimensions

      const unit_sizes_in_px = {
        px: 1,
        in: 72,
        cm: 28.3465
      };
      let current_unit = image_attributes.unit = image_attributes.unit || "px";
      let width_in_px = canvas.width;
      let height_in_px = canvas.height;

      const $width_label = $(E("label")).appendTo($main).text("Width:");
      const $height_label = $(E("label")).appendTo($main).text("Height:");
      const $width = $(E("input"))
        .attr({
          type: "number",
          min: 1
        })
        .attr("style", "margin-bottom: 10px; margin-right: 6px;")
        .addClass("no-spinner xp-input")
        .appendTo($width_label);

      const $height = $(E("input"))
        .attr({
          type: "number",
          min: 1
        })
        .attr("style", "margin-bottom: 10px")
        .addClass("no-spinner xp-input")
        .appendTo($height_label);

      $main.find("input")
        .css({
          width: "40px"
        })
        .on("change keyup keydown keypress pointerdown pointermove paste drop", () => {
          width_in_px = $width.val() * unit_sizes_in_px[current_unit];
          height_in_px = $height.val() * unit_sizes_in_px[current_unit];
        });

      // Fieldsets

      const $units = $(E("fieldset"))
        .addClass("xp-groupbox")
        .attr("style", "background-color: #ece9d8; width: 200px; display: flex; justify-content: space-between;")
        .appendTo($main)
        .append('<legend>Units</legend>');

      $units.append('<label><input type="radio" name="units" value="in">Inches</label>');
      $units.append('<label><input type="radio" name="units" value="cm">Cm</label>');
      $units.append('<label><input type="radio" name="units" value="px">Pixels</label>');
      $units.find(`[value=${current_unit}]`).attr({
        checked: true
      });
      $units.on("change", () => {
        const new_unit = $units.find(":checked").val();
        $width.val(width_in_px / unit_sizes_in_px[new_unit]);
        $height.val(height_in_px / unit_sizes_in_px[new_unit]);
        current_unit = new_unit;
      }).triggerHandler("change");

      const $colors = $(E("fieldset"))
        .addClass("xp-groupbox")
        .attr("style", "background-color: #ece9d8; width: 200px; display: flex; justify-content: space-between;")
        .appendTo($main)
        .append('<legend>Colors</legend>');

      $colors.append('<label><input type="radio" name="colors" value="monochrome">Black and White</label>');
      $colors.append('<label><input type="radio" name="colors" value="polychrome">Color</label>');
      $colors.find(`[value=${monochrome ? "monochrome" : "polychrome"}]`).attr({
        checked: true
      });

      const $transparency = $(E("fieldset"))
        .addClass("xp-groupbox")
        .attr("style", "background-color: #ece9d8; width: 200px; display: flex; justify-content: space-between;")
        .appendTo($main)
        .append('<legend>Transparency</legend>');

      $transparency.append('<label><input type="radio" name="transparency" value="transparent">Transparent</label>');
      $transparency.append('<label><input type="radio" name="transparency" value="opaque">Opaque</label>');
      $transparency.find(`[value=${transparency ? "transparent" : "opaque"}]`).attr({
        checked: true
      });

      // Buttons on the right

      $w.$Button("OK", () => {
        const transparency_option = $transparency.find(":checked").val();
        const colors_option = $colors.find(":checked").val();
        const unit = $units.find(":checked").val();

        const was_monochrome = monochrome;

        image_attributes.unit = unit;
        transparency = (transparency_option == "transparent");
        monochrome = (colors_option == "monochrome");

        if (monochrome != was_monochrome) {
          if (monochrome) {
            palette = monochrome_palette;
          } else {
            palette = polychrome_palette;
          }

          $colorbox.rebuild_palette();
          reset_colors();
        }
        if (monochrome && !is_all_black_and_white(ctx)) {
          show_convert_to_black_and_white();
        }

        const unit_to_px = unit_sizes_in_px[unit];
        const width = $width.val() * unit_to_px;
        const height = $height.val() * unit_to_px;
        resize_canvas_and_save_dimensions(~~width, ~~height);

        if (!transparency && has_any_transparency(ctx)) {
          make_opaque();
        }

        image_attributes.$window.close();
      })[0].focus();

      $w.$Button("Cancel", () => {
        image_attributes.$window.close();
      });

      $w.$Button("Default", () => {
        width_in_px = default_canvas_width;
        height_in_px = default_canvas_height;
        $width.val(width_in_px / unit_sizes_in_px[current_unit]);
        $height.val(height_in_px / unit_sizes_in_px[current_unit]);
      });

      // Reposition the window

      image_attributes.$window.center();

      $w.$form.attr("style", "display: flex");
      $w.$buttons.attr("style", "display: flex; flex-direction: column;")
    }

    function show_convert_to_black_and_white() {
      const $w = new $FormToolWindow("Convert to Black and White");
      $w.addClass("convert-to-black-and-white");
      $w.$main.append("<fieldset><legend>Threshold</legend><input type='range' min='0' max='1' step='0.01' value='0.5'></fieldset>");
      const $slider = $w.$main.find("input[type='range']");
      const original_canvas = make_canvas(canvas);
      let threshold;
      const update_threshold = () => {
        make_or_update_undoable({
          name: "Make Monochrome",
          match: (history_node) => history_node.name === "Make Monochrome",
          icon: get_help_folder_icon("p_monochrome.png"),
        }, () => {
          threshold = $slider.val();
          ctx.copy(original_canvas);
          threshold_black_and_white(ctx, threshold);
        });
      };
      update_threshold();
      $slider.on("input", debounce(update_threshold, 100));

      $w.$Button("OK", () => {
        $w.close();
      });
      $w.$Button("Cancel", () => {
        if (current_history_node.name === "Make Monochrome") {
          undo();
        } else {
          undoable({
            name: "Cancel Make Monochrome",
            icon: get_help_folder_icon("p_monochrome_undo.png"),
          }, () => {
            ctx.copy(original_canvas);
          });
        }
        $w.close();
      });
      $w.center();
    }

    function image_flip_and_rotate() {
      const $w = new $FormToolWindow("Flip and Rotate");
      $w.addClass("flip-and-rotate");

      const $fieldset = $(E("fieldset"))
        .addClass("xp-groupbox")
        .attr("style", "background-color: #ece9d8;")
        .appendTo($w.$main);

      $fieldset.append(`
		<legend>Flip or rotate</legend>
		<label><input type="radio" name="flip-or-rotate" value="flip-horizontal" checked/>Flip horizontal</label>
		<label><input type="radio" name="flip-or-rotate" value="flip-vertical"/>Flip vertical</label>
		<label><input type="radio" name="flip-or-rotate" value="rotate-by-angle"/>Rotate by angle</label>
	`);

      const $rotate_by_angle = $(E("div")).appendTo($fieldset);
      $rotate_by_angle.css({
        paddingLeft: "30px"
      });
      $rotate_by_angle.append(`
		<label><input type="radio" name="rotate-by-angle" value="90" checked/>90°</label>
		<label><input type="radio" name="rotate-by-angle" value="180"/>180°</label>
		<label><input type="radio" name="rotate-by-angle" value="270"/>270°</label>
		<label><input type="radio" name="rotate-by-angle" value="arbitrary"/><input type="number" min="-360" max="360" name="rotate-by-arbitrary-angle" value="" class="no-spinner" style="width: 50px"/> Degrees</label>
	`);
      $rotate_by_angle.find("input").attr({
        disabled: true
      });

      $fieldset.find("input").on("change", () => {
        const action = $fieldset.find("input[name='flip-or-rotate']:checked").val();
        $rotate_by_angle.find("input").attr({
          disabled: action !== "rotate-by-angle"
        });
      });
      $rotate_by_angle.find("label, input").on("click", (e) => {
        // Select "Rotate by angle" and enable subfields
        $fieldset.find("input[value='rotate-by-angle']").prop("checked", true);
        $fieldset.find("input").triggerHandler("change");

        const $label = $(e.target).closest("label");
        // Focus the numerical input if this field has one
        const num_input = $label.find("input[type='number']")[0];
        if (num_input) {
          num_input.focus();
        }
        // Select the radio for this field
        $label.find("input[type='radio']").prop("checked", true);
      });
      // @TODO: enable all controls that are accessable to the pointer

      $fieldset.find("label").css({
        display: "block"
      });

      $w.$Button("OK", () => {
        const action = $fieldset.find("input[name='flip-or-rotate']:checked").val();
        let angle_val = $fieldset.find("input[name='rotate-by-angle']:checked").val();
        if (angle_val === "arbitrary") {
          angle_val = $fieldset.find("input[name='rotate-by-arbitrary-angle']").val();
        }
        const angle_deg = parseFloat(angle_val);
        const angle = angle_deg / 360 * TAU;

        if (isNaN(angle)) {
          const $msgw = new $FormToolWindow("Invalid Value").addClass("dialogue-window");
          $msgw.$main.text("The value specified for Degrees was invalid.");
          $msgw.$Button("OK", () => {
            $msgw.close();
          });
          return;
        }

        switch (action) {
          case "flip-horizontal":
            flip_horizontal();
            break;
          case "flip-vertical":
            flip_vertical();
            break;
          case "rotate-by-angle":
            rotate(angle);
            break;
        }

        $canvas_area.trigger("resize");

        $w.close();
      })[0].focus();
      $w.$Button("Cancel", () => {
        $w.close();
      });

      $w.center();

      $w.$form.attr("style", "display: flex");
      $w.$buttons.attr("style", "display: flex; flex-direction: column;")
    }

    function image_stretch_and_skew() {
      const $w = new $FormToolWindow("Stretch and Skew");

      const $fieldset_stretch = $(E("fieldset"))
        .addClass("xp-groupbox")
        .attr("style", "background-color: #ece9d8;")
        .appendTo($w.$main);

      $fieldset_stretch.append("<legend>Stretch</legend><table></table>");

      const $fieldset_skew = $(E("fieldset"))
        .addClass("xp-groupbox")
        .attr("style", "background-color: #ece9d8;")
        .appendTo($w.$main);

      $fieldset_skew.append("<legend>Skew</legend><table></table>");

      const $RowInput = ($table, img_src, label_text, default_value, label_unit, min, max) => {
        const $tr = $(E("tr")).appendTo($table);
        const $img = $(E("img")).attr({
          src: img_src,
          width: 32,
          height: 32,
        }).css({
          marginRight: "20px"
        });
        const input_id = ("input" + Math.random() + Math.random()).replace(/\./, "");
        const $input = $(E("input")).attr({
          type: "number",
          min,
          max,
          value: default_value,
          id: input_id,
        }).css({
          width: "40px"
        }).addClass("no-spinner");
        $(E("td")).appendTo($tr).append($img);
        $(E("td")).appendTo($tr).append($(E("label")).text(label_text).attr("for", input_id));
        $(E("td")).appendTo($tr).append($input);
        $(E("td")).appendTo($tr).text(label_unit);

        return $input;
      };

      const stretch_x = $RowInput($fieldset_stretch.find("table"), STRETCH_X_BASE64, "Horizontal:", 100, "%", 1, 5000);
      const stretch_y = $RowInput($fieldset_stretch.find("table"), STRETCH_Y_BASE64, "Vertical:", 100, "%", 1, 5000);
      const skew_x = $RowInput($fieldset_skew.find("table"), SKEW_X_BASE64, "Horizontal:", 0, "Degrees", -90, 90);
      const skew_y = $RowInput($fieldset_skew.find("table"), SKEW_Y_BASE64, "Vertical:", 0, "Degrees", -90, 90);

      $w.$Button("OK", () => {
        const xscale = parseFloat(stretch_x.val()) / 100;
        const yscale = parseFloat(stretch_y.val()) / 100;
        const hskew = parseFloat(skew_x.val()) / 360 * TAU;
        const vskew = parseFloat(skew_y.val()) / 360 * TAU;
        stretch_and_skew(xscale, yscale, hskew, vskew);
        $canvas_area.trigger("resize");
        $w.close();
      })[0].focus();

      $w.$Button("Cancel", () => {
        $w.close();
      });

      $w.center();

      $w.$form.attr("style", "display: flex");
      $w.$buttons.attr("style", "display: flex; flex-direction: column;")
    }


    // @TODO: establish a better pattern for this (platform-specific functions, with browser-generic fallbacks)
    // Note: we can't just poke in a different save_canvas_as function in electron-injected.js because electron-injected.js is loaded first
    function save_canvas_as(canvas, fileName, savedCallbackUnreliable) {
      if (window.systemSaveCanvasAs) {
        return systemSaveCanvasAs(canvas, fileName, savedCallbackUnreliable);
      }

      // @TODO: file name + type dialog
      canvas.toBlob(blob => {
        sanity_check_blob(blob, () => {
          const file_saver = saveAs(blob, `${file_name.replace(/\.(bmp|dib|a?png|gif|jpe?g|jpe|jfif|tiff?|webp|raw)$/, "")}.png`);
          file_saver.onwriteend = () => {
            // this won't fire in chrome
            savedCallbackUnreliable();
          };
        });
      });
    }

    function set_as_wallpaper_tiled(c = canvas) {
      // Note: we can't just poke in a different set_as_wallpaper_tiled function, because it's stored by reference in menus.js
      if (window.systemSetAsWallpaperTiled) {
        return window.systemSetAsWallpaperTiled(c);
      }

      const wallpaperCanvas = make_canvas(screen.width, screen.height);
      const pattern = wallpaperCanvas.ctx.createPattern(c, "repeat");
      wallpaperCanvas.ctx.fillStyle = pattern;
      wallpaperCanvas.ctx.fillRect(0, 0, wallpaperCanvas.width, wallpaperCanvas.height);

      set_as_wallpaper_centered(wallpaperCanvas);
    }

    function set_as_wallpaper_centered(c = canvas) {
      // Note: we can't just poke in a different set_as_wallpaper_centered function, because it's stored by reference in menus.js
      if (window.systemSetAsWallpaperCentered) {
        return window.systemSetAsWallpaperCentered(c);
      }

      c.toBlob(blob => {
        sanity_check_blob(blob, () => {
          saveAs(blob, `${file_name.replace(/\.(bmp|dib|a?png|gif|jpe?g|jpe|jfif|tiff?|webp|raw)$/, "")} wallpaper.png`);
        });
      });
    }

    /**
     * @param {HTMLElement} canvas
     * @return {Promise}
     */
    function get_array_buffer_from_canvas(canvas) {
      return new Promise((resolve, reject) => {
        const file_reader = new FileReader();

        file_reader.onloadend = () => {
          resolve(file_reader.result);
        };

        file_reader.onerror = () => {
          reject(new Error("Failed to read canvas image to array buffer"));
        };

        canvas.toBlob(blob => {
          sanity_check_blob(blob, () => {
            file_reader.readAsArrayBuffer(blob);
          });
        });
      });
    }

    function save_selection_to_file() {
      if (selection && selection.canvas) {
        selection.canvas.toBlob(blob => {
          sanity_check_blob(blob, () => {
            saveAs(blob, "selection.png");
          });
        });
      }
    }

    function sanity_check_blob(blob, okay_callback) {
      if (blob.size > 0) {
        okay_callback();
      } else {
        const $w = $FormToolWindow().title("Warning").addClass("dialogue-window");
        $w.$main.html(`
			<p>Tried to save file, but file was empty.</p>
			<p>Try again, or if the problem persists, report here:
			<a href='https://github.com/1j01/jspaint/issues/118'>Issue #118</a>
		`);
        $w.$main.css({
          maxWidth: "500px"
        });
        $w.$Button("OK", () => {
          $w.close();
        });
        $w.center();
      }
    }
  </script>
  <script>
    let $storage_manager;
    let $quota_exceeded_window;
    let ignoring_quota_exceeded = false;

    function storage_quota_exceeded() {
      if ($quota_exceeded_window) {
        $quota_exceeded_window.close();
        $quota_exceeded_window = null;
      }
      if (ignoring_quota_exceeded) {
        return;
      }
      const $w = $FormToolWindow().title("Storage Error").addClass("dialogue-window");
      $w.$main.html(
        "<p>JS Paint stores images as you work on them so that if you " +
        "close your browser or tab or reload the page " +
        "your images are usually safe.</p>" +
        "<p>However, it has run out of space to do so.</p>" +
        "<p>You can still save the current image with <b>File > Save</b>. " +
        "You should save frequently, or free up enough space to keep the image safe.</p>"
      );
      $w.$Button("View and manage storage", () => {
        $w.close();
        ignoring_quota_exceeded = false;
        manage_storage();
      });
      $w.$Button("Ignore", () => {
        $w.close();
        ignoring_quota_exceeded = true;
      });
      $w.width(500);
      $w.center();
      $quota_exceeded_window = $w;
    }

    function manage_storage() {
      if ($storage_manager) {
        $storage_manager.close();
      }
      $storage_manager = $FormToolWindow().title("Manage Storage").addClass("storage-manager dialogue-window");
      // @TODO: way to remove all (with confirmation)
      const $table = $(E("table")).appendTo($storage_manager.$main);
      const $message = $(E("p")).appendTo($storage_manager.$main).html(
        "Any images you've saved to your computer with <b>File > Save</b> will not be affected."
      );
      $storage_manager.$Button("Close", () => {
        $storage_manager.close();
      });

      const addRow = (k, imgSrc) => {
        const $tr = $(E("tr")).appendTo($table);

        const $img = $(E("img")).attr({
          src: imgSrc
        });
        const $remove = $(E("button")).text("Remove").addClass("remove-button");
        const href = `#${k.replace("image#", "local:")}`;
        const $open_link = $(E("a")).attr({
          href,
          target: "_blank"
        }).text("Open");
        const $thumbnail_open_link = $(E("a")).attr({
          href,
          target: "_blank"
        }).addClass("thumbnail-container");
        $thumbnail_open_link.append($img);
        $(E("td")).append($thumbnail_open_link).appendTo($tr);
        $(E("td")).append($open_link).appendTo($tr);
        $(E("td")).append($remove).appendTo($tr);

        $remove.on("click", () => {
          localStorage.removeItem(k);
          $tr.remove();
          if ($table.find("tr").length == 0) {
            $message.html("<p>All clear!</p>");
          }
        });
      };

      let localStorageAvailable = false;
      try {
        localStorage._available = true;
        localStorageAvailable = localStorage._available;
        delete localStorage._available;
        // eslint-disable-next-line no-empty
      } catch (e) {}

      if (localStorageAvailable) {
        for (const k in localStorage) {
          if (k.match(/^image#/)) {
            let v = localStorage[k];
            try {
              if (v[0] === '"') {
                v = JSON.parse(v);
              }
              // eslint-disable-next-line no-empty
            } catch (e) {}
            addRow(k, v);
          }
        }
      }

      if (!localStorageAvailable) {
        // @TODO: DRY with similar message
        // @TODO: instructions for your browser; it's called Cookies in chrome/chromium at least, and "storage" gives NO results
        $message.html("<p>Please enable local storage in your browser's settings for local backup. It may be called Cookies, Storage, or Site Data.</p>");
      } else if ($table.find("tr").length == 0) {
        $message.html("<p>All clear!</p>");
      }

      $storage_manager.width(450);
      $storage_manager.center();
    }
  </script>
  <script>
    const HELP_BACK_BUTTON_BASE64 = "data:image/png;base64,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";
    const HELP_BOOK_ICON_BASE64 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAEH3pUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjatVdblusoDPzXKmYJlsRzOYDhnLuDWf4UNn4kjvsm3T2mbbCQRVGFoEP13z+N/sElIo6M9cFF5yZcJpooCY0wrVdanjyZ5Tlepq3xYKe9Q2BS1Lq+BjfsFXaBvwx7GXES7PYUKNbRkR870ggkYQywjTgGUl4HmEZgSiOQyhjZrO95ndbkYvDnKZTh30b/QgNu6g+jXpx17A2eRibvXUQ7yGQ8eJs70FYk9u9sHoGe3mlzFWCSqqwTnqEj1PVOuP3ydPBhjWiz2sUypgy1hCaPdtx4/fr6Cjlt0IfkD5LuLb6xn5SmhdCtQ58Ucnv90s72sNNZ0kW308jO7SM/2I3thJyuTbV+tzaH1uo6u2QcpuzGpLapLC345c7W8pVD8bjtFDrZvUSUgJQoWEczFllGKRxZIGNjwzMnblyXunABRCNVPGqRIsqFYAwQI0rRLq7phZt4yDxrwAIoWA4Kq+xYeBk2LsMVDhh45kBYPYxgjE9+VOgdp9Z6QjFPYecKuKRnGlB05ZhpYrhBEW6DVLsQvJXnq+uqUNAuNAdMME25R4D82fKxuHQRWuFoUa8JzH4eAUAREFiAYYUCk0OusOPJi5BnBpEBAiVAFzWSIQtbKzNAilGkmBdkAcbGN54XV7GymrERQgirjpCQoScixDLGYv14E7CGklVrrLXOehtstMmp6xnmnHd9R01evfHWO+998NEnChpMsMEFH0KIIUWJih3XRuRjDDHGlDBoQuSErxMcUsqSNZtss8s+hxxzKkJFiym2uOJLKLGkWWadkcezm/0c5jinyhVLqZpqq6u+hhpralhqTZtptrnmW2iRWtpVG7Jeygeq8VBNFqW6o99Vg9X7LQT37cR2zaCYGIbgvivASiJdsymwMdKV65pNUZAVVgDSdnFm7opBQVNZbONdu0M5S+p+RzeCEPIbylGX7g3lrrq9Um1Oy0Gni0I9DTupkyL74JQk4A8n5tc1PRu0TldT+3s4em+8u/oYlg5btksr12haPswhDbML4OIWHf0ExRkEvUJxG+ILdPQTFGcQ9G2an9DR36U9odFajqY3v4LosiDflfcR2SM/WkOmxyiPcD9BRd+V+7qy71Y04H6C9v+Q/57MK+1XtPRdcl+S/QTzL8kw3WX/p7TeB3qNB/H35txqb6T+02StW9ibdXZLoNRw8CCH5Ml1/yTJGqXFpFVLi/Pa9fgdHYElnf2POEfI/STQcjHSJzl1vz9cck2vOXBi6kC/c1aPqSHAhcl8Md2SvHFFF9cnrl5zdMDMbU/aw/hqZq29t5DoLXZf7CenviNQbl+f1+9gorf3/afd9RkjnRjy32fofPb/4MQ+tpEPRr4LTL9xpn07kDb8l4ef+PQfcCBC7omkgIUAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAALiMAAC4jAXilP3YAAAAHdElNRQfkBwYXDwRP1h3bAAAAGXRFWHRDb21tZW50AENyZWF0ZWQgd2l0aCBHSU1QV4EOFwAAAJhJREFUOMulk9ENwyAMRB8shke70cxk7kebCGgCRDlkWTLcEyAb5opf3CpNjAjR5LQD6Iyt7iBpZVxBEhDujpuzoxGSAdwcc3sCiA7wBpLbjSeQ4+/yWFlBdCyJiCADafz9K8hovOqDGEHmhtkXJAkzo5RCrfWs/71J6AwgJEVEhLufedXiHaA178xGBzluMDOmxSTunHunD2g+dJ/t6XqHAAAAAElFTkSuQmCC";
    const HELP_FORWARD_BUTTON_BASE64 = "data:image/png;base64,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";
    const HELP_HIDE_BUTTON_BASE64 = "data:image/png;base64,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";
    const HELP_OPTIONS_BUTTON_BASE64 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAASl3pUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHja1ZpZdhu7kkX/MYoaAvpmOGjXqhnU8N8OINnItkjeK3+8Mi1RTCbRRHPOiQDV/L//Xep/+BdT1sqHlGOJUfPPF19s5Y+sz7+6fxvt9+/z4vae+Xpd3d+wXHI8u/Myx+v65Lrlfntd79c4levhaaAyrzfa1zfqNZDN1wTX9dtEzpwJ9DWwqtdAzl4z+/O6nW3pWHJ63kK/7l/X+9sM/Cj55V2yMUSTPL+91SnFwt/Zap+w25CFrm6LfC60a6BfXqvbrZY12emM0/zOskJ3fio/af+O3GNc4W/jIr+tS2eleMsqzQtTbnZ9/e/VytVt6ZfLv7j0/pf55vqTp9U26O0N94uH4v35j9dNeFxXzy7dfnuaOcb7zF+u63UzxsNz6ua+tUZea57dVR/Zcrw2ddvK/ov7mlhrfyrySPwEncXY8ig8MinRiaNBkDUe3RRjceMy3gxTzTJzP3fTWaK30yaere3Wma64mHFGsd2Jc708zLIJNw+XcXEnHBxX7X0tZk9b9nSdFBt6mKyIHsNgho/86KE+uWktSShjdL7binVZyTRWIZ4zRmnDbXjErMuoYRv49vj1n/jV4cGwzZzZYNVNRsD9LZhHcLntaMeNgeeTwCaNawBMxAoCizEOD+hoXDDR6GStSsZgyIyDKku3ztuGW0wIdrBI6x0plixZwNx8Jpl9qw32XAYIcURwUZGQWRIRZ3kfiJ/kMzFUgws+hBBDCjmUUKOLkmExpiiIWpNLPoUUU0o5lVRVdtnnkGNOOeeSa7HFgbihkI8ll1JqZdLKyJVPV26otdnmmm+hxZZabqXVblV33ffQY08999LrsMMN8njEkUYeZdRpJqE0/QwzzjTzLLMuQm255VdYcaWVV1Gr3r12ufW3xz/wmrm8Zren5MZ09xpXU7oNYQROgvgMj1lvcHgSDxinrBWf6Wy8t+I58ZkulqwIlkUGcc4w4jE86KexYZm77x6eCwrQ/Ct+UzjC/g3PKXHdB5773W9/8tqom+jc9pCkoRhVO7JvlTVztbkKU758Vu9u+PT5v3mgFfUapac1fTUThOZCLW5hKR97CFh2pN7Nag6W6MXjD7dmN8HymaxGrm2W9cnUbcpc1bUzV1kyCbNleVaL6ZpPqztPYHXmyKbJesbKpckteY7k1zRt6THK6ikNYgpqSczgy+xz1RFVcISYT8Qtn3DO1GyEa3w2fc5OTPVJQmi2EyQaJotbNckE02AItro3b5QdiVXIi77t0eNZao4JQOATQxO/fa29Or0/ZqrYtOTnQdXzqD8ZVH231H86qPqyVPEfr68oKDOK1fGMCRIHXtCg8xZizWN5gmDNWRkpLcAf5eBS8Ha1jgzLrImMBxhcd0WPOkYoo1fouowVwKdUtM8d/yNYEZ6j5TxSiypZv5zXZrQ0h2GW/VrWsZqufW8aEAl1r3jEOlNPo9bVQ809ZldXaACEaqEy2WrRupGFoEsKC/Vjwyg5OuTIHIP1hcBuDVizLQWEuDTkLwbdkykjy5lhSQoQ8NOdNQV8Iisq14psXegbMXZIph7zrz6wzliRm7ryssHVzRg4qqFodB4D09TW68wrzSVKBbtM34nM2XWqhGaqAL8PosrDzkBFeqSTgmJ2UnD7aYKLcecgpnEr5h0IxeZ0NoIVZFnDNDsYNa+hbsOeZzNv6c3Sf03wW36fsQmntUfObC9bVbeHGNoEknE9xvz12WARHN1jq3FlTbJnomYEq1sr4FGJ00SCJQ6ChKmIlNiJnI6+zyxpDduyOzHNBk9ME3g7ps2VJmCLeuw/ldv+Q9z7R9mIHWXDZVtOw3Xd4yO3Wg3isCERj3dSVCjiufCG+JkQyCUR0dO6HGcV0pkRIuyZfLQ4kmiLIbDfkqJ3rTnTUuwRBFKxDR0bJp4ubBPnSRoc7FuX/YoVhzdsRDbaPrObrg84d9jlW/ODhKHwswzacsSIme34mpmzk2Wzo5ETuTNiI6j+6KuHq9TlK5O32XQxQ+J0OX7PVfZC02SYCFRn35vB9kFLZkbtMIJb+DGXqjBOdzsRLEhC1LQKu3oqULvGHCwLsZkLq8RIQZKgaszWT7qEkzYeG3FlptL3esSoi0zqkMFiXClO2DDjxlaESKRcyT4J7U+Qnm2mcflTLQRPBr/QXcBBat2LdAhojAArWBtK7dH7ZkX76DlTs0ZwCXOAoajCHWNFqyyzh47t3MYBTZQSAX2E1i3mIb95mBis57+PItwS2gu74MgK80yE1DCK2RkW43Pdb7eHwbN1oRMYSLYdYdh0+jAbW6tgl0Q3Vu8dqOMdA/6pntnQ3idSZ0NV1Tts4k6xIGMBRRd8CuDt8OKvpoPMXAlR+EOl+TsTbyFQT0BsImbLxMg17u/PElUKSmhZTI8Ui+ThXG0H2bQHVL9DRC84VHBa2IJDOhFOFlhWaTt52xwn10t1d5Beot82SB+IvuEzi8KGaYHhCl0fi5t2DPR0Y0koy0G+5TlL3S7yAI6nHoLCEvNlluLc1AwoeZnKyUu10pWYRoKI63Y24ie0hPebFUj3MF2cggZI9BhZwvSuYj0dehEhX/qEIHGGyRaJ0s2xyUgnHJYF07DZEATqKHNNdM025m05pclypFxbgtnkt4wgmOXSsUarInV3/S5DjxG1LHMM7M0yUc5s2PhcZxyR2DaJXINwsEFOkQDJFCBCn7w1mtuYya6nQDW5Z+M4yiB7s5VAL2HqRZgGignVEqrDxCoMiZmKtWh5LJTZhpAvym8S63mjItLekBor9un1FM2PY31NOaJGJqmE1BR/HUljpAe1CE0yngIG+2R/UrNi5EVBsSlgc4ERfIMLvNuyBjoQ80AGK3juSIiPQczxiUkgNVcRMxqZYlCRbKTWUWpBwWRjqJOsySBk51ZCwLOKWdzGOEudJQgn+BhtA026od6M2BiOAmIqSgfDF4EXqhczRda4ATuIdoK6hWj6FPkw/fEXoeaOpu0bH46owGYynWhh1MuhChkondRguyRWCeypI40BNECYMg+HQ9fUdi1kTzHkcNIYFIYAJ/LF9AY6o/xrE49LSbmC7G+5C/UEYOK6AKYdgGF5Bf4kwbBrTAFzYxpHXaeqVHNF2i4YDYLA90RgyI16K4GFjrciG4uYcfhdANyw7AZlG8io18AqmUYESz86pJhUBRNBgr0SqmRZa39VTKhHNbGLiafa5Vk4yTBbOm3hJFmX5rfV0cVRAZ6/gIxhBci0JG3YCoyYPegVb+hlDnpVJcVplczemspENy8go5QRIOviVBO2q/vFYhN422CaRXeKuGhT7cV4Ib5gy8YPbERgbwSZJ256JPmbh/EwGqU/YmaKLra+IVXAYtykYNUmUklbJ308Y2fwE+YrcxCzyDTgI6S8Kf44ote+1eahCUS7eELAny1l5AVJ1oDVbNmCBTsiMevQU1L4D2BwDqnDUETCEkB1LJfqXHu7SjdEvKQsjCl4Bt6sy4uilPQB3i5CXxBtA29GPUPs092At7qiUrAHeR2mAJMHiga9iwGgPXRvtuWA2hRB5M0JlNCTSCEHoqHxHI5VJAYgR+QjuAqIlkG0whpAhznNyNIW50ekaQYmQLQs0kwQjVoDRNte7E2FcBDpCPWFKd1dBAIdRwQafSmzZMXwwo3VX+WWIT4otxBaYddb/pRb5ER2u+DibZMGugZ0SzlTHJPeREwpEK51s3RMyjJHQW5pqyiCtFTBaO0GLTmA1JsNpgfyXQkX5O9c2d1g0cuuSl1G3BoPSIdAQFpuCNLuxXl96B5AFWkSU7WBjVFCFaozJ4ogO6m31jgSCLpDEc+da/eKlmS+VbRA865oJcb27QjoBE51WaaHUdkswC0lhN1sBmXDsAXAg5OLCQJDCQUOIHZhHshzIY7FzWRjEg0HTTapG2tHHCZfwHTXAWSy37Lijmx1Ay3qkdftRfKGrUHEa/lrGqtf8lgENMZHww+JR1AZEUIJFDyMwQViAqpMFm0KatrEetHSW7GtI+evsmYL+iDBgIQyu3LQX0vFbwBP/aFUvBWKV5m4S4RbofhNLbfI/rfA+tk06swTyMluI5UWjELpI2YdkEwFXZKwtfQiBnITDKi1GVAh48xWAiU9pm7QUUgiHrqDQE6lODNOllwnFEUsyEGOrPp1Qa+kVbnu/RWBiHt/RborPVZqLFaaqNUIRbIjDyHEKpIhObkbPu5OIf9JG6ejZcnZkDVeelJOFBor8eVD2a6Obv9Qtm/k1EHqCUmyM1DaWagmMSYKE/ZkRICJLJY4DpVwB14wcyOJANFCWVYg8zqH7RXLQuS9kiJ7jeqtipXFfW0oXe0k1hn8JjxxlPrOU6glVPAVD9CnqacULuRM5G4y/hTCCK8I9gC1SbtYv0qbTd5X+J12wNUMkPC72gHh1OA386ur77TNtvtO964TW5snRkQdvHjeUa9ehL3U3x/UakIZuP/P01xreZdhT1Op13O9ahmExzDkjboNc9SRDFP2MHaH6e6tbvq+ZNMX0QSaH9nEB9VRTsIPWzsd5QSyM9ORTSc8LuyVNt3BXknko4ePeFIX7H7RTlKIVqmht3hK6xNbqc/8QmQROUToQOsTWb2PKkWoG9U710Oc1P0aMeUnBBy8s3XqOIi90lueJIgg3gVWu9dNAuxetxjjdLtH2F059bIt92ivi5q6sIGMu7DBhAsbgkeNsLPtSNnOAW5ydbcSbbtaiVWAO8oXG8SMb08h3iPSNyJ8M4W6ty//pMIfO2vrDfSpdzM9TfTyuEO9O+/4Yvd745cwl6qGMM/iQ71rkafyQC5LiJurPDjl+u6/e/CFGL2qg3MHQS4glYRuZKBHgRDdDnFZ/0ZKAnxnyQfUoP6GfWQM9bF97nFJfj1H5jlcOJEt5wvtEZlf4nIXfG0Liu/ikkScVm1ZuA9AwZx4l4UeyC9QwU0VluIR1ZcqrMkVf1RhF3YX+akgjyWtwLEdK/pTzjuSxKfs6sT7rQn9aDzsJvRpykgTGqG1xexfGEzVa2lvBnsHbSfX+JuaiRGqjtJHWJB4lJKiBTx69ecLisxRvd368z5HqbfG1Z5XpuzO89Wf353n3Z9nJaXVz8lK/YQYn8lKvWart2R1si/0qK70W26n3+k8SJ8xnU7nzr4Zd/a1nX2xkXs7ysWqu98pQEBxPPKpZE9DBW9dHWrqv9PgWEVma3McqpRCbD3Jh2Ml9TP58LCSesfp76x086RyooneHrIcjf3qIE89aapblLDv3NydVnEKPHlk37BGynHeOLIvhmCrMbAs8piKQDp2W/Yt6aXtg8+TUr6dGhJn7r5gPRsSn+WvVKOu4/Dbwenz53coXElZBXXIlGudFH5EEPQPTkL/w3XVpBPDu7HKgTMls7NS+YUA/QOrQ8p50uktGKuf0eKDFdXPYX9cZ5BvYH97t9102+vj1fTqAEHyUjj2xPX3RwlqN8W/P0A4JPKBndTfocebsX9Mj4f7f0aPl0pTr7558dQrBQpcQDuPKsduDxKYcOhmAXWjgej9TsBSmk1Jvr336JhLBn410p5sf5ngZiQlcwF111zgDiNt2pa5Nm/LEbnwdvU+Bl1DCc2S6nKsEjRmoGJcJO0/q4G+x0t1q7d+Wm59WkJESMel088S4QKstKcj8RJVB/aejsST/+1I/LDMu9aZuP/s4QT+/QidRV+H6PvcRB++G3fN8euQ6jHmz4ZUf1rmPx1S4kwJX0ijJQlfUO6FERwcIY3abG2T3ncMrRKt0cpXMCSGmtsnEyeG9OEC9bPvQT0SW32S2Z8ktvogsz/6ipX6O6ciemLsLv1ca3Jh023IwUBmG4OKV77h4uSMrSBmoMdACoeEA3BTJKFbr5oaRpuekTXOjG6mm9GFuWR6Vui1ILhQvJxpSKp0H8gOvGpyj70jxczIpo5Qm3zBKDo1wY9VQ0PolHNcoe3eKhYs2zNVPMMCXt+l5LYxqdjXGGPV6kbIccphiDQ9xVGxm+/Pw+/PareC83NL6fuO0mmT/bloV6dq3yEitLnWu9m/gR319fj/X5/+J4XxdGn37/CQFSnUGmvRRIAopegXeN0ixiTAcmNKP2cMuM8afFrClP2rqxI5mSy1SCu7FjGnFpEtS585ypFDISADsUaIILhnzGYCCrqHPosqtQwWEGwfVpoq0iEmrEFiBGM+LeIu3OT3MSSSDnHSsLsDKWKWL51FG3xQ9sfYeHBM3YGsZTnt+deDqp+i421I9T0v/LMh1bu9fzqk+tycr4dU/8ZDz0PKCalFUKpQhk5fKo7znavnkuP6ypVPv33lqsd5aQT1eX/4r4iI7/XKvV57v5zPnv8fDIQF4XDi4j+H06uV13K84QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+QHBhcQHebnu4UAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAzklEQVRIx+1VSw6FIAxsjffCm1luVk82Lp6QiiCfaN7GSRoslCn9gEQfKuAOW9xwoMQ3tZIDoFRUlYgIIkIikt3Y4gCqSsy/w23bFkfnXHBSxJSk4CKqSsuyUHDinIvkYbzDbBUbpoiQJbdOAERyZi6mJ1dEe/Ksns4nUi3kaYOFJTd2XW0KADEFF8OjyGHt0KttPpcWvPfxe13XE/noRatGYOdfiaDzlvPTESCXmacisG8S/78GoSWfwGzeBmL2Q63YAUErhm7yyz+sD3nsoTDkgFfOHb4AAAAASUVORK5CYII=";
  </script>
  <script>
    // Using a new help.js as the old one would need a full rewrite

    function addTabFunctionality() {
      const tabs = document.querySelectorAll("section.xp-tabs > menu[role=tablist]");

      for (let i = 0; i < tabs.length; i++) {
        const tab = tabs[i];

        const tabButtons = tab.querySelectorAll("menu[role=tablist] > button");

        tabButtons.forEach((btn) =>
          btn.addEventListener("click", (e) => {
            e.preventDefault();

            tabButtons.forEach((button) => {
              if (
                button.getAttribute("aria-controls") ===
                e.target.getAttribute("aria-controls")
              ) {
                button.setAttribute("aria-selected", true);
                openTab(e, tab);
              } else {
                button.setAttribute("aria-selected", false);
              }
            });
          })
        );
      }
    }

    function openTab(event, tab) {
      const articles = tab.parentNode.querySelectorAll('[role="tabpanel"]');
      articles.forEach((p) => {
        p.setAttribute("hidden", true);
      });
      const article = tab.parentNode.querySelector(
        `[role="tabpanel"]#${event.target.getAttribute("aria-controls")}`
      );
      article.removeAttribute("hidden");
    }



    function show_help() {
      const $w = new $FormToolWindow("About XP Paint");

      let aboutWindowBody = `
	<div id="HelpTopPanel" style="background-color: white; display: flex;">
		<div id="HideButton" style="padding: 8px;">
			<div><img src="${HELP_HIDE_BUTTON_BASE64}" style="width: 32px; height: 32px; image-rendering: crips-edges"></div>
			<div>Hide</div>
		</div>
		<div id="BackButton" style="padding: 8px;">
			<div><img src="${HELP_BACK_BUTTON_BASE64}" style="width: 32px; height: 32px; image-rendering: crips-edges"></div>
			<div>Back</div>
		</div>
		<div id="ForwardButton" style="padding: 8px;">
			<div><img src="${HELP_FORWARD_BUTTON_BASE64}" style="width: 32px; height: 32px; image-rendering: crips-edges"></div>
			<div>Forward</div>
		</div>
		<div id="OptionsButton" style="padding: 8px;">
			<div><img src="${HELP_OPTIONS_BUTTON_BASE64}" style="width: 32px; height: 32px; image-rendering: crips-edges"></div>
			<div>Options</div>
		</div>
	</div>

	<div id="HelpBottomPanel" style="display: flex">
		<div id="HelpLeftPanel" style="margin-top: 12px;">
			<section class="xp-tabs" style="width: 250px;">
				<menu role="tablist" aria-label="Sample Tabs">
					<button role="tab" aria-selected="true" aria-controls="tab-A">Contents</button>
					<button role="tab" aria-controls="tab-B">Index</button>
					<button role="tab" aria-controls="tab-C">Search</button>
				</menu>
			
				<article role="tabpanel" id="tab-A" style="padding: 10px; margin-right: 4px; height: 360px">
					<div style="border: 1px solid gray; background-color: white;">
						<div style="margin: 1px; border-top: 1px solid gray; border-left: 1px solid gray; height: 358px">
							<div style="padding-left: 3px;">To be implemented</div>
						</div>
					</div>
				</article>

				<article role="tabpanel" id="tab-B" hidden="true" style="padding: 10px; margin-right: 4px; height: 360px">
					<div style="border: 1px solid gray; background-color: white;">
						<div style="margin: 1px; border-top: 1px solid gray; border-left: 1px solid gray; height: 358px">
							<div style="padding-left: 3px;">This isn't yet implemented either</div>
						</div>
					</div>
				</article>

				<article role="tabpanel" id="tab-C" hidden="true" style="padding: 10px; margin-right: 4px; height: 360px">
					<div style="border: 1px solid gray; background-color: white;">
						<div style="margin: 1px; border-top: 1px solid gray; border-left: 1px solid gray; height: 358px">
							<div style="padding-left: 3px;">Also not implemented</div>
						</div>
					</div>
				</article>
			</section>
		</div>

		<div id="HelpRightPanel" style="width: 400px; min-height: 400px; border-top: 2px solid gray; border-left: 2px solid gray; background-color: white; padding: 10px">
			<h1 style="font-size: 18px">XP Paint Overview</h1>
			<p>
				XP Paint is a fork of the JS Paint application. It has a different goal than JS Paint in that
				it is intended to be fully usable offline and as close to the original XP version of paint
				as possible. It removes some features from JS Paint to keep it lighter and available to use
				offline, and, unlike JS Paint, XP Paint is contained within a single HTML file, making it
				highly portable and very easy to embed within web tech. Since it is a single HTML file, you
				can actually save this webpage and you'll have a complete copy of XP Paint available.
			</p>

			<p>
				Currently this page does not actually contain all of the original help functionality of
				the Paint within Windows XP, since the help topics are barely used and there is a lot of
				work involved in making a copy of them, but if someone wants to port all the text over
				and the functionality, then by all means do a pull request and I'll add in a credit
				for you!
			</p>
		</div>
	</div>
	`;

      const $fieldset = $(E("div"))
        .appendTo($w.$main);

      $w.$content.attr("style", "margin: 0px; padding: 0px; padding-left: 3px; padding-right: 3px");

      $fieldset.append(aboutWindowBody);

      addTabFunctionality();
    }
  </script>
  <script>
    (() => {

      const looksLikeChrome = !!(window.chrome && (chrome.loadTimes || chrome.csi));
      // NOTE: Microsoft Edge includes window.chrome.app
      // (also this browser detection logic could likely use some more nuance)

      window.menus = {
        "&File": [{
            item: "&New",
            shortcut: "Ctrl+Alt+N", // Ctrl+N opens a new browser window
            speech_recognition: [],
            action: () => {
              file_new();
            },
            description: "Creates a new document.",
          },
          {
            item: "&Open",
            shortcut: "Ctrl+O",
            speech_recognition: [],
            action: () => {
              file_open();
            },
            description: "Opens an existing document.",
          },
          {
            item: "&Save",
            shortcut: "Ctrl+S",
            speech_recognition: [],
            action: () => {
              file_save();
            },
            description: "Saves the active document.",
          },
          {
            item: "Save &As",
            shortcut: "Ctrl+Shift+S",
            speech_recognition: [],
            // in mspaint, no shortcut is listed; it supports F12 (but in a browser that opens the dev tools)
            // it doesn't support Ctrl+Shift+S but that's a good & common modern shortcut
            action: () => {
              file_save_as();
            },
            description: "Saves the active document with a new name.",
          },
          MENU_DIVIDER,
          {
            item: "Print Pre&view",
            speech_recognition: [],
            action: () => {
              print();
            },
            description: "Prints the active document and sets printing options.",
            //description: "Displays full pages.",
          },
          {
            item: "Page Se&tup",
            speech_recognition: [],
            action: () => {
              print();
            },
            description: "Prints the active document and sets printing options.",
            //description: "Changes the page layout.",
          },
          {
            item: "&Print",
            shortcut: "Ctrl+P",
            speech_recognition: [],
            action: () => {
              print();
            },
            description: "Prints the active document and sets printing options.",
          },
          MENU_DIVIDER,
          {
            item: "Set As &Wallpaper (Tiled)",
            speech_recognition: [],
            action: () => {
              set_as_wallpaper_tiled();
            },
            description: "Tiles this bitmap as the desktop background.",
          },
          {
            item: "Set As Wallpaper (&Centered)", // in mspaint it's Wa&llpaper
            speech_recognition: [],
            action: () => {
              set_as_wallpaper_centered();
            },
            description: "Centers this bitmap as the desktop background.",
          },
          MENU_DIVIDER,
          {
            item: "Recent File",
            enabled: false, // @TODO for desktop app
            description: "",
          },
          MENU_DIVIDER,
          {
            item: "E&xit",
            // shortcut: "Alt+F4", // closes browser window
            speech_recognition: [],
            action: () => {
              close();
            },
            description: "Quits Paint.",
          }
        ],
        "&Edit": [{
            item: "&Undo",
            shortcut: "Ctrl+Z",
            speech_recognition: [],
            enabled: () => undos.length >= 1,
            action: () => {
              undo();
            },
            description: "Undoes the last action.",
          },
          {
            item: "&Repeat",
            shortcut: "F4",
            speech_recognition: [],
            enabled: () => redos.length >= 1,
            action: () => {
              redo();
            },
            description: "Redoes the previously undone action.",
          },
          {
            item: "&History",
            shortcut: "Ctrl+Shift+Y",
            speech_recognition: [],
            action: () => {
              show_document_history();
            },
            description: "Shows the document history and lets you navigate to states not accessible with Undo or Repeat.",
          },
          MENU_DIVIDER,
          {
            item: "Cu&t",
            shortcut: "Ctrl+X",
            speech_recognition: [],
            enabled: () =>
              // @TODO: support cutting text with this menu item as well (e.g. for the text tool)
              !!selection,
            action: () => {
              edit_cut(true);
            },
            description: "Cuts the selection and puts it on the Clipboard.",
          },
          {
            item: "&Copy",
            shortcut: "Ctrl+C",
            speech_recognition: [],
            enabled: () =>
              // @TODO: support copying text with this menu item as well (e.g. for the text tool)
              !!selection,
            action: () => {
              edit_copy(true);
            },
            description: "Copies the selection and puts it on the Clipboard.",
          },
          {
            item: "&Paste",
            shortcut: "Ctrl+V",
            speech_recognition: [],
            enabled: () =>
              // @TODO: disable if nothing in clipboard or wrong type (if we can access that)
              true,
            action: () => {
              edit_paste(true);
            },
            description: "Inserts the contents of the Clipboard.",
          },
          {
            item: "C&lear Selection",
            shortcut: "Del",
            speech_recognition: [],
            enabled: () => !!selection,
            action: () => {
              delete_selection();
            },
            description: "Deletes the selection.",
          },
          {
            item: "Select &All",
            shortcut: "Ctrl+A",
            speech_recognition: [],
            action: () => {
              select_all();
            },
            description: "Selects everything.",
          },
          MENU_DIVIDER,
          {
            item: "C&opy To...",
            speech_recognition: [],
            enabled: () => !!selection,
            action: () => {
              save_selection_to_file();
            },
            description: "Copies the selection to a file.",
          },
          {
            item: "Paste &From...",
            speech_recognition: [],
            action: () => {
              paste_from_file_select_dialog();
            },
            description: "Pastes a file into the selection.",
          }
        ],
        "&View": [{
            item: "&Tool Box",
            // shortcut: "Ctrl+T", // opens a new browser tab
            speech_recognition: [],
            checkbox: {
              toggle: () => {
                $toolbox.toggle();
              },
              check: () => $toolbox.is(":visible"),
            },
            description: "Shows or hides the tool box.",
          },
          {
            item: "&Color Box",
            // shortcut: "Ctrl+L", // focuses browser address bar
            speech_recognition: [],
            checkbox: {
              toggle: () => {
                $colorbox.toggle();
              },
              check: () => $colorbox.is(":visible"),
            },
            description: "Shows or hides the color box.",
          },
          {
            item: "&Status Bar",
            speech_recognition: [],
            checkbox: {
              toggle: () => {
                $status_area.toggle();
              },
              check: () => $status_area.is(":visible"),
            },
            description: "Shows or hides the status bar.",
          },
          {
            item: "T&ext Toolbar",
            speech_recognition: [],
            enabled: false, // @TODO: toggle fonts box
            checkbox: {},
            description: "Shows or hides the text toolbar.",
          },
          MENU_DIVIDER,
          {
            item: "&Zoom",
            submenu: [{
                item: "&Normal Size",
                // shortcut: "Ctrl+PgUp", // cycles thru browser tabs
                speech_recognition: [],
                description: "Zooms the picture to 100%.",
                enabled: () => magnification !== 1,
                action: () => {
                  set_magnification(1);
                },
              },
              {
                item: "&Large Size",
                // shortcut: "Ctrl+PgDn", // cycles thru browser tabs
                speech_recognition: [],
                description: "Zooms the picture to 400%.",
                enabled: () => magnification !== 4,
                action: () => {
                  set_magnification(4);
                },
              },
              {
                item: "Zoom To &Window",
                speech_recognition: [],
                description: "Zooms the picture to fit within the view.",
                action: () => {
                  const rect = $canvas_area[0].getBoundingClientRect();
                  const margin = 30; // leave a margin so scrollbars won't appear
                  let mag = Math.min(
                    (rect.width - margin) / canvas.width,
                    (rect.height - margin) / canvas.height,
                  );
                  // round to an integer percent for the View > Zoom > Custom... dialog, which shows non-integers as invalid
                  mag = Math.floor(100 * mag) / 100;
                  set_magnification(mag);
                },
              },
              {
                item: "C&ustom...",
                description: "Zooms the picture.",
                speech_recognition: [],
                action: () => {
                  show_custom_zoom_window();
                },
              },
              MENU_DIVIDER,
              {
                item: "Show &Grid",
                shortcut: "Ctrl+G",
                speech_recognition: [],
                enabled: () => magnification >= 4,
                checkbox: {
                  toggle: toggle_grid,
                  check: () => show_grid,
                },
                description: "Shows or hides the grid.",
              },
              {
                item: "Show T&humbnail",
                speech_recognition: [],
                enabled: false, // @TODO: implement Show Thumbnail
                checkbox: {},
                description: "Shows or hides the thumbnail view of the picture.",
              }
            ]
          },
          {
            item: "&View Bitmap",
            shortcut: "Ctrl+F",
            speech_recognition: [],
            action: () => {
              view_bitmap();
            },
            description: "Displays the entire picture.",
          }
        ],
        "&Image": [
          // @TODO: speech recognition: terms that apply to selection
          {
            item: "&Flip/Rotate",
            // shortcut: "Ctrl+R", // reloads browser tab
            speech_recognition: [],
            action: () => {
              image_flip_and_rotate();
            },
            description: "Flips or rotates the picture or a selection.",
          },
          {
            item: "&Stretch/Skew",
            // shortcut: "Ctrl+W", // closes browser tab
            speech_recognition: [],
            action: () => {
              image_stretch_and_skew();
            },
            description: "Stretches or skews the picture or a selection.",
          },
          {
            item: "&Invert Colors",
            shortcut: "Ctrl+I",
            speech_recognition: [],
            action: () => {
              image_invert_colors();
            },
            description: "Inverts the colors of the picture or a selection.",
          },
          {
            item: "&Attributes...",
            shortcut: "Ctrl+E",
            speech_recognition: [],
            action: () => {
              image_attributes();
            },
            description: "Changes the attributes of the picture.",
          },
          {
            item: "&Clear Image",
            shortcut: looksLikeChrome ? undefined : "Ctrl+Shift+N", // opens incognito window in chrome
            speech_recognition: [],
            // (mspaint says "Ctrl+Shft+N")
            action: () => {
              !selection && clear();
            },
            enabled: () => !selection,
            description: "Clears the picture.",
            // action: ()=> {
            // 	if (selection) {
            // 		delete_selection();
            // 	} else {
            // 		clear();
            // 	}
            // },
            // mspaint says "Clears the picture or selection.", but grays out the option when there's a selection
          },
          {
            item: "&Draw Opaque",
            speech_recognition: [],
            checkbox: {
              toggle: () => {
                tool_transparent_mode = !tool_transparent_mode;
                $G.trigger("option-changed");
              },
              check: () => !tool_transparent_mode,
            },
            description: "Makes the current selection either opaque or transparent.",
          }
        ],
        "&Colors": [{
            item: "&Edit Colors...",
            speech_recognition: [],
            action: () => {
              $colorbox.edit_last_color();
            },
            description: "Creates a new color.",
          },
          {
            item: "&Get Colors",
            speech_recognition: [],
            action: () => {
              get_FileList_from_file_select_dialog((files) => {
                const file = files[0];
                Palette.load(file, (err, new_palette) => {
                  if (err) {
                    show_error_message("This file is not in a format that paint recognizes, or no colors were found.");
                  } else {
                    palette = new_palette;
                    $colorbox.rebuild_palette();
                  }
                });
              });
            },
            description: "Uses a previously saved palette of colors.",
          },
          {
            item: "&Save Colors",
            speech_recognition: [],
            action: () => {
              const blob = new Blob([JSON.stringify(palette)], {
                type: "application/json"
              });
              sanity_check_blob(blob, () => {
                saveAs(blob, "colors.json");
              });
            },
            description: "Saves the current palette of colors to a file.",
          }
        ],
        "&Help": [{
            item: "&Help Topics",
            speech_recognition: [],
            action: () => {
              show_help();
            },
            description: "Displays Help for the current task or command.",
          },
          MENU_DIVIDER,
          {
            item: "&About Paint",
            speech_recognition: [],
            action: () => {
              show_about_paint();
            },
            description: "Displays information about this application.",
            //description: "Displays program information, version number, and copyright.",
          }
        ],
        "E&xtras": [{
            item: "&History",
            shortcut: "Ctrl+Shift+Y",
            speech_recognition: [],
            action: () => {
              show_document_history();
            },
            description: "Shows the document history and lets you navigate to states not accessible with Undo or Repeat.",
          },
          {
            item: "&Render History As GIF",
            shortcut: "Ctrl+Shift+G",
            speech_recognition: [],
            action: () => {
              render_history_as_gif();
            },
            description: "Creates an animation from the document history.",
          },
          MENU_DIVIDER,
          {
            item: "Manage Storage",
            speech_recognition: [],
            action: () => {
              manage_storage();
            },
            description: "Manages storage of previously created or opened pictures.",
          },
          MENU_DIVIDER,
          {
            item: "&Pride Color Palette",
            speech_recognition: [],
            action: () => {
              palette = ["#000000", "#784f17", "#fe0000", "#fd8c00", "#ffe500", "#119f0b", "#0644b3", "#c22edc", "#5adafd", "#febdd3", "#ffffff", "#febdd3", "#5adafd", "#d60270", "#000000", "#784f17", "#fe0000", "#fd8c00", "#ffe500", "#119f0b", "#0644b3", "#c22edc", "#5adafd", "#febdd3", "#ffffff", "#febdd3", "#5adafd", "#0038a8"];
              $colorbox.rebuild_palette();
            },
            description: "Pride flag color palette!",
          },
        ],
      };

    })();
  </script>
  <script>
    const default_magnification = 1;
    const default_tool = get_tool_by_name("Pencil");

    const default_canvas_width = 800;
    const default_canvas_height = 600;
    let my_canvas_width = default_canvas_width;
    let my_canvas_height = default_canvas_height;

    let aliasing = true;
    let transparency = false;
    let monochrome = false;

    let magnification = default_magnification;
    let return_to_magnification = 4;

    const canvas = make_canvas();
    canvas.classList.add("main-canvas");
    const ctx = canvas.ctx;

    const default_palette = [
      "#000000", "#787878", "#790300", "#757A01", "#007902", "#007778", "#0A0078", "#7B0077", "#767A38", "#003637", "#286FFE", "#083178", "#4C00FE", "#783B00",
      "#FFFFFF", "#BBBBBB", "#FF0E00", "#FAFF08", "#00FF0B", "#00FEFF", "#3400FE", "#FF00FE", "#FBFF7A", "#00FF7B", "#76FEFF", "#8270FE", "#FF0677", "#FF7D36",
    ];
    let palette = default_palette;
    let polychrome_palette = palette;
    let monochrome_palette = make_monochrome_palette();

    // declared like this for Cypress tests
    window.default_brush_shape = "circle";
    window.default_brush_size = 4;
    window.default_eraser_size = 8;
    window.default_airbrush_size = 9;
    window.default_pencil_size = 1;
    window.default_stroke_size = 1; // applies to lines, curves, shape outlines
    // declared like this for Cypress tests
    window.brush_shape = default_brush_shape;
    window.brush_size = default_brush_size
    window.eraser_size = default_eraser_size;
    window.airbrush_size = default_airbrush_size;
    window.pencil_size = default_pencil_size;
    window.stroke_size = default_stroke_size; // applies to lines, curves, shape outlines
    let tool_transparent_mode = false;

    let stroke_color;
    let fill_color;
    let stroke_color_k = "foreground"; // enum of "foreground", "background", "ternary"
    let fill_color_k = "background"; // enum of "foreground", "background", "ternary"

    let selected_tool = default_tool;
    let selected_tools = [selected_tool];
    let return_to_tools = [selected_tool];
    window.colors = { // declared like this for Cypress tests
      foreground: "",
      background: "",
      ternary: "",
    };

    let selection; //the one and only OnCanvasSelection
    let textbox; //the one and only OnCanvasTextBox
    let helper_layer; //the OnCanvasHelperLayer for the grid and tool previews
    let show_grid = false;
    let text_tool_font = {
      family: '"Arial"', // should be an exact value detected by Font Detective
      size: 12,
      line_scale: 20 / 12,
      bold: false,
      italic: false,
      underline: false,
      vertical: false,
      color: "",
      background: "",
    };

    let root_history_node = make_history_node({
      name: "App Not Loaded Properly - Please send a bug report."
    }); // will be replaced
    let current_history_node = root_history_node;
    let history_node_to_cancel_to = null;
    /** array of history nodes */
    let undos = [];
    /** array of history nodes */
    let redos = [];

    let file_name;
    let document_file_path;
    let saved = true;

    /** works in canvas coordinates */
    let pointer;
    /** works in canvas coordinates */
    let pointer_start;
    /** works in canvas coordinates */
    let pointer_previous;

    let pointer_active = false;
    let pointer_type, pointer_buttons;
    let reverse;
    let ctrl;
    let button;
    let pointer_over_canvas = false;
    let update_helper_layer_on_pointermove_active = false;

    /** works in client coordinates */
    let pointers = [];

    const update_from_url_params = () => {
      if (location.hash.match(/eye-gaze-mode/i)) {
        if (!$("body").hasClass("eye-gaze-mode")) {
          $("body").addClass("eye-gaze-mode");
          $G.triggerHandler("eye-gaze-mode-toggled");
          $G.triggerHandler("theme-load"); // signal layout change
        }
      } else {
        if ($("body").hasClass("eye-gaze-mode")) {
          $("body").removeClass("eye-gaze-mode");
          $G.triggerHandler("eye-gaze-mode-toggled");
          $G.triggerHandler("theme-load"); // signal layout change
        }
      }

      if (location.hash.match(/vertical-color-box-mode|eye-gaze-mode/i)) {
        if (!$("body").hasClass("vertical-color-box-mode")) {
          $("body").addClass("vertical-color-box-mode");
          $G.triggerHandler("vertical-color-box-mode-toggled");
          $G.triggerHandler("theme-load"); // signal layout change
        }
      } else {
        if ($("body").hasClass("vertical-color-box-mode")) {
          $("body").removeClass("vertical-color-box-mode");
          $G.triggerHandler("vertical-color-box-mode-toggled");
          $G.triggerHandler("theme-load"); // signal layout change
        }
      }

      if (location.hash.match(/speech-recognition-mode/i)) {
        window.enable_speech_recognition && enable_speech_recognition();
      } else {
        window.disable_speech_recognition && disable_speech_recognition();
      }
    };
    update_from_url_params();
    $G.on("hashchange popstate change-url-params", update_from_url_params);

    // handle backwards compatibility URLs
    if (location.search.match(/eye-gaze-mode/)) {
      change_url_param("eye-gaze-mode", true, {
        replace_history_state: true
      });
      update_from_url_params();
    }
    if (location.search.match(/vertical-colors?-box/)) {
      change_url_param("vertical-color-box", true, {
        replace_history_state: true
      });
      update_from_url_params();
    }

    const $app = $(E("div")).addClass("jspaint").appendTo("body");

    const $V = $(E("div")).addClass("vertical").appendTo($app);
    const $H = $(E("div")).addClass("horizontal").appendTo($V);

    const $canvas_area = $(E("div")).addClass("canvas-area").appendTo($H);

    const $canvas = $(canvas).appendTo($canvas_area);
    $canvas.attr("touch-action", "none");
    let canvas_bounding_client_rect = canvas.getBoundingClientRect(); // cached for performance, updated later
    const getRect = () => ({
      left: 0,
      top: 0,
      width: canvas.width,
      height: canvas.height,
      right: canvas.width,
      bottom: canvas.height
    })
    const $canvas_handles = $Handles($canvas_area, getRect, {
      outset: 4,
      get_offset_left: () => parseFloat($canvas_area.css("padding-left")) + 1,
      get_offset_top: () => parseFloat($canvas_area.css("padding-top")) + 1,
      size_only: true,
    });
    // hack: fix canvas handles causing document to scroll when selecting/deselecting
    // by overriding these methods
    $canvas_handles.hide = () => {
      $canvas_handles.css({
        opacity: 0,
        pointerEvents: "none"
      });
    };
    $canvas_handles.show = () => {
      $canvas_handles.css({
        opacity: "",
        pointerEvents: ""
      });
    };

    const $top = $(E("div")).addClass("component-area").prependTo($V);
    const $bottom = $(E("div")).addClass("component-area").appendTo($V);
    const $left = $(E("div")).addClass("component-area").prependTo($H);
    const $right = $(E("div")).addClass("component-area").appendTo($H);

    const $status_area = $(E("div")).addClass("status-area").appendTo($V);
    const $status_text = $(E("div")).addClass("status-text").appendTo($status_area);
    const $status_position = $(E("div")).addClass("status-coordinates").appendTo($status_area);
    const $status_size = $(E("div")).addClass("status-coordinates").appendTo($status_area);

    const $news_indicator = $(`
	<a class='news-indicator' href='#project-news'>
		<img src='images/winter/present.png' width='24' height='22' alt=''/>
		<span class='not-the-icon'>
			<strong>New!</strong>&nbsp;Holiday theme, multitouch panning, and revamped history
		</span>
	</a>
`);
    $news_indicator.on("click auxclick", (event) => {
      event.preventDefault();
      show_news();
    });
    // @TODO: use localstorage to show until clicked, if available
    // and show for a longer period of time after the update, if available
    if (Date.now() < Date.parse("Jan 5 2020 23:42:42 GMT-0500")) {
      $status_area.append($news_indicator);
    }

    $status_text.default = () => {
      $status_text.text("For Help, click Help Topics on the Help Menu.");
    };
    $status_text.default();

    // menu bar
    let menu_bar_outside_frame = false;
    if (frameElement) {
      try {
        if (parent.$MenuBar) {
          $MenuBar = parent.$MenuBar;
          menu_bar_outside_frame = true;
        }
        // eslint-disable-next-line no-empty
      } catch (e) {}
    }
    const $menu_bar = $MenuBar(menus);
    if (menu_bar_outside_frame) {
      $menu_bar.insertBefore(frameElement);
    } else {
      $menu_bar.prependTo($V);
    }

    $menu_bar.on("info", (_event, info) => {
      $status_text.text(info);
    });
    $menu_bar.on("default-info", () => {
      $status_text.default();
    });
    // </menu bar>

    let $toolbox = $ToolBox(tools);
    // let $toolbox2 = $ToolBox(extra_tools, true);//.hide();
    // Note: a second $ToolBox doesn't work because they use the same tool options (which could be remedied)
    // If there's to be extra tools, they should probably get a window, with different UI
    // so it can display names of the tools, and maybe authors and previews (and not necessarily icons)

    let $colorbox = $ColorBox($("body").hasClass("vertical-color-box-mode"));

    $G.on("vertical-color-box-mode-toggled", () => {
      $colorbox.destroy();
      $colorbox = $ColorBox($("body").hasClass("vertical-color-box-mode"));
      prevent_selection($colorbox);
    });
    $G.on("eye-gaze-mode-toggled", () => {
      $colorbox.destroy();
      $colorbox = $ColorBox($("body").hasClass("vertical-color-box-mode"));
      prevent_selection($colorbox);

      $toolbox.destroy();
      $toolbox = $ToolBox(tools);
      prevent_selection($toolbox);

      // $toolbox2.destroy();
      // $toolbox2 = $ToolBox(extra_tools, true);
      // prevent_selection($toolbox2);
    });


    $canvas_area.on("user-resized", (_event, _x, _y, unclamped_width, unclamped_height) => {
      resize_canvas_and_save_dimensions(unclamped_width, unclamped_height);
    });

    $G.on("resize", () => { // for browser zoom, and in-app zoom of the canvas
      update_canvas_rect();
      update_disable_aa();
    });
    $canvas_area.on("scroll", () => {
      update_canvas_rect();
    });
    $canvas_area.on("resize", () => {
      update_magnified_canvas_size();
    });

    $("body").on("dragover dragenter", e => {
      const dt = e.originalEvent.dataTransfer;
      const has_files = Array.from(dt.types).includes("Files");
      if (has_files) {
        e.preventDefault();
      }
    }).on("drop", e => {
      if (e.isDefaultPrevented()) {
        return;
      }
      const dt = e.originalEvent.dataTransfer;
      const has_files = Array.from(dt.types).includes("Files");
      if (has_files) {
        e.preventDefault();
        if (dt && dt.files && dt.files.length) {
          open_from_FileList(dt.files, "dropped");
        }
      }
    });

    $G.on("keydown", e => {
      if (e.isDefaultPrevented()) {
        return;
      }
      if (e.keyCode === 27) { // Esc
        if (textbox && textbox.$editor.is(e.target)) {
          deselect();
        }
      }
      if (
        // Ctrl+Shift+Y
        (e.ctrlKey || e.metaKey) && e.shiftKey && !e.altKey &&
        String.fromCharCode(e.keyCode).toUpperCase() === "Y"
      ) {
        show_document_history();
        e.preventDefault();
        return;
      }
      // @TODO: return if menus/menubar focused or focus in dialog window
      // or maybe there's a better way to do this that works more generally
      // maybe it should only handle the event if document.activeElement is the body or html element?
      // (or $app could have a tabIndex and no focus style and be focused under various conditions,
      // if that turned out to make more sense for some reason)
      if (
        e.target instanceof HTMLInputElement ||
        e.target instanceof HTMLTextAreaElement
      ) {
        return;
      }

      // @TODO: preventDefault in all cases where the event is handled
      // also, ideally check that modifiers *aren't* pressed
      // probably best to use a library at this point!

      if (selection) {
        const nudge_selection = (delta_x, delta_y) => {
          selection.x += delta_x;
          selection.y += delta_y;
          selection.position();
        };
        switch (e.keyCode) {
          case 37: // Left
            nudge_selection(-1, 0);
            e.preventDefault();
            break;
          case 39: // Right
            nudge_selection(+1, 0);
            e.preventDefault();
            break;
          case 40: // Down
            nudge_selection(0, +1);
            e.preventDefault();
            break;
          case 38: // Up
            nudge_selection(0, -1);
            e.preventDefault();
            break;
        }
      }

      if (e.keyCode === 27) { //Escape
        if (selection) {
          deselect();
        } else {
          cancel();
        }
        window.stopSimulatingGestures && window.stopSimulatingGestures();
        window.trace_and_sketch_stop && window.trace_and_sketch_stop();
      } else if (e.keyCode === 13) { //Enter
        if (selection) {
          deselect();
        }
      } else if (e.keyCode === 115) { //F4
        redo();
      } else if (e.keyCode === 46) { //Delete
        delete_selection();
      } else if (e.keyCode === 107 || e.keyCode === 109) { // Numpad Plus and Minus
        const plus = e.keyCode === 107;
        const minus = e.keyCode === 109;
        const delta = plus - minus; // const delta = +plus++ -minus--; // Δ = ±±±±

        if (selection) {
          selection.scale(2 ** delta);
        } else {
          if (selected_tool.name === "Brush") {
            brush_size = Math.max(1, Math.min(brush_size + delta, 500));
          } else if (selected_tool.name === "Eraser/Color Eraser") {
            eraser_size = Math.max(1, Math.min(eraser_size + delta, 500));
          } else if (selected_tool.name === "Airbrush") {
            airbrush_size = Math.max(1, Math.min(airbrush_size + delta, 500));
          } else if (selected_tool.name === "Pencil") {
            pencil_size = Math.max(1, Math.min(pencil_size + delta, 50));
          } else if (selected_tool.name.match(/Line|Curve|Rectangle|Ellipse|Polygon/)) {
            stroke_size = Math.max(1, Math.min(stroke_size + delta, 500));
          }

          $G.trigger("option-changed");
          if (button !== undefined && pointer) { // pointer may only be needed for tests
            selected_tools.forEach((selected_tool) => {
              tool_go(selected_tool);
            });
          }
          update_helper_layer();
        }
        e.preventDefault();
        return;
      } else if (e.ctrlKey || e.metaKey) {
        const key = String.fromCharCode(e.keyCode).toUpperCase();
        if (textbox) {
          switch (key) {
            case "A":
            case "Z":
            case "Y":
            case "I":
            case "B":
            case "U":
              // Don't prevent the default. Allow text editing commands.
              return;
          }
        }
        switch (e.keyCode) {
          case 188: // , <
          case 219: // [ {
            rotate(-TAU / 4);
            $canvas_area.trigger("resize");
            break;
          case 190: // . >
          case 221: // ] }
            rotate(+TAU / 4);
            $canvas_area.trigger("resize");
            break;
        }
        switch (key) {
          case "Z":
            e.shiftKey ? redo() : undo();
            break;
          case "Y":
            // Ctrl+Shift+Y handled above
            redo();
            break;
          case "G":
            e.shiftKey ? render_history_as_gif() : toggle_grid();
            break;
          case "F":
            view_bitmap();
            break;
          case "O":
            file_open();
            break;
          case "N":
            e.shiftKey ? clear() : file_new();
            break;
          case "S":
            e.shiftKey ? file_save_as() : file_save();
            break;
          case "A":
            select_all();
            break;
          case "I":
            image_invert_colors();
            break;
          case "E":
            image_attributes();
            break;
          default:
            return; // don't preventDefault
        }
        e.preventDefault();
      }
    });
    $G.on("cut copy paste", e => {
      if (e.isDefaultPrevented()) {
        return;
      }
      if (
        document.activeElement instanceof HTMLInputElement ||
        document.activeElement instanceof HTMLTextAreaElement ||
        !window.getSelection().isCollapsed
      ) {
        // Don't prevent cutting/copying/pasting within inputs or textareas, or if there's a selection
        return;
      }

      e.preventDefault();
      const cd = e.originalEvent.clipboardData || window.clipboardData;
      if (!cd) {
        return;
      }

      if (e.type === "copy" || e.type === "cut") {
        if (selection && selection.canvas) {
          const do_sync_clipboard_copy_or_cut = () => {
            // works only for pasting within a jspaint instance
            const data_url = selection.canvas.toDataURL();
            cd.setData("text/x-data-uri; type=image/png", data_url);
            cd.setData("text/uri-list", data_url);
            cd.setData("URL", data_url);
            if (e.type === "cut") {
              delete_selection({
                name: "Cut",
                icon: get_help_folder_icon("p_cut.png"),
              });
            }
          };
          if (!navigator.clipboard || !navigator.clipboard.write) {
            return do_sync_clipboard_copy_or_cut();
          }
          try {
            if (e.type === "cut") {
              edit_cut();
            } else {
              edit_copy();
            }
          } catch (e) {
            do_sync_clipboard_copy_or_cut();
          }
        }
      } else if (e.type === "paste") {
        for (const item of cd.items) {
          if (item.type.match(/^text\/(?:x-data-uri|uri-list|plain)|URL$/)) {
            item.getAsString(text => {
              const uris = get_URIs(text);
              if (uris.length > 0) {
                load_image_from_URI(uris[0], (error, img) => {
                  if (error) {
                    return show_resource_load_error_message(error);
                  }
                  paste(img);
                });
              } else {
                show_error_message("The information on the Clipboard can't be inserted into Paint.");
              }
            });
            break;
          } else if (item.type.match(/^image\//)) {
            paste_image_from_file(item.getAsFile());
            break;
          }
        }
      }
    });

    reset_file();
    reset_colors();
    reset_canvas_and_history(); // (with newly reset colors)
    set_magnification(default_magnification);

    // this is synchronous for now, but @TODO: handle possibility of loading a document before callback
    // when switching to asynchronous storage, e.g. with localforage
    storage.get({
      width: default_canvas_width,
      height: default_canvas_height,
    }, (err, stored_values) => {
      if (err) {
        return;
      }
      my_canvas_width = stored_values.width;
      my_canvas_height = stored_values.height;

      make_or_update_undoable({
        match: (history_node) => history_node.name === "New Document",
        name: "Resize New Document Canvas",
        icon: get_help_folder_icon("p_stretch_both.png"),
      }, () => {
        canvas.width = Math.max(1, my_canvas_width);
        canvas.height = Math.max(1, my_canvas_height);
        ctx.disable_image_smoothing();
        if (!transparency) {
          ctx.fillStyle = colors.background;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        $canvas_area.trigger("resize");
      });
    });

    if (window.document_file_path_to_open) {
      open_from_file_path(document_file_path_to_open, err => {
        if (err) {
          return show_error_message(`Failed to open file ${document_file_path_to_open}`, err);
        }
      });
    }

    const lerp = (a, b, b_ness) => a + (b - a) * b_ness;

    const color_ramp = (num_colors, start_hsla, end_hsla) =>
      Array(num_colors).fill().map((_undefined, index, array) =>
        `hsla(${
			lerp(start_hsla[0], end_hsla[0], index/array.length)
		}deg, ${
			lerp(start_hsla[1], end_hsla[1], index/array.length)
		}%, ${
			lerp(start_hsla[2], end_hsla[2], index/array.length)
		}%, ${
			lerp(start_hsla[3], end_hsla[3], index/array.length)
		}%)`
      );

    const update_palette_from_theme = () => {
      if (get_theme() === "winter.css") {
        const make_stripe_patterns = (reverse) => [
          make_stripe_pattern(reverse, [
            "hsl(166, 93%, 38%)",
            "white",
          ]),
          make_stripe_pattern(reverse, [
            "white",
            "hsl(355, 78%, 46%)",
          ]),
          make_stripe_pattern(reverse, [
            "hsl(355, 78%, 46%)",
            "white",
            "white",
            "hsl(355, 78%, 46%)",
            "hsl(355, 78%, 46%)",
            "hsl(355, 78%, 46%)",
            "white",
            "white",
            "hsl(355, 78%, 46%)",
            "white",
          ], 2),
          make_stripe_pattern(reverse, [
            "hsl(166, 93%, 38%)",
            "white",
            "white",
            "hsl(166, 93%, 38%)",
            "hsl(166, 93%, 38%)",
            "hsl(166, 93%, 38%)",
            "white",
            "white",
            "hsl(166, 93%, 38%)",
            "white",
          ], 2),
          make_stripe_pattern(reverse, [
            "hsl(166, 93%, 38%)",
            "white",
            "hsl(355, 78%, 46%)",
            "white",
          ], 2),
        ];
        palette = [
          "black",
          // green
          "hsl(91, 55%, 81%)",
          "hsl(142, 57%, 64%)",
          "hsl(166, 93%, 38%)",
          "#04ce1f", // elf green
          "hsl(159, 93%, 16%)",
          // red
          "hsl(2, 77%, 27%)",
          "hsl(350, 100%, 50%)",
          "hsl(356, 97%, 64%)",
          // brown
          "#ad4632",
          "#5b3b1d",
          // stripes
          ...make_stripe_patterns(false),
          // white to blue
          ...color_ramp(
            6,
            [200, 100, 100, 100],
            [200, 100, 10, 100],
          ),
          // pink
          "#fcbaf8",
          // silver
          "hsl(0, 0%, 90%)",
          "hsl(22, 5%, 71%)",
          // gold
          "hsl(48, 82%, 54%)",
          "hsl(49, 82%, 72%)",
          // stripes
          ...make_stripe_patterns(true),
        ];
        $colorbox.rebuild_palette();
      } else {
        palette = default_palette;
        $colorbox.rebuild_palette();
      }
    };

    $G.on("theme-load", update_palette_from_theme);
    update_palette_from_theme();

    function to_canvas_coords({
      clientX,
      clientY
    }) {
      const rect = canvas_bounding_client_rect;
      const cx = clientX - rect.left;
      const cy = clientY - rect.top;
      return {
        x: ~~(cx / rect.width * canvas.width),
        y: ~~(cy / rect.height * canvas.height),
      };
    }

    function update_fill_and_stroke_colors_and_lineWidth(selected_tool) {
      ctx.lineWidth = stroke_size;

      const reverse_because_fill_only = selected_tool.$options && selected_tool.$options.fill && !selected_tool.$options.stroke;
      ctx.fillStyle = fill_color =
        ctx.strokeStyle = stroke_color =
        colors[
          (ctrl && colors.ternary && pointer_active) ? "ternary" :
          ((reverse ^ reverse_because_fill_only) ? "background" : "foreground")
        ];

      fill_color_k =
        stroke_color_k =
        ctrl ? "ternary" : ((reverse ^ reverse_because_fill_only) ? "background" : "foreground");

      if (selected_tool.shape || selected_tool.shape_colors) {
        if (!selected_tool.stroke_only) {
          if ((reverse ^ reverse_because_fill_only)) {
            fill_color_k = "foreground";
            stroke_color_k = "background";
          } else {
            fill_color_k = "background";
            stroke_color_k = "foreground";
          }
        }
        ctx.fillStyle = fill_color = colors[fill_color_k];
        ctx.strokeStyle = stroke_color = colors[stroke_color_k];
      }
    }

    function tool_go(selected_tool, event_name) {
      update_fill_and_stroke_colors_and_lineWidth(selected_tool);

      if (selected_tool[event_name]) {
        selected_tool[event_name](ctx, pointer.x, pointer.y);
      }
      if (selected_tool.paint) {
        selected_tool.paint(ctx, pointer.x, pointer.y);
      }
    }

    function canvas_pointer_move(e) {
      ctrl = e.ctrlKey;
      shift = e.shiftKey;
      pointer = to_canvas_coords(e);

      // Quick Undo
      // (Note: pointermove also occurs when the set of buttons pressed changes,
      // except when another event would fire like pointerdown)
      if (pointers.length && e.button != -1) {
        // compare buttons other than middle mouse button by using bitwise OR to make that bit of the number the same
        const MMB = 4;
        if (e.pointerType != pointer_type || (e.buttons | MMB) != (pointer_buttons | MMB)) {
          cancel();
          pointer_active = false; // NOTE: pointer_active used in cancel()
          return;
        }
      }

      if (e.shiftKey) {
        if (selected_tool.name.match(/Line|Curve/)) {
          // snap to eight directions
          const dist = Math.sqrt(
            (pointer.y - pointer_start.y) * (pointer.y - pointer_start.y) +
            (pointer.x - pointer_start.x) * (pointer.x - pointer_start.x)
          );
          const eighth_turn = TAU / 8;
          const angle_0_to_8 = Math.atan2(pointer.y - pointer_start.y, pointer.x - pointer_start.x) / eighth_turn;
          const angle = Math.round(angle_0_to_8) * eighth_turn;
          pointer.x = Math.round(pointer_start.x + Math.cos(angle) * dist);
          pointer.y = Math.round(pointer_start.y + Math.sin(angle) * dist);
        } else if (selected_tool.shape) {
          // snap to four diagonals
          const w = Math.abs(pointer.x - pointer_start.x);
          const h = Math.abs(pointer.y - pointer_start.y);
          if (w < h) {
            if (pointer.y > pointer_start.y) {
              pointer.y = pointer_start.y + w;
            } else {
              pointer.y = pointer_start.y - w;
            }
          } else {
            if (pointer.x > pointer_start.x) {
              pointer.x = pointer_start.x + h;
            } else {
              pointer.x = pointer_start.x - h;
            }
          }
        }
      }
      selected_tools.forEach((selected_tool) => {
        tool_go(selected_tool);
      });
      pointer_previous = pointer;
    }
    $canvas.on("pointermove", e => {
      pointer = to_canvas_coords(e);
      $status_position.text(`${pointer.x},${pointer.y}`);
    });
    $canvas.on("pointerenter", () => {
      pointer_over_canvas = true;

      update_helper_layer();

      if (!update_helper_layer_on_pointermove_active) {
        $G.on("pointermove", update_helper_layer);
        update_helper_layer_on_pointermove_active = true;
      }
    });
    $canvas.on("pointerleave", () => {
      pointer_over_canvas = false;

      $status_position.text("");

      update_helper_layer();

      if (!pointer_active && update_helper_layer_on_pointermove_active) {
        $G.off("pointermove", update_helper_layer);
        update_helper_layer_on_pointermove_active = false;
      }
    });

    let clean_up_eye_gaze_mode = () => {};
    $G.on("eye-gaze-mode-toggled", () => {
      if ($("body").hasClass("eye-gaze-mode")) {
        init_eye_gaze_mode();
      } else {
        clean_up_eye_gaze_mode();
      }
    });
    if ($("body").hasClass("eye-gaze-mode")) {
      init_eye_gaze_mode();
    }

    function init_eye_gaze_mode() {
      const circle_radius_max = 50; // dwell indicator size in pixels
      const hover_timespan = 500; // how long between the dwell indicator appearing and triggering a click
      const averaging_window_timespan = 500;
      const inactive_at_startup_timespan = 1500; // (should be at least averaging_window_timespan, but more importantly enough to make it not awkward when enabling eye gaze mode)
      const inactive_after_release_timespan = 1000; // after click or drag release (from dwell or otherwise)
      const inactive_after_hovered_timespan = 1000; // after dwell click indicator appears; does not control the time to finish that dwell click, only to click on something else after this is canceled (but it doesn't control that directly)
      const inactive_after_invalid_timespan = 1000; // after a dwell click is canceled due to an element popping up in front, or existing in front at the center of the other element
      const inactive_after_focused_timespan = 1000; // after page becomes focused after being unfocused
      let recent_points = [];
      let inactive_until_time = Date.now();
      let paused = false;
      let $pause_button;
      let hover_candidate;
      let gaze_dragging = null;

      const deactivate_for_at_least = (timespan) => {
        inactive_until_time = Math.max(inactive_until_time, Date.now() + timespan);
      };
      deactivate_for_at_least(inactive_at_startup_timespan);

      const $halo = $("<div class='hover-halo'>").appendTo("body").hide();
      const $dwell_indicator = $("<div class='dwell-indicator'>").css({
        width: circle_radius_max,
        height: circle_radius_max,
      }).appendTo("body").hide();

      const on_pointer_move = (e) => {
        recent_points.push({
          x: e.clientX,
          y: e.clientY,
          time: Date.now()
        });
      };
      const on_pointer_up_or_cancel = (e) => {
        deactivate_for_at_least(inactive_after_release_timespan);
        gaze_dragging = null;
      };

      let page_focused = document.visibilityState === "visible"; // guess/assumption
      let mouse_inside_page = true; // assumption
      const on_focus = () => {
        page_focused = true;
        deactivate_for_at_least(inactive_after_focused_timespan);
      };
      const on_blur = () => {
        page_focused = false;
      };
      const on_mouse_leave_page = () => {
        mouse_inside_page = false;
      };
      const on_mouse_enter_page = () => {
        mouse_inside_page = true;
      };

      $G.on("pointermove", on_pointer_move);
      $G.on("pointerup pointercancel", on_pointer_up_or_cancel);
      $G.on("focus", on_focus);
      $G.on("blur", on_blur);
      $(document).on("mouseleave", on_mouse_leave_page);
      $(document).on("mouseenter", on_mouse_enter_page);

      const get_hover_candidate = (clientX, clientY) => {

        if (!page_focused || !mouse_inside_page) return null;

        let target = document.elementFromPoint(clientX, clientY);
        if (!target) {
          return null;
        }

        let hover_candidate = {
          x: clientX,
          y: clientY,
          time: Date.now(),
        };

        // top level menus are just immediately switched between for now
        // prevent awkward hover clicks on top level menu buttons while menus are open
        if (
          (target.closest(".menu-button") || target.matches(".menu-container")) &&
          $(".menu-button.active").length
        ) {
          return null;
        }

        const target_selector = `
			button:not([disabled]),
			input,
			textarea,
			label,
			a,
			.current-colors,
			.color-button,
			.tool:not(.selected),
			.chooser-option,
			.menu-button:not(.active),
			.menu-item,
			.main-canvas,
			.selection canvas,
			.handle,
			.window:not(.maximized) .window-titlebar,
			.history-entry,
			.canvas-area
		`;
        // .canvas-area is handled specially below
        // (it's not itself a desired target)

        target = target.closest(target_selector);

        if (!target) {
          return null;
        }

        if (target.matches(".color-button input")) {
          target = target.closest(".color-button");
        }

        // if (target.matches(".help-window li")) {
        // 	target = target.querySelector(".item");
        // }

        if (target === $canvas_area[0]) {
          // Nudge hovers near the edges of the canvas onto the canvas
          const margin = 50;
          if (
            hover_candidate.x > canvas_bounding_client_rect.left - margin &&
            hover_candidate.y > canvas_bounding_client_rect.top - margin &&
            hover_candidate.x < canvas_bounding_client_rect.right + margin &&
            hover_candidate.y < canvas_bounding_client_rect.bottom + margin
          ) {
            target = canvas;
            hover_candidate.x = Math.min(
              canvas_bounding_client_rect.right - 1,
              Math.max(
                canvas_bounding_client_rect.left,
                hover_candidate.x,
              ),
            );
            hover_candidate.y = Math.min(
              canvas_bounding_client_rect.bottom - 1,
              Math.max(
                canvas_bounding_client_rect.top,
                hover_candidate.y,
              ),
            );
          } else {
            return null;
          }
        } else if (!target.matches(".main-canvas, .selection canvas, .window-titlebar")) {
          // Nudge hover previews to the center of buttons and things
          const rect = target.getBoundingClientRect();
          hover_candidate.x = rect.left + rect.width / 2;
          hover_candidate.y = rect.top + rect.height / 2;
        }
        hover_candidate.target = target;
        return hover_candidate;
      };

      const update = () => {
        const time = Date.now();
        recent_points = recent_points.filter((point_record) => time < point_record.time + averaging_window_timespan);
        if (recent_points.length) {
          const latest_point = recent_points[recent_points.length - 1];
          recent_points.push({
            x: latest_point.x,
            y: latest_point.y,
            time
          });
          const average_point = average_points(recent_points);
          // debug
          // const canvas_point = to_canvas_coords({clientX: average_point.x, clientY: average_point.y});
          // ctx.fillStyle = "red";
          // ctx.fillRect(canvas_point.x, canvas_point.y, 10, 10);
          const recent_movement_amount = Math.hypot(latest_point.x - average_point.x, latest_point.y - average_point.y);

          // Invalidate in case an element pops up in front of the element you're hovering over, e.g. a submenu
          if (hover_candidate && !gaze_dragging) {
            const apparent_hover_candidate = get_hover_candidate(hover_candidate.x, hover_candidate.y);
            if (apparent_hover_candidate) {
              if (
                apparent_hover_candidate.target !== hover_candidate.target &&
                apparent_hover_candidate.target.closest("label") !== hover_candidate.target
              ) {
                hover_candidate = null;
                deactivate_for_at_least(inactive_after_invalid_timespan);
              }
            } else {
              hover_candidate = null;
              deactivate_for_at_least(inactive_after_invalid_timespan);
            }
          }

          let circle_position = latest_point;
          let circle_opacity = 0;
          let circle_radius = 0;
          if (hover_candidate) {
            circle_position = hover_candidate;
            circle_opacity = 0.4;
            circle_radius =
              (hover_candidate.time - time + hover_timespan) / hover_timespan *
              circle_radius_max;
            if (time > hover_candidate.time + hover_timespan) {
              if (pointer_active || gaze_dragging) {
                $(hover_candidate.target).trigger($.Event("pointerup", {
                  clientX: hover_candidate.x,
                  clientY: hover_candidate.y,
                  pointerId: 1234567890,
                  pointerType: "mouse",
                  button: 0,
                  buttons: 0,
                  isPrimary: true,
                }));
              } else {
                pointers = []; // prevent multi-touch panning
                $(hover_candidate.target).trigger($.Event("pointerdown", {
                  clientX: hover_candidate.x,
                  clientY: hover_candidate.y,
                  pointerId: 1234567890,
                  pointerType: "mouse",
                  button: 0,
                  buttons: 1,
                  isPrimary: true,
                }));
                const is_drag =
                  hover_candidate.target.matches(".window-titlebar, .window-titlebar *:not(button)") ||
                  hover_candidate.target.matches(".selection, .selection *, .handle") ||
                  (
                    hover_candidate.target === canvas &&
                    selected_tool.name !== "Pick Color" &&
                    selected_tool.name !== "Fill With Color" &&
                    selected_tool.name !== "Magnifier" &&
                    selected_tool.name !== "Polygon" &&
                    selected_tool.name !== "Curve"
                  );
                if (is_drag) {
                  gaze_dragging = hover_candidate.target;
                } else {
                  $(hover_candidate.target).trigger($.Event("pointerup", {
                    clientX: hover_candidate.x,
                    clientY: hover_candidate.y,
                    pointerId: 1234567890,
                    pointerType: "mouse",
                    button: 0,
                    buttons: 0,
                    isPrimary: true,
                  }));
                  if (hover_candidate.target.matches("button:not(.toggle)")) {
                    ((button) => {
                      button.style.borderImage = "var(--inset-deep-border-image)";
                      setTimeout(() => {
                        button.style.borderImage = "";
                        // delay the button click to here so the pressed state is
                        // visible even when the button closes a dialog
                        button.click();
                      }, 100);
                    })(hover_candidate.target);
                  } else {
                    hover_candidate.target.click();
                    if (hover_candidate.target.matches("input, textarea")) {
                      hover_candidate.target.focus();
                    }
                  }
                }
              }
              hover_candidate = null;
              deactivate_for_at_least(inactive_after_hovered_timespan);
            }
          }

          if (gaze_dragging) {
            $dwell_indicator.addClass("for-release");
          } else {
            $dwell_indicator.removeClass("for-release");
          }
          $dwell_indicator.show().css({
            opacity: circle_opacity,
            transform: `scale(${circle_radius / circle_radius_max})`,
            left: circle_position.x - circle_radius_max / 2,
            top: circle_position.y - circle_radius_max / 2,
          });

          let halo_target =
            gaze_dragging ||
            (hover_candidate || get_hover_candidate(latest_point.x, latest_point.y) || {}).target;

          if (halo_target && (!paused || $pause_button.is(halo_target))) {
            let rect = halo_target.getBoundingClientRect();
            // Clamp to visible region if in scrollable area
            // (could generalize to look for overflow: auto parents in the future)
            if (halo_target.closest(".canvas-area")) {
              const scroll_area_rect = $canvas_area[0].getBoundingClientRect();
              rect = {
                left: Math.max(rect.left, scroll_area_rect.left),
                top: Math.max(rect.top, scroll_area_rect.top),
                right: Math.min(rect.right, scroll_area_rect.right),
                bottom: Math.min(rect.bottom, scroll_area_rect.bottom),
              };
              rect.width = rect.right - rect.left;
              rect.height = rect.bottom - rect.top;
            }
            // this is so overkill just for border radius mimicry
            const computed_style = getComputedStyle(halo_target);
            const border_radius_scale = parseInt(
              (
                $(halo_target).closest(".component").css("transform") || ""
              ).match(/\d+/) || 1
            );
            $halo.css({
              display: "block",
              position: "fixed",
              left: rect.left,
              top: rect.top,
              width: rect.width,
              height: rect.height,
              // shorthand properties might not work in all browsers (not tested)
              // this is so overkill...
              borderTopRightRadius: parseFloat(computed_style.borderTopRightRadius) * border_radius_scale,
              borderTopLeftRadius: parseFloat(computed_style.borderTopLeftRadius) * border_radius_scale,
              borderBottomRightRadius: parseFloat(computed_style.borderBottomRightRadius) * border_radius_scale,
              borderBottomLeftRadius: parseFloat(computed_style.borderBottomLeftRadius) * border_radius_scale,
            });
          } else {
            $halo.hide();
          }

          if (time < inactive_until_time) {
            return;
          }
          if (recent_movement_amount < 5) {
            if (!hover_candidate) {
              hover_candidate = {
                x: average_point.x,
                y: average_point.y,
                time: Date.now(),
                target: gaze_dragging || null,
              };
              if (!gaze_dragging) {
                hover_candidate = get_hover_candidate(hover_candidate.x, hover_candidate.y);
              }
              if (hover_candidate && (paused && !$pause_button.is(hover_candidate.target))) {
                hover_candidate = null;
              }
            }
          }
          if (recent_movement_amount > 100) {
            if (gaze_dragging) {
              $G.trigger($.Event("pointerup", {
                clientX: average_point.x,
                clientY: average_point.y,
                pointerId: 1234567890,
                pointerType: "mouse",
                button: 0,
                buttons: 0,
                isPrimary: true,
              }));
              pointers = []; // prevent multi-touch panning
            }
          }
          if (recent_movement_amount > 60) {
            hover_candidate = null;
          }
        }
      };
      let raf_id;
      const animate = () => {
        raf_id = requestAnimationFrame(animate);
        update();
      };
      raf_id = requestAnimationFrame(animate);

      const $floating_buttons =
        $("<div/>")
        .appendTo("body")
        .css({
          position: "fixed",
          bottom: 0,
          left: 0,
          transformOrigin: "bottom left",
          transform: "scale(3)",
        });

      $("<button title='Undo'/>")
        .on("click", undo)
        .appendTo($floating_buttons)
        .css({
          width: 28,
          height: 28,
          verticalAlign: "bottom",
          position: "relative", // to make the icon's "absolute" relative to here
        })
        .append(
          $("<div>")
          .css({
            position: "absolute",
            left: 0,
            top: 0,
            width: 24,
            height: 24,
            backgroundImage: "url(images/classic/undo.svg)",
          })
        );

      // These are matched on exactly for speech recognition synonymization
      const pause_button_text = "Pause Dwell Clicking";
      const resume_button_text = "Resume Dwell Clicking";

      $pause_button = $(`<button title="${pause_button_text}"/>`)
        .on("click", () => {
          paused = !paused;
          $pause_button
            .attr("title", paused ? resume_button_text : pause_button_text)
            .find("div").css({
              backgroundImage: paused ?
                "url(images/classic/eye-gaze-unpause.svg)" : "url(images/classic/eye-gaze-pause.svg)",
            });
        })
        .appendTo($floating_buttons)
        .css({
          width: 28,
          height: 28,
          verticalAlign: "bottom",
          position: "relative", // to make the icon's "absolute" relative to here
        })
        .append(
          $("<div>")
          .css({
            position: "absolute",
            left: 0,
            top: 0,
            width: 24,
            height: 24,
            backgroundImage: "url(images/classic/eye-gaze-pause.svg)",
          })
        );

      clean_up_eye_gaze_mode = () => {
        console.log("Cleaning up / disabling eye gaze mode");
        cancelAnimationFrame(raf_id);
        $halo.remove();
        $dwell_indicator.remove();
        $floating_buttons.remove();
        $G.off("pointermove", on_pointer_move);
        $G.off("pointerup pointercancel", on_pointer_up_or_cancel);
        $G.off("focus", on_focus);
        $G.off("blur", on_blur);
        $(document).off("mouseleave", on_mouse_leave_page);
        $(document).off("mouseenter", on_mouse_enter_page);
        clean_up_eye_gaze_mode = () => {};
      };
    }

    let pan_start_pos;
    let pan_start_scroll_top;
    let pan_start_scroll_left;

    function average_points(points) {
      const average = {
        x: 0,
        y: 0
      };
      for (const pointer of points) {
        average.x += pointer.x;
        average.y += pointer.y;
      }
      average.x /= points.length;
      average.y /= points.length;
      return average;
    }
    $canvas_area.on("pointerdown", (event) => {
      if (pointers.every((pointer) =>
          // prevent multitouch panning in case of synthetic events from eye gaze mode
          pointer.pointerId !== 1234567890 &&
          // prevent multitouch panning in case of dragging across iframe boundary with a mouse/pen
          // Note: there can be multiple active primary pointers, one per pointer type
          !(pointer.isPrimary && (pointer.pointerType === "mouse" || pointer.pointerType === "pen"))
          // @TODO: handle case of dragging across iframe boundary with touch
        )) {
        pointers.push({
          pointerId: event.pointerId,
          pointerType: event.pointerType,
          // isPrimary not available on jQuery.Event, and originalEvent not available in synthetic case
          isPrimary: event.originalEvent && event.originalEvent.isPrimary || event.isPrimary,
          x: event.clientX,
          y: event.clientY,
        });
      }

      if (pointers.length == 2) {
        pan_start_pos = average_points(pointers);
        pan_start_scroll_top = $canvas_area.scrollTop();
        pan_start_scroll_left = $canvas_area.scrollLeft();
      }
      // Quick Undo when there are multiple pointers (i.e. for touch)
      // see pointermove for other pointer types
      if (pointers.length >= 2) {
        cancel();
        pointer_active = false; // NOTE: pointer_active used in cancel()
        return;
      }
    });
    $G.on("pointerup pointercancel", (event) => {
      pointers = pointers.filter((pointer) =>
        pointer.pointerId !== event.pointerId
      );
    });
    $G.on("pointermove", (event) => {
      for (const pointer of pointers) {
        if (pointer.pointerId === event.pointerId) {
          pointer.x = event.clientX;
          pointer.y = event.clientY;
        }
      }
      if (pointers.length >= 2) {
        const current_pos = average_points(pointers);
        const difference_in_x = current_pos.x - pan_start_pos.x;
        const difference_in_y = current_pos.y - pan_start_pos.y;
        $canvas_area.scrollLeft(pan_start_scroll_left - difference_in_x);
        $canvas_area.scrollTop(pan_start_scroll_top - difference_in_y);
      }
    });

    // window.onerror = show_error_message;

    $canvas.on("pointerdown", e => {
      update_canvas_rect();

      // Quick Undo when there are multiple pointers (i.e. for touch)
      // see pointermove for other pointer types
      // NOTE: this relies on event handler order for pointerdown
      // pointer is not added to pointers yet
      if (pointers.length >= 1) {
        cancel();
        pointer_active = false; // NOTE: pointer_active used in cancel()
        // in eye gaze mode, allow drawing with mouse after canceling gaze gesture with mouse
        pointers = pointers.filter((pointer) =>
          pointer.pointerId !== 1234567890
        );
        return;
      }

      history_node_to_cancel_to = current_history_node;

      pointer_active = !!(e.buttons & (1 | 2)); // as far as tools are concerned
      pointer_type = e.pointerType;
      pointer_buttons = e.buttons;
      $G.one("pointerup", () => {
        pointer_active = false;
        update_helper_layer();

        if (!pointer_over_canvas && update_helper_layer_on_pointermove_active) {
          $G.off("pointermove", update_helper_layer);
          update_helper_layer_on_pointermove_active = false;
        }
      });

      if (e.button === 0) {
        reverse = false;
      } else if (e.button === 2) {
        reverse = true;
      } else {
        return;
      }

      button = e.button;
      ctrl = e.ctrlKey;
      shift = e.shiftKey;
      pointer_start = pointer_previous = pointer = to_canvas_coords(e);

      const pointerdown_action = () => {
        let interval_ids = [];
        selected_tools.forEach((selected_tool) => {
          if (selected_tool.paint || selected_tool.pointerdown) {
            tool_go(selected_tool, "pointerdown");
          }
          if (selected_tool.paint_on_time_interval != null) {
            interval_ids.push(setInterval(() => {
              tool_go(selected_tool);
            }, selected_tool.paint_on_time_interval));
          }
        });

        $G.on("pointermove", canvas_pointer_move);

        $G.one("pointerup", (e, canceling) => {
          button = undefined;
          reverse = false;

          pointer = to_canvas_coords(e);
          selected_tools.forEach((selected_tool) => {
            selected_tool.pointerup && selected_tool.pointerup(ctx, pointer.x, pointer.y);
          });

          if (selected_tools.length === 1) {
            if (selected_tool.deselect) {
              select_tools(return_to_tools);
            }
          }
          $G.off("pointermove", canvas_pointer_move);
          for (const interval_id of interval_ids) {
            clearInterval(interval_id);
          }

          if (!canceling) {
            history_node_to_cancel_to = null;
          }
        });
      };

      pointerdown_action();

      update_helper_layer();
    });

    $canvas_area.on("pointerdown", e => {
      if (e.button === 0) {
        if ($canvas_area.is(e.target)) {
          if (selection) {
            deselect();
          }
        }
      }
    });

    function prevent_selection($el) {
      $el.on("mousedown selectstart contextmenu", (e) => {
        if (e.isDefaultPrevented()) {
          return;
        }
        if (
          e.target instanceof HTMLSelectElement ||
          e.target instanceof HTMLTextAreaElement ||
          (e.target instanceof HTMLLabelElement && e.type !== "contextmenu") ||
          (e.target instanceof HTMLInputElement && e.target.type !== "color")
        ) {
          return;
        }
        if (e.button === 1) {
          return; // allow middle-click scrolling
        }
        e.preventDefault();
        // we're just trying to prevent selection
        // but part of the default for mousedown is *deselection*
        // so we have to do that ourselves explicitly
        window.getSelection().removeAllRanges();
      });
    }

    prevent_selection($app);
    prevent_selection($toolbox);
    // prevent_selection($toolbox2);
    prevent_selection($colorbox);

    // Stop drawing (or dragging or whatver) if you Alt+Tab or whatever
    $G.on("blur", () => {
      $G.triggerHandler("pointerup");
    });
  </script>


  <script>
    if (/MSIE \d|Trident.*rv:/.test(navigator.userAgent)) {
      document.write(
        '<style>body { text-align: center; }</style>' +
        '<div className="not-supported">' +
        '<h1 className="not-supported-header">Internet Explorer is not supported!</h1>' +
        '<p className="not-supported-details">Try Chrome, Firefox, or Edge.</p>' +
        '</div>'
      );
    }
  </script>
  <noscript>
    <h1><img src="data:image/png;base64,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" width="32" height="32" alt=""> XP Paint</h1>

    <p>This application requires JavaScript to run.</p>

    <p>You can also check out <a href="https://github.com/assemblylanguage/xp-paint">the source code and project info</a>.</p>
  </noscript>

  <svg style="position: absolute;
pointer-events: none;
bottom: 100%;">
    <defs>
      <filter id="disabled-inset-filter" x="0" y="0" width="1px" height="1px">
        <feColorMatrix in="SourceGraphic" type="matrix" values="
							1 0 0 0 0
							0 1 0 0 0
							0 0 1 0 0
							-1000 -1000 -1000 1 0
						" result="black-parts-isolated"></feColorMatrix>
        <feFlood result="shadow-color" flood-color="var(--ButtonShadow)"></feFlood>
        <feFlood result="hilight-color" flood-color="var(--ButtonHilight)"></feFlood>
        <feOffset in="black-parts-isolated" dx="1" dy="1" result="offset"></feOffset>
        <feComposite in="hilight-color" in2="offset" operator="in" result="hilight-colored-offset"></feComposite>
        <feComposite in="shadow-color" in2="black-parts-isolated" operator="in" result="shadow-colored"></feComposite>
        <feMerge>
          <feMergeNode in="hilight-colored-offset"></feMergeNode>
          <feMergeNode in="shadow-colored"></feMergeNode>
        </feMerge>
      </filter>
    </defs>
  </svg>


</body>

</html>